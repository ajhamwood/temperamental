<!doctype html>
<html>
<head>
  <title>General isomorphic keyboard</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='music, xenharmony, xenrhythm, notation'>
  <meta name='description' content='Music notation experiment.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
html, body { height: 100% }
body {
  margin: 0;
  background-color: #000;
  overflow: hidden }
  canvas {
    width: 100dvw;
    height: 100dvh }
  </style>
</head>
<body>
  <canvas id="hex"></canvas>
  <script src="js/machine.js"></script>
  <script>

//Utils

const clamp = (min, max, val) => Math.max(min, Math.min(max, val)),
      lerp = (a, b, t) => a * (1 - t) + b * t,
      between = (min, max, val) => val <= max && val >= min,
      mod = (n, m) => ((n % m) + m) % m;

class HexButton {
  #g; #h; #grid; #osc; #volume; #noteClass

  constructor (g, h, noteClass, grid) {
    this.#g = g;
    this.#h = h;
    this.#grid = grid;
    this.#noteClass = noteClass
  }

  static vertices (g, h, grid) {
    const r = grid.r, x = grid.w / 2, y = grid.h / 2,
          k = .5 * Math.sqrt(3),
          origin = [
            [ x, y - r ], [ x - r * k, y - r / 2 ], [ x - r * k, y + r / 2 ],
            [ x, y + r ], [ x + r * k, y + r / 2 ], [ x + r * k, y - r / 2 ]
          ];
    return origin.map(([ a, b ]) => grid.rotate(
      Math.floor(a + r * k * (h + 2 * g)),
      Math.floor(b + 1.5 * r * h)
    ))
  }
  static centre (g, h, grid) {
    const { r, w: width, h: height } = grid, k = .5 * Math.sqrt(3);
    return grid.rotate(
      Math.floor(width / 2 + r * k * (h + 2 * g)),
      Math.floor(height / 2 + 1.5 * r * h)
    )
  }

  vertices () { return HexButton.vertices(this.#g, this.#h, this.#grid) }
  centre () { return HexButton.centre(this.#g, this.#h, this.#grid) }

  neighbours () {
    const g = this.#g, h = this.#h;
    return [
      [ g - 1, h ], [ g, h - 1 ], [ g + 1, h - 1 ],
      [ g + 1, h ], [ g, h + 1 ], [ g - 1, h + 1 ]
    ]
  }

  getCoord () { return [ this.#g, this.#h ] }

  setNoteClass (name) { this.#noteClass = name }
  getColour () { return this.#grid.noteClassColours[this.#noteClass] ?? "#222" }

  note () {
    const n = this.#g * this.#grid.gstep + this.#h * this.#grid.hstep, { edo } = this.#grid;
    return [ Math.floor(n / edo), (n % edo + edo) % edo ]
  }

  start () {
    const { audioctx, edo, masterVolume, wave, freqBasis, refNote, equaliser } = this.#grid, [ octave, steps ] = this.note(),
          osc = this.#osc = audioctx.createOscillator(),
          volume = this.#volume = audioctx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freqBasis * 2 ** (octave + ((refNote + steps) / edo));
    osc.connect(volume);
    volume.connect(equaliser);
    volume.gain.value = .0001;
    volume.gain.linearRampToValueAtTime(masterVolume, audioctx.currentTime + .05)
    osc.start(audioctx.currentTime)
  }

  stop () {
    const { audioctx } = this.#grid, osc = this.#osc, volume = this.#volume;
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime + .05);
    osc.stop(audioctx.currentTime + .05);
    this.#osc = null;
    this.#volume = null
  }

}

class HexGrid {
  w = 0; h = 0; unit = 50; r = this.unit * 2
  edo = 5; gstep = 2; hstep = 1; theta = 0
  #hexes = new Map(); #edges = new Set(); #notes = new Set()
  noteClassColours = { middle: "#333" }
  audioctx; masterVolume; freqBasis; refNote
  equaliser

  constructor (opts = {}) {
    Object.assign(this, opts);
    // this.#edges.add(this.#newHex(0, 0))
  }

  #newHex (g, h, noteClass) {
    const row = this.#hexes.get(g) ?? this.#hexes.set(g, new Map()).get(g),
          hex = new HexButton(g, h, noteClass, this);
    row.set(h, hex);
    return hex
  }

  setCentre (w, h) {
    this.w = w;
    this.h = h
  }

  getHex (g, h) { return this.#hexes.get(g)?.get(h) }

  hasHex (g, h) { return this.#hexes.get(g)?.has(h) ?? false }

  * [Symbol.iterator] () { for (let [ , row ] of this.#hexes) for (let [ , hex ] of row) yield hex }

  updateGrid () {
    const { gstep, hstep, edo, w } = this, res = [];

    // Generate orientations
    for (let y = 0; y <= edo / hstep; y++) {
      const x = (edo - hstep * y) / gstep;
      if (x === Math.floor(x)) res.push ([ x, y ])
    }
    const [ g, h ] = res[0],  // Also can swap g and h
          x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5,
          octLen = Math.hypot(x, y);
    this.theta = Math.atan(y / x);
    this.r = Math.min(this.unit * 2, w / (octLen + 2) / 2)
    
    // Central line
    this.#edges.add(this.#newHex(0, 0, "middle"));
    this.#notes.add(0);
    let left = .5, right = .5, focus = [ [0, 0], [0, 0] ];
    for (let i = 1; i <= g + h; i++) {
      if (left / i <= h / (g + h)) { left++; focus[0][1]++ } else focus[0][0]++;
      if (right / i < h / (g + h)) { right++; focus[1][1]++ } else focus[1][0]++;
      this.#edges.add(this.#newHex(...focus[0], "middle"));
      this.#notes.add(focus[0][0] * gstep + focus[0][1] * hstep);
      if (focus[0].every((v, i) => v === focus[1][i])) continue
      this.#edges.add(this.#newHex(...focus[1], "middle"));
      this.#notes.add(focus[1][0] * gstep + focus[1][1] * hstep)
    }

    // One octave
    this.fillGrid((g, h, { newNotes }) => HexButton.centre(g, h, this)[0] - this.w / 2 >= 0 &&
      !~[ ...newNotes ].findIndex(note => mod(g * gstep + h * hstep - note, edo) === 0));

    // Fill to sides
    const home = [ ...this ];
    this.fillGrid((g0, h0) => {
      const near = ~home.findIndex(hex => {
              const [ baseG, baseH ] = hex.getCoord();
              return (baseG - g0) * h === (baseH - h0) * g  // require gcd(g, h) === 1
            });
      return near && HexButton.vertices(g0, h0, this).some(([ px, py ]) =>
        px > 0 && px < this.w && py > 0 && py < this.h)
    })
  }

  fillGrid (isInside) {
    let viewEdges = new Set([ ...this.#edges ]);
    while (viewEdges.size > 0) {
      let newEdges = new Set([ ...this.#edges ]),
          newViewEdges = new Set([ ...viewEdges ]),
          newNotes = new Set([ ...this.#notes ]);
      for (let hex of viewEdges) {  // Can I get all candidate new hexes first?
        let remove = true;
        for (let [g, h] of hex.neighbours()) {
          const thisHex = this.getHex(g, h);
          if (thisHex) { if (viewEdges.has(thisHex)) newViewEdges.delete(thisHex) }
          else {
            if (isInside(g, h, { newEdges, newViewEdges, newNotes })) {
              const nextHex = this.#newHex(g, h);
              newViewEdges.add(nextHex);
              newEdges.add(nextHex);
              newNotes.add(g * this.gstep + h * this.hstep)
            } else remove = false;
          }
        }
        newViewEdges.delete(hex)
        if (remove) newEdges.delete(hex)
      }
      viewEdges = newViewEdges;
      this.#edges = newEdges;
      this.#notes = newNotes
    }
  }

  rotate (x, y, rev = false) {
    const cx = this.w / 2, cy = this.h / 2, theta = rev ? -this.theta : this.theta,
          cos = Math.cos(theta), sin = Math.sin(theta);
    return [ cos * (x - cx) + sin * (y - cy) + cx, cos * (y - cy) - sin * (x - cx) + cy ]
  }

  getCoord (x, y) {
    ([ x, y ] = this.rotate(x * 2, y * 2, true));
    const { r, w: width, h: height } = this,
          a = (x - width / 2) / r / Math.sqrt(3) * 2,
          b = (y - height / 2) / r * 2,
          band = Math.floor(Math.floor((b + 1) / 3));
    if (((Math.floor(b % 3)) + 3) % 3 === 1) {
      const clampedA = ((a % 1) + 1) % 1, clampedB = ((b % 1) + 1) % 1,
            topLeft = clampedA + clampedB > 1, bottomLeft = clampedA < clampedB,
            h = 2 * Math.floor((b + 4) / 6), g = Math.floor((a - h) / 2);
      if (band % 2) return Math.floor(a) % 2 ? [ g + 1, h - !topLeft ] : [ g + !bottomLeft, h - !bottomLeft ];
      else return Math.floor(a) % 2 ? [ g + !bottomLeft, h + bottomLeft ] : [ g, h + topLeft ]
    } else return [ Math.floor((a - band + 1) / 2), band ]
  }

}

class Equaliser {
  iso_freq = [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000];
  iso_curves = {
    0: [76.55, 65.62, 55.12, 45.53, 37.63, 30.86, 25.02, 20.51, 16.65, 13.12, 10.09, 7.54, 5.11, 3.06, 1.48, 0.3, -0.3, -0.01, 1.03, -1.19, -4.11, -7.05, -9.03, -8.49, -4.48, 3.28, 9.83, 10.48, 8.38, 14.1, 79.65],
    10: [83.75, 75.76, 68.21, 61.14, 54.96, 49.01, 43.24, 38.13, 33.48, 28.77, 24.84, 21.33, 18.05, 15.14, 12.98, 11.18, 9.99, 10, 11.26, 10.43, 7.27, 4.45, 3.04, 3.8, 7.46, 14.35, 20.98, 23.43, 22.33, 25.17, 81.47],
    20: [89.58, 82.65, 75.98, 69.62, 64.02, 58.55, 53.19, 48.38, 43.94, 39.37, 35.51, 31.99, 28.69, 25.67, 23.43, 21.48, 20.1, 20.01, 21.46, 21.4, 18.15, 15.38, 14.26, 15.14, 18.63, 25.02, 31.52, 34.43, 33.04, 34.67, 84.18],
    40: [99.85, 93.94, 88.17, 82.63, 77.78, 73.08, 68.48, 64.37, 60.59, 56.7, 53.41, 50.4, 47.58, 44.98, 43.05, 41.34, 40.06, 40.01, 41.82, 42.51, 39.23, 36.51, 35.61, 36.65, 40.01, 45.83, 51.8, 54.28, 51.49, 51.96, 92.77],
    60: [109.51, 104.23, 99.08, 94.18, 89.96, 85.94, 82.05, 78.65, 75.56, 72.47, 69.86, 67.53, 65.39, 63.45, 62.05, 60.81, 59.89, 60.01, 62.15, 63.19, 59.96, 57.26, 56.42, 57.57, 60.89, 66.36, 71.66, 73.16, 68.63, 68.43, 104.92],
    80: [118.99, 114.23, 109.65, 105.34, 101.72, 98.36, 95.17, 92.48, 90.09, 87.82, 85.92, 84.31, 82.89, 81.68, 80.86, 80.17, 79.67, 80.01, 82.48, 83.74, 80.59, 77.88, 77.07, 78.31, 81.62, 86.81, 91.41, 91.74, 85.41, 84.67, 118.95],
    100: [128.41, 124.15, 120.11, 116.38, 113.35, 110.65, 108.16, 106.17, 104.48, 103.03, 101.85, 100.97, 100.3, 99.83, 99.62, 99.5, 99.44, 100.01, 102.81, 104.25, 101.18, 98.48, 97.67, 99, 102.3, 107.23, 111.11, 110.23, 102.07, 100.83, 133.73]
  }
  audioctx
  constructor (audioctx) { this.audioctx = audioctx }
  createFilter (phons, reso) {
    phons = clamp(0, 100, phons);
    reso = clamp(2, 31, reso);
    const { audioctx } = this,
          ixs = Array(reso).fill().map((_, i) => Math.round(i * 30 / (reso - 1))),
          freqs = ixs.map(i => this.iso_freq[i]),
          [ j, t ] = phons < 20 ?
            [ 10 * Math.floor(phons / 10), (phons / 10) % 1 ] :
            [ 20 * Math.floor(phons / 20), (phons / 20) % 1 ],
          levels = ixs.map(i => j === 100 ? this.iso_curves[100][i] : lerp(this.iso_curves[j][i], this.iso_curves[phons < 20 ? j + 10 : j + 20][i], t)),
          eqDest = ixs.reduce((prev, x, i) => {
            const filter = audioctx.createBiquadFilter(),
                  middle = freqs[i], from = i === 0 ? Math.max(10, freqs[0] ** 1.5 / Math.sqrt(freqs[1])) : Math.sqrt(freqs[i - 1] * freqs[i]),
                  to = i === ixs.length - 1 ? Math.min(audioctx.sampleRate, freqs[i] ** 1.5 / Math.sqrt(freqs[i - 1])): Math.sqrt(freqs[i] * freqs[i + 1]);
            filter.type = "peaking";
            filter.frequency.value = middle;
            filter.Q.value = middle / (to - from);
            filter.gain.value = clamp(-40, 40, levels[i] / 2 - phons);
            filter.connect(prev);
            return filter
          }, audioctx.destination);
    return eqDest
  }
}


// Page state
var app = new $.Machine({
  gridctx: null,
  hexGrid: null,
  activeHexes: new Map(),
  gridTouches: new Map(),
  mousedown: false
});

// Events
$.targets({

  load () { app.emit("init") },

  resize () { app.emit("resize") },

  "touchstart* touchend* touchmove*" (e) {
    e.preventDefault();
    if (app.hexGrid.hasHex(...app.hexGrid.getCoord(e.changedTouches[0].clientX, e.changedTouches[0].clientY)) || e.type === "touchend")
      app.emit("press", e.type.slice(5), e.changedTouches)
  },

  mousedown (e) {
    app.mousedown = true;
    app.emit("press", "start", [e]);
  },
  mousemove (e) {
    if (app.mousedown && app.hexGrid.hasHex(...app.hexGrid.getCoord(e.clientX, e.clientY)))
      app.emit("press", "move", [e])
  },
  "mouseup mouseout" (e) {
    if (!app.mousedown || e.type === "mouseout") return
    app.mousedown = false;
    app.emit("press", "end", [e]);
  },

  app: {

    init () { // presets: 12,2,1; 19,3,2; 22,4,1; 31,5,3; 41,7,3; 53,9,4
      this.canvas = $("#hex");
      this.gridctx = this.canvas.getContext("2d");
      const audioctx = new AudioContext();
      this.hexGrid = new HexGrid({
        unit: 45, edo: 31, gstep: 5, hstep: 3,
        audioctx, masterVolume: .1, freqBasis: 220, refNote: 23,
        equaliser: audioctx.destination//new Equaliser(audioctx).createFilter(40, 31)
      });
      app.emit("resize");
    },

    resize () {
      $("canvas").width = innerWidth * 2;
      $("canvas").height = innerHeight * 2;
      const { hexGrid, gridctx } = this;
      hexGrid.setCentre(innerWidth * 2, innerHeight * 2);
      hexGrid.updateGrid();
      gridctx.reset();
      gridctx.textBaseline = "middle";
      gridctx.font = (.4 * hexGrid.r) + "px sans";
      gridctx.strokeStyle = "#ddd";
      for (let hex of hexGrid) app.emit("colourHex", hex, hex.getColour(), "#ddd")
    },

    colourHex (hex, bgColour, txColour) {
      const { gridctx } = this, vertices = hex.vertices();
      gridctx.beginPath();
      gridctx.moveTo(...vertices[5]);
      for (let [ x, y ] of vertices) gridctx.lineTo(x, y);
      gridctx.fillStyle = bgColour;
      gridctx.fill();
      gridctx.stroke();
      const label = hex.note()[1], [ x, y ] = hex.centre(),
            { width } = gridctx.measureText(label);
      gridctx.fillStyle = txColour;
      gridctx.fillText(label, x - width / 2, y)
    },

    press (type, touches) {
      const { hexGrid, activeHexes, gridTouches } = this;
      for (let t of touches) {
        let hex, ids;
        const coord = hexGrid.getCoord(t.clientX, t.clientY);
        switch (type) {

          case "start":
            hex = hexGrid.getHex(...coord);
            app.emit("colourHex", hex, "yellow", "#222");
            if (!activeHexes.has(hex)) hex.start();
            activeHexes.set(hex, (activeHexes.get(hex) ?? new Set()).add(t.identifier));
            gridTouches.set(t.identifier, hex);
            break;

          case "move":
            hex = gridTouches.get(t.identifier);
            ids = activeHexes.get(hex);
            if (hex.getCoord().some((v, i) => v !== coord[i])) {
              ids.delete(t.identifier);
              if (ids.size === 0) {
                hex.stop();
                activeHexes.delete(hex);
                app.emit("colourHex", hex, hex.getColour(), "#ddd");
              }
              hex = hexGrid.getHex(...coord);
              app.emit("colourHex", hex, "yellow", "#222");
              if (!activeHexes.has(hex)) hex.start();
              activeHexes.set(hex, (activeHexes.get(hex) ?? new Set()).add(t.identifier));
              gridTouches.set(t.identifier, hex)
            }
            break

          case "end":
            hex = gridTouches.get(t.identifier);
            ids = activeHexes.get(hex);
            ids.delete(t.identifier);
            if (ids.size === 0) {
              hex.stop();
              activeHexes.delete(hex);
              app.emit("colourHex", hex, hex.getColour(), "#ddd")
            }
            gridTouches.delete(t.identifier)
            
        }
      }
    }

  }
});

$.queries({})
  </script>
  <noscript><h6>Only viewable with JavaScript enabled.</h6></noscript>
</body>
</html>