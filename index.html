<!doctype html>
<html>
<head>
  <title>Temperamental ⁂ Microtonal music explorer</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='music, xenharmony, xenrhythm'>
  <meta name='description' content='Web app for composing, playing, and noodling on microtonal music.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
html, body {height: 100dvh }
body {
  margin: 0;
  background-color: #222;
  color: #ddd;
  display: grid;
  grid: "nav" auto "menu" 0 "main" 1fr;
  overflow: hidden;
  touch-action: none }
  body.menuActive { grid-template-rows: auto auto 1fr }
  nav {
    display: flex;
    flex-flow: column }
    nav > * {
      padding: .5em;
      flex-flow: row;
      justify-content: space-between }
    #controls { display: flex }
      #volume > * { vertical-align: middle }
    nav:focus-within:not(:has(:is(#panic, #volume > input):focus)) > #dropdown,
    body.menuActive #dropdown { display: flex }
    #dropdown {
      display: none;
      background-color: #000 }
  menu {
    padding: 0;
    margin: 0 }
    menu > * { padding: .5em }
    #breadcrumbs {
      background-color: #ddd;
      color: #222;
      display: flex;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
      #breadcrumb-text { font-size: small }
      #breadcrumb-text::before { content: "// " }
    form {
      display: flex;
      flex-flow: row wrap;
      align-items: start }
      fieldset {
        display: flex;
        flex-flow: column }
        fieldset > * { margin: .3em }
        input[type="number"] { width: 3.5em }
        select:has(option[value=""]:checked) { color: #666 }
  main {
    background-color: #000;
    overflow: hidden }
    canvas {
      width: 100%;
      height: 100% }
  </style>
</head>
<body>
  <nav tabindex="0">
    <div id="dropdown">
      <div id="keyboard-select">
        <span>Keyboard</span>
        <select></select>
        <button id="keyboard-settings-button" type="button">⚙️</button>
      </div>
      <div id="track-select">
        <span>Track</span>
        <select>
          <option>None</option>
        </select>
      </div>
      <button type="button">ⓘ</button>
    </div>
    <div id="controls">
      <div id="volume">
        <span>Volume</span>
        <input type="range" min="0" max="100" step="1">
      </div>
      <button id="panic" type="button">Panic</div>
    </div>
  </nav>
  <menu>
    <li id="breadcrumbs">
      <span id="breadcrumb-text"></span>
      <div>
        <button id="menu-cancel" type="button">Cancel</button>
        <button id="menu-apply" type="button">Apply</button>
      </div>
    </li>
    <li id="menu-display">
      <form id="keyboard-settings">
        <fieldset>
          <legend>Shape</legend>
          <label id="gstep">Horizontal steps: <input type="number" min="0" step="1"></label>
          <label id="hstep">Diagonal steps: <input type="number" min="0" step="1"></label>
          <label id="orientation">Orientation:
            <select>
              <option value="">Choose</option>
            </select>
          </label>
          <label id="unit">Key size: <input type="number" min="5" step="1"> px</label>
        </fieldset>
        <fieldset>
          <legend>Note</legend>
          <label id="refNote">Tuning root note: <input type="number" min="0" step="1"></label>
          <label id="freqBasis">Tuning root frequency: <input type="number" min="10" max="40000"> Hz</label>
          <div>Scale:
            <label id="edo">Divisions of octave: <input type="number" min="1" step="1"></label>
            <button type="button">Advanced</button>
          </div>
        </fieldset>
        <fieldset>
          <legend>Waveform</legend>
          <label id="instrument">Output:
            <select>
              <option value="osc">Local</option>
              <option value="midi">MIDI</option>
            </select>
          </label>
          <label id="instrument-option">
            <span>Oscillator</span>
            <select>
              <option value="custom">Custom</option>
            </select>
            <button type="button">Choose</button>
          </label>
        </fieldset>
      </form>
    </li>
  </menu>
  <main>
    <canvas id="hex"></canvas>
  </main>
  <template id="option">
    <option></option>
  </template>
  <script src="js/machine.js"></script>
  <script>

//Utils

const clamp = (min, max, val) => Math.max(min, Math.min(max, val)),
      lerp = (a, b, t) => a * (1 - t) + b * t,
      between = (min, max, val) => val <= max && val >= min,
      mod = (n, m) => ((n % m) + m) % m,
      gcd = (a, b) => !b ? a : gcd(b, a % b);

class HexButton {
  #g; #h; #grid; #osc; #volume; #noteClass

  constructor (g, h, noteClass, grid) {
    this.#g = g;
    this.#h = h;
    this.#grid = grid;
    this.#noteClass = noteClass
  }

  static vertices (g, h, grid) {
    const r = grid.r, x = grid.w / 2, y = grid.h / 2,
          k = .5 * Math.sqrt(3),
          origin = [
            [ x, y - r ], [ x - r * k, y - r / 2 ], [ x - r * k, y + r / 2 ],
            [ x, y + r ], [ x + r * k, y + r / 2 ], [ x + r * k, y - r / 2 ]
          ];
    return origin.map(([ a, b ]) => grid.rotate(
      Math.floor(a + r * k * (h + 2 * g)),
      Math.floor(b + 1.5 * r * h)
    ))
  }
  static centre (g, h, grid) {
    const { r, w: width, h: height } = grid, k = .5 * Math.sqrt(3);
    return grid.rotate(
      Math.floor(width / 2 + r * k * (h + 2 * g)),
      Math.floor(height / 2 + 1.5 * r * h)
    )
  }

  vertices () { return HexButton.vertices(this.#g, this.#h, this.#grid) }
  centre () { return HexButton.centre(this.#g, this.#h, this.#grid) }

  neighbours () {
    const g = this.#g, h = this.#h;
    return [
      [ g - 1, h ], [ g, h - 1 ], [ g + 1, h - 1 ],
      [ g + 1, h ], [ g, h + 1 ], [ g - 1, h + 1 ]
    ]
  }

  getCoord () { return [ this.#g, this.#h ] }

  setNoteClass (name) { this.#noteClass = name }
  getColour () { return this.#grid.noteClassColours[this.#noteClass] ?? "#222" }

  note () {
    const n = this.#g * this.#grid.gstep + this.#h * this.#grid.hstep, { edo } = this.#grid;
    return [ Math.floor(n / edo), (n % edo + edo) % edo ]
  }

  start () {
    const { audioctx, masterVolume } = app.state(),
          { edo, freqBasis, refNote } = this.#grid, [ octave, steps ] = this.note(),
          osc = this.#osc = audioctx.createOscillator(),
          volume = this.#volume = audioctx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freqBasis * 2 ** (octave + ((refNote + steps) / edo));
    osc.connect(volume);
    volume.connect(masterVolume);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime)
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime + .05)
    osc.start(audioctx.currentTime)
  }

  stop () {
    const { audioctx } = app.state(), osc = this.#osc, volume = this.#volume;
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime + .05);
    osc.stop(audioctx.currentTime + .05);
    this.#osc = null;
    this.#volume = null
  }

}

class HexGrid {
  w = 0; h = 0; unit = 50; r = this.unit * 2
  edo = 5; gstep = 2; hstep = 1; orientations = []; theta = 0
  #hexes = new Map(); #edges = new Set(); #notes = new Set()
  noteClassColours = { middle: "#333" }
  freqBasis; refNote; orientation

  constructor (opts = {}) {
    Object.assign(this, opts);
    if ("orientation" in opts) this.setOrientation(...opts.orientation)
    // this.#edges.add(this.#newHex(0, 0))
  }

  #newHex (g, h, noteClass) {
    const row = this.#hexes.get(g) ?? this.#hexes.set(g, new Map()).get(g),
          hex = new HexButton(g, h, noteClass, this);
    row.set(h, hex);
    return hex
  }

  getHex (g, h) { return this.#hexes.get(g)?.get(h) }
  hasHex (g, h) { return this.#hexes.get(g)?.has(h) ?? false }

  * [Symbol.iterator] () { for (let [ , row ] of this.#hexes) for (let [ , hex ] of row) yield hex }

  genOrientations () {
    const { gstep, hstep, edo } = this, res = [];
    for (let y = 0; y <= edo / hstep; y++) {
      const x = (edo - hstep * y) / gstep;
      if (x === Math.floor(x)) res.push ([ x, y ])
    }
    this.orientations = res;
  }
  setOrientation (g, h) {
    this.orientation = [ g, h ];
    const { unit, w } = this, x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5;
    this.theta = Math.atan(y / x)
  }

  updateGrid () {
    const { gstep, hstep, edo, w } = this, [ g, h ] = this.orientation,
          octLen = Math.hypot((2 * g + h) * Math.sqrt(3) / 2, h * 1.5);

    // Central line
    this.#edges.add(this.#newHex(0, 0, "middle"));
    this.#notes.add(0);
    let left = .5, right = .5, focus = [ [0, 0], [0, 0] ];
    for (let i = 1; i <= g + h; i++) {
      if (left / i <= h / (g + h)) { left++; focus[0][1]++ } else focus[0][0]++;
      if (right / i < h / (g + h)) { right++; focus[1][1]++ } else focus[1][0]++;
      this.#edges.add(this.#newHex(...focus[0], "middle"));
      this.#notes.add(focus[0][0] * gstep + focus[0][1] * hstep);
      if (focus[0].every((v, i) => v === focus[1][i])) continue
      this.#edges.add(this.#newHex(...focus[1], "middle"));
      this.#notes.add(focus[1][0] * gstep + focus[1][1] * hstep)
    }

    // One octave
    this.fillGrid((g, h, { newNotes }) => HexButton.centre(g, h, this)[0] - this.w / 2 >= 0 &&
      !~[ ...newNotes ].findIndex(note => mod(g * gstep + h * hstep - note, edo) === 0));

    // Fill to sides
    const home = [ ...this ];
    this.fillGrid((g0, h0) => {
      const near = ~home.findIndex(hex => {
              const [ baseG, baseH ] = hex.getCoord();
              return (baseG - g0) * h === (baseH - h0) * g  // require gcd(g, h) === 1
            });
      return near && HexButton.vertices(g0, h0, this).some(([ px, py ]) =>
        px > 0 && px < this.w && py > 0 && py < this.h)
    })
  }

  fillGrid (isInside) {
    let viewEdges = new Set([ ...this.#edges ]);
    while (viewEdges.size > 0) {
      let newEdges = new Set([ ...this.#edges ]),
          newViewEdges = new Set([ ...viewEdges ]),
          newNotes = new Set([ ...this.#notes ]);
      for (let hex of viewEdges) {  // Can I get all candidate new hexes first?
        let remove = true;
        for (let [g, h] of hex.neighbours()) {
          const thisHex = this.getHex(g, h);
          if (thisHex) { if (viewEdges.has(thisHex)) newViewEdges.delete(thisHex) }
          else {
            if (isInside(g, h, { newEdges, newViewEdges, newNotes })) {
              const nextHex = this.#newHex(g, h);
              newViewEdges.add(nextHex);
              newEdges.add(nextHex);
              newNotes.add(g * this.gstep + h * this.hstep)
            } else remove = false;
          }
        }
        newViewEdges.delete(hex)
        if (remove) newEdges.delete(hex)
      }
      viewEdges = newViewEdges;
      this.#edges = newEdges;
      this.#notes = newNotes
    }
  }

  rotate (x, y, rev = false) {
    const cx = this.w / 2, cy = this.h / 2, theta = rev ? -this.theta : this.theta,
          cos = Math.cos(theta), sin = Math.sin(theta);
    return [ cos * (x - cx) + sin * (y - cy) + cx, cos * (y - cy) - sin * (x - cx) + cy ]
  }

  getCoord (x, y) {
    ([ x, y ] = this.rotate(x * 2, y * 2, true));
    const { r, w: width, h: height } = this,
          a = (x - width / 2) / r / Math.sqrt(3) * 2,
          b = (y - height / 2) / r * 2,
          band = Math.floor(Math.floor((b + 1) / 3));
    if (((Math.floor(b % 3)) + 3) % 3 === 1) {
      const clampedA = ((a % 1) + 1) % 1, clampedB = ((b % 1) + 1) % 1,
            topLeft = clampedA + clampedB > 1, bottomLeft = clampedA < clampedB,
            h = 2 * Math.floor((b + 4) / 6), g = Math.floor((a - h) / 2);
      if (band % 2) return Math.floor(a) % 2 ? [ g + 1, h - !topLeft ] : [ g + !bottomLeft, h - !bottomLeft ];
      else return Math.floor(a) % 2 ? [ g + !bottomLeft, h + bottomLeft ] : [ g, h + topLeft ]
    } else return [ Math.floor((a - band + 1) / 2), band ]
  }
}

// Page state
var app = new $.Machine({
    // Navigation
      menuState: [],
      keyboards: {
        "12edo": {
          gstep: 2, hstep: 1, orientations: [[6,0],[5,2],[4,4],[3,6],[2,8],[1,10],[0,12]], orientation: [5, 2], unit: 45,
          refNote: 9, freqBasis: 220, edo: 12, instrument: "triangle"
        },
        "19edo": {
          gstep: 3, hstep: 2, orientations: [[5,2],[3,5],[1,8]], orientation: [5, 2], unit: 45,
          refNote: 14, freqBasis: 220, edo: 19, instrument: "triangle"
        },
        "22edo": {
          gstep: 4, hstep: 1, orientations: [[5,2],[4,6],[3,10],[2,14],[1,18],[0,22]], orientation: [5, 2], unit: 45,
          refNote: 16, freqBasis: 220, edo: 22, instrument: "triangle"
        },
        "31edo": {
          gstep: 5, hstep: 3, orientations: [[5,2],[2,7]], orientation: [5, 2], unit: 45,
          refNote: 23, freqBasis: 220, edo: 31, instrument: "triangle"
        },
        "41edo": {
          gstep: 7, hstep: 3, orientations: [[5,2],[2,9]], orientation: [5, 2], unit: 45,
          refNote: 30, freqBasis: 220, edo: 41, instrument: "triangle"
        },
        "53edo": {
          gstep: 9, hstep: 4, orientations: [[5,2],[1,11]], orientation: [5, 2], unit: 45,
          refNote: 39, freqBasis: 220, edo: 53, instrument: "triangle"
        },
      },

    // Keyboard
      keyboardSelection: null,
      keyboard: null,
      gridctx: null,
      hexGrid: null,
      activeHexes: new Map(),
      gridTouches: new Map(),
      mousedown: false,
      audioctx: null,
      masterVolume: null
    });

// Events
$.targets({

  load () { app.emit("init") },

  keydown (e) { if (e.key === "Escape") document.activeElement.blur() },

  resize () {
    app.emit("resize");
    app.emit("redraw")
  },

  contextmenu (e) { e.preventDefault() },

  "touchstart touchend touchmove" (e) {
    const nav = $("canvas");
    if ( e.type === "touchstart" && document.activeElement === nav && !e.composedPath().includes(nav)) $(nav).blur();
    const canvas = $("canvas");
    if (e.target !== canvas) return;
    for (let { clientX, clientY, identifier } of e.changedTouches) {
      const x = clientX - canvas.offsetLeft, y = clientY - canvas.offsetTop;
      if ((app.gridTouches.has(identifier) || e.type === "touchstart") &&
        (app.hexGrid.hasHex(...app.hexGrid.getCoord(x, y)) || e.type === "touchend"))
        app.emit("press", e.type.slice(5), x, y, identifier)
    }
  },

  mousedown (e) {
    if (e.target !== $("canvas")) return;
    if (!app.hexGrid.hasHex(...app.hexGrid.getCoord(e.layerX, e.layerY))) return;
    app.mousedown = true;
    app.emit("press", "start", e.layerX, e.layerY);
  },
  mousemove (e) {
    if (app.mousedown && app.hexGrid.hasHex(...app.hexGrid.getCoord(e.layerX, e.layerY)))
      app.emit("press", "move", e.layerX, e.layerY)
  },
  "mouseup mouseout" (e) {
    if (!app.mousedown || e.type === "mouseout") return
    app.mousedown = false;
    app.emit("press", "end", e.layerX, e.layerY);
  },

  app: {

    init () {
      this.canvas = $("#hex");
      new ResizeObserver(() => {
        app.emit("resize")
        app.emit("redraw")
      }).observe($("main"));
      this.gridctx = this.canvas.getContext("2d");
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
      app.emit("load-presets");
      app.emit("load-keyboard")
    },

    "clear-storage" () { localStorage.clear() },

    "load-presets" () {
      let keyboards = localStorage.getItem("keyboards");
      if (!keyboards) {
        keyboards = this.keyboards;
        localStorage.setItem("keyboards", JSON.stringify(keyboards))
      } else keyboards = this.keyboards = JSON.parse(keyboards)
      Object.keys(keyboards).forEach(name => {
        const el = $.load("option", "#keyboard-select > select")[0][0]
        el.innerText = name;
        el.setAttribute("name", name)
      });
      const customKeybOptEl = $.load("option", "#keyboard-select > select")[0][0]
      customKeybOptEl.innerText = "Custom";
      customKeybOptEl.setAttribute("name", "Custom");

      let keyboardSelection = localStorage.getItem("keyboardSelection");
      if (!keyboardSelection) {
        keyboardSelection = Object.keys(app.keyboards)[0];
        localStorage.setItem("keyboardSelection", keyboardSelection)
      } else keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value = keyboardSelection;
      
      this.keyboard = keyboardSelection === "Custom" ? JSON.parse(localStorage.getItem("keyboard")) : keyboards[keyboardSelection];
      app.emit("fill-keyboard-settings", this.keyboard)
    },

    "fill-keyboard-settings" ({ unit, edo, gstep, hstep, freqBasis, refNote, orientation, orientations }) {
      $("#gstep > input").value = gstep;
      $("#hstep > input").value = hstep;
      $.all("#orientation > select > *").forEach(el => el.remove());
      orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      });
      $("#orientation > select").options.namedItem(orientation.join(",")).selected = true;
      $("#unit > input").value = unit;
      $("#refNote > input").value = refNote;
      $("#freqBasis > input").value = freqBasis;
      $("#edo > input").value = edo
    },

    "load-keyboard" () {
      let keyboard, unit, edo, gstep, hstep, orientations, orientation, refNote, freqBasis;
      const keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value;
      localStorage.setItem("keyboardSelection", keyboardSelection)
      if (keyboardSelection === "Custom") {
        this.keyboard = {
          unit: $("#unit > input").valueAsNumber,
          edo: $("#edo > input").valueAsNumber,
          gstep: $("#gstep > input").valueAsNumber,
          hstep: $("#hstep > input").valueAsNumber,
          freqBasis: $("#freqBasis > input").valueAsNumber,
          refNote: $("#refNote > input").valueAsNumber,
          orientation: $("#orientation > select").value.split(",").map(v => parseInt(v))
        };
        const hexGrid = this.hexGrid = new HexGrid(this.keyboard);
        hexGrid.genOrientations();
        this.keyboard.orientations = hexGrid.orientations;
      
        localStorage.setItem("keyboard", JSON.stringify(this.keyboard));
      } else {
        keyboard = this.keyboards[keyboardSelection];
        localStorage.removeItem("keyboard");
        app.emit("fill-keyboard-settings", keyboard);

        const hexGrid = this.hexGrid = new HexGrid(keyboard);
        hexGrid.setOrientation(...keyboard.orientation);
      }
      app.emit("resize")
      app.emit("redraw")
    },

    "orientation-change" (g, h) {
      this.hexGrid.setOrientation(g, h);
      app.emit("redraw")
    },

    "change-keyboard-lattice" () {
      $("#keyboard-select > select").value = "Custom";
      this.keyboard = null;
      const { hexGrid } = this,
            gstep = $("#gstep > input").valueAsNumber,
            hstep = $("#hstep > input").valueAsNumber,
            edo = $("#edo > input").valueAsNumber;
      $.all("#orientation > select > *").forEach(el => el.remove());
      if (gcd(gstep, hstep) !== 1) {
        $("#menu-apply").disabled = true;
        return
      }
      $("#menu-apply").disabled = false;
      hexGrid.gstep = gstep;
      hexGrid.hstep = hstep;
      hexGrid.edo = edo;
      hexGrid.genOrientations();
      const orientation = hexGrid.orientations.find(([g, h]) => g + h === 7) || hexGrid.orientations[0];
      if (!orientation) {
        $("#menu-apply").disabled = true;
        return
      }
      hexGrid.setOrientation(...orientation);
      hexGrid.orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      })
    },

    "menu-select" (which) {
      this.menuState = [which];
      $("body").classList.add("menuActive");
      switch (which) {
        case "keyboard-settings":
          $("#breadcrumb-text").innerText = "Keyboard ⚙️"
      }
    },
    "menu-cancel" () {
      this.menuState = [];
      $("body").classList.remove("menuActive")
    },
    "menu-apply" () {
      app.emit("load-keyboard");
      app.emit("menu-cancel")
    },

    "volume-change" (value) { this.masterVolume.gain.value = value / 100 },

    resize () {
      const { canvas, hexGrid } = this, { unit, orientation: [g, h] } = hexGrid,
            x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5,
            { width, height } = canvas.getBoundingClientRect();
      hexGrid.w = canvas.width = width * 2;
      hexGrid.h = canvas.height = height * 2;
      hexGrid.r = Math.min(unit * 2, width / (Math.hypot(x, y) + 2))
    },

    redraw () {
      const { hexGrid, gridctx } = this;
      hexGrid.updateGrid();
      gridctx.reset();
      gridctx.textBaseline = "middle";
      gridctx.font = (.4 * hexGrid.r) + "px sans";
      gridctx.strokeStyle = "#ddd";
      for (let hex of hexGrid) app.emit("colourHex", hex, hex.getColour(), "#ddd")
    },

    colourHex (hex, bgColour, txColour) {
      const { gridctx } = this, vertices = hex.vertices();
      gridctx.beginPath();
      gridctx.moveTo(...vertices[5]);
      for (let [ x, y ] of vertices) gridctx.lineTo(x, y);
      gridctx.fillStyle = bgColour;
      gridctx.fill();
      gridctx.stroke();
      const label = hex.note()[1], [ x, y ] = hex.centre(),
            { width } = gridctx.measureText(label);
      gridctx.fillStyle = txColour;
      gridctx.fillText(label, x - width / 2, y)
    },

    press (type, x, y, id) {
      const { hexGrid, activeHexes, gridTouches } = this,
            coord = hexGrid.getCoord(x, y);
      let hex, ids;
      switch (type) {

        case "start":
          hex = hexGrid.getHex(...coord);
          app.emit("colourHex", hex, "yellow", "#222");
          if (!activeHexes.has(hex)) hex.start();
          activeHexes.set(hex, (activeHexes.get(hex) ?? new Set()).add(id));
          gridTouches.set(id, hex);
          break;

        case "move":
          hex = gridTouches.get(id);
          ids = activeHexes.get(hex);
          if (hex.getCoord().some((v, i) => v !== coord[i])) {
            ids.delete(id);
            if (ids.size === 0) {
              hex.stop();
              activeHexes.delete(hex);
              app.emit("colourHex", hex, hex.getColour(), "#ddd");
            }
            hex = hexGrid.getHex(...coord);
            app.emit("colourHex", hex, "yellow", "#222");
            if (!activeHexes.has(hex)) hex.start();
            activeHexes.set(hex, (activeHexes.get(hex) ?? new Set()).add(id));
            gridTouches.set(id, hex)
          }
          break

        case "end":
          hex = gridTouches.get(id);
          ids = activeHexes.get(hex);
          ids.delete(id);
          if (ids.size === 0) {
            hex.stop();
            activeHexes.delete(hex);
            app.emit("colourHex", hex, hex.getColour(), "#ddd")
          }
          gridTouches.delete(id)
          
      }
    },

    panic () {
      this.audioctx.close();
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
    }
  }
});

$.queries({
  nav: { touchstart (e) { if ($.all("#panic, #volume > input").every(el => e.target !== el)) this.focus() } },
  "#volume > input": { change () { app.emit("volume-change", this.valueAsNumber) } },
  "#panic": { pointerdown () { app.emit("panic") } },
  "#keyboard-settings-button": { pointerdown () { app.emit("menu-select", "keyboard-settings") } },
  "#menu-cancel": { pointerdown () { app.emit("menu-cancel") } },
  "#menu-apply": { pointerdown () { app.emit("menu-apply") } },
  "#keyboard-settings": { change (e) { $("#keyboard-select > select").value = "Custom" } },
  "#keyboard-select > select": { change () { app.emit("load-keyboard") } },
  ":is(#gstep, #hstep, #edo) > input": { change () { app.emit("change-keyboard-lattice")} }
})
  </script>
  <noscript><h6>Only viewable with JavaScript enabled.</h6></noscript>
</body>
</html>