<!doctype html>
<html>
<head>
  <title>Temperamental â‚ Microtonal music explorer</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='music, xenharmony, xenrhythm'>
  <meta name='description' content='Web app for composing, playing, and noodling on microtonal music.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
@font-face {
  font-family: HEJI2;
  src: url('fonts/HEJI2Text.woff2') format('woff2');
  font-weight: normal;
  font-synthesis-weight: none;
  font-style: normal;
  font-display: swap;
  unicode-range: U+E260-E266, U+E2C0-E2FA;
  size-adjust: 150%;
  ascent-override: 0%;
  descent-override: 0% }
@font-face {
  font-family: Ratafly;
  src: url('fonts/Ratafly-Extrabold.woff2') format('woff2');
  font-weight: bold;
  font-style: normal;
  font-display: swap;
  size-adjust: 100%; }
@font-face {
  font-family: Ratafly;
  src: url('fonts/Ratafly-Medium.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap }
@font-face {
  font-family: Netto;
  src: url('fonts/NettoIcons.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
  ascent-override: 0%;
  descent-override: 0% }



@media (min-aspect-ratio: 1) {
  body.menuActive { grid: "nav nav" auto "menu main" 1fr / min-content 1fr }
  menu { max-width: 50dvw }
  #track-editor > form > textarea {
    width: 20em;
    min-width: 10em }
  .interval-display, #mapping { max-width: calc(50dvw - 3.5em - 4px) }
  #temperament-list, #chord-list { max-width: calc(50dvw - 3.5em - 4px) } }
@media (max-aspect-ratio: 1) {
  body.menuActive { grid: "nav" auto "menu" min-content "main" auto / 100dvw }
  menu { max-height: calc(50dvh - 3.5em) }
  #track-editor > form > textarea {
    width: 100% !important;
    resize: vertical }
  .interval-display, #mapping { max-width: calc(100dvw - 2.5em - 8px) }
  #temperament-list, #chord-list { max-width: calc(100dvw - 3.5em - 4px) }
  #temperament-list {
    min-height: calc(50dvh - 8em);
    min-width: calc(var(--tp-display-width) - 3em) } }

html, body {
  height: 100dvh }
body, button, select, input, textarea { font: min(16px, 2.7dvw) HEJI2, Ratafly, Netto }
body {
  margin: 0;
  background-color: #222;
  color: #ddd;
  display: grid;
  grid: "nav" auto "main" 1fr / 100dvw;
  overflow: hidden;
  position: relative }
  nav {
    background-color: #222;
    grid-area: nav;
    display: flex;
    flex-flow: column;
    user-select: none }
    nav > * {
      padding: .5em;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
    #controls {
      display: grid;
      grid-template-columns: auto auto 1fr repeat(3, auto);
      grid-gap: 0 .5em }
      #controls > * { flex: max-content 0 }
      #controls > :nth-last-child(n+2),
        #volume > * { vertical-align: middle }
      #volume > input { max-width: 20dvw }
      #info {
        width: 100%;
        min-width: max-content;
        text-align: center }
        #edo-info::after { content: "EDO" }
        #limit-info::after { content: "-limit" }
      #fullscreen.active::before { content: "ğŸ—•" }
      #fullscreen:not(.active)::before { content: "ğŸ—–" }
    #controls:has(.activeControls) { grid-template-columns: auto auto 1fr repeat(4, auto) }
    #track-controls {
      display: none;
      align-items: center }
      #track-controls > * {
        margin-right: .5em;
        width: max-content }
      #track-controls.activeControls { display: flex }
        #track-play:not(.trackPlaying)::before { content: "Play âµ" }
        #track-play.trackPlaying::before { content: "Pause â¸" }
    nav:focus-within:not(:has(:is(#refresh, #panic, #fullscreen, #volume > input):focus)) > #dropdown,
      body.menuActive #dropdown { display: flex }
    #dropdown {
      display: none;
      background-color: #000 }
      #dropdown > :nth-last-child(n+2) { margin-right: 2em }
        #dropdown > * > * { vertical-align: middle }
      #clipboard-item-select:has(#clipboard-peek:empty) { color: #666 }
      #clipboard-item-select.active {
        border: 2px dashed #ddd8;
        margin: -2px calc(2em - 2px) -2px -2px }
        #clipboard-peek { display: none }
        #clipboard-item-select > #clipboard-peek:not(:empty) { display: inline-block }
        #clipboard-peek {
          border: 1px solid #333;
          margin: -1px }
        #clipboard-peek:hover {
          border: 1px solid #ddd8;
          cursor: pointer }
        #clipboard-peek.active { background-color: #333 }
        body.copying #clipboard-peek:hover {
          border: 2px dashed #ddd8;
          margin: -2px }
          #clipboard-peek > * {
            display: flex;
            gap: .3em;
            padding: .1em .3em;
            align-items: baseline }
          .item-colour {
            background-color: var(--colour);
            height: 1em;
            width: 1em;
            display: inline-block }
          .split-colours.item-colour {
            background: linear-gradient(to bottom right, var(--colour-1) 50%, var(--colour-2) 50%) }
      #track-select { flex: 1 }
  menu {
    background-color: #222;
    padding: 0;
    margin: 0;
    min-height: 0;
    display: none }
  body.menuActive > menu { display: block }
    menu > li { padding: .5em }
    menu > li:not(#breadcrumbs) {
      overflow-y: scroll;
      height: calc(100% - 3.6em);
      display: none }
    menu > li.activeMenu { display: list-item !important }
    #breadcrumbs {
      background-color: #ddd;
      color: #222;
      display: flex;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
      #breadcrumb-text { font-size: .8em }
      #breadcrumb-text::before { content: "// " }
      #breadcrumb-text > :nth-last-child(n+2) { cursor: pointer }
      #breadcrumb-text > :nth-last-child(n+2)::after { content: " â€º " }
        #menu-actions > :nth-last-child(n+2) { margin-right: .5em }
      #breadcrumb-text > :last-child { user-select: none }
    form {
      display: flex;
      flex-flow: row wrap;
      gap: 0 .6em }
      #track-editor > form > * { width: 100% }
      fieldset {
        display: flex;
        flex-flow: column;
        flex: auto }
        fieldset > * { padding: .3em }
          :is(#scale, #mapping) > * {
            display: block;
            margin-left: 1em }
            :is(.harmonic, .interval-cell) > button { cursor: pointer }
          #mapping {
            display: grid;
            gap: .3em;
            width: fit-content }
            .harmonic {
              grid-template-columns: subgrid;
              display: grid !important;
              grid-column: span 20;
              gap: .3em;
              align-items: center;
              white-space: nowrap }
              .harmonic > span { user-select: none }
              .harm-obj::after { content: " harmonic" }
              .subharm-obj::after { content: " subharmonic" }
              .harmonic > .harmonic-spelling { text-align: start }
              .harmonic > :not(input) { text-align: end }
              .harmonic:not(.basis) > input, .harmonic.basis > span.steps,
                .harmonic.prime.power:not(.basis) > input.hcolour  { display: none }
              .hcolour {
                max-height: 6dvw;
                height: 100% }
              #error::after { content: "Â¢" }
          .choice {
            display: flex;
            flex-flow: row;
            gap: .5em }
          .choice input[type="radio"] { display: none }
          .choice > label {
            display: block;
            cursor: pointer }
          .choice > label:active {
            background-color: #ddd;
            color: #222 }
          .choice > label:has(input[type="radio"]:checked) { border-bottom: 1px solid }
          .interval-display {
            display: none;
            padding: 0 }
          .choice:has(label#diamond-choice > input[type="radio"]:checked) ~ #diamond-wrapper,
            .choice:has(label#table-choice > input[type="radio"]:checked) ~ #ivtable-wrapper { display: block }
          .interval-display, #mapping { overflow-x: scroll }
            .interval-cell.activeEnharmonic {
              border-bottom: 1px solid;
              margin-bottom: -1px }
          #diamond {
            display: grid;
            grid-template-columns: 1fr repeat(var(--size), auto);
            grid-template-rows: repeat(var(--size), 2em);
            justify-items: end;
            width: max-content }
        #harmonic-mapping:has(#table-choice > :checked)
          { height: calc(var(--iv-display-offsetTop) + var(--iv-display-scrollHeight)) }
          #ivtable-wrapper {
            max-height: calc(var(--iv-display-height));
            position: sticky;
            top: -.5em;
            overflow-y: hidden }
          #interval-table {
            display: grid;
            grid-template-columns: repeat(2, auto) repeat(calc(var(--harms) - 1), 1px auto);
            grid-template-rows: repeat(2, minmax(0, min-content)) repeat(calc(var(--edo) - 1), 1px minmax(0, min-content));
            width: max-content }
            #interval-table > :not(.table-border) { padding: .25em }
              .interval-th.column-head.row-head { z-index: 3 }
              .interval-th.column-head {
                position: sticky;
                top: 0;
                background-color: #222;
                z-index: 2;
                border-bottom: 1px solid #ddd8 }
              .interval-th.column-head:nth-child(n+2) {
                border-left: 1px solid #ddd8;
                margin-left: -1px }
              .interval-th.row-head {
                position: sticky;
                left: 0;
                background-color: #222;
                z-index: 2;
                border-right: 1px solid #ddd8 }
            .interval-th {
              position: relative;
              display: grid;
              place-items: center }
              .table-border {
                pointer-events: none }
              .column-head:not(.row-head) > span::after { content: "-limit" }
              .column-head + .table-border { border-right: 1px solid #ddd8 }
              .row-head:not(.column-head) + .table-border,
                .column-head.row-head + * + .table-border { border-bottom: 1px solid #ddd8 }
            .interval-td {
              display: flex;
              flex-flow: column;
              gap: .5em;
              place-self: end / center;
              align-items: end }
            .interval { width: max-content }
              #table-unison {
                text-align: center;
                margin: -.25em -1px -.25em 0;
                background-color: #222;
                width: calc(100% - .25em);
                padding: .25em;
                z-index: 1 }
      #temperament-list { height: calc(var(--tp-display-height) - 1.8em)  }
        #commas {
          display: grid;
          grid-template-columns: max-content;
          overflow-y: scroll;
          max-width: inherit }
          .comma {
            line-height: 1.8em;
            cursor: pointer;
            width: max-content }
          .comma:nth-child(2) { margin-top: -.8em }
          .comma:hover, .comma.active {
            border-bottom: 1px solid;
            margin-bottom: -1px;
            font-weight: bold }
          #computing-commas {
            min-height: 2em;
            min-width: inherit;
            order: 32767;
            text-align: center;
            line-height: 2em }
          #computing-commas.active > .hourglass { display: inline }
      #chord-list {
        position: relative;
        z-index: 1 }
        .chord-settings {
          position: sticky;
          top: -.5em;
          background-color: #222;
          padding: .5em;
          margin: -.5em;
          display: flex;
          flex-flow: row;
          align-items: baseline;
          gap: 2em }
          .heading-border {
            background-color: #ddd8;
            height: 1px;
            position: sticky;
            top: calc(1.8em + 1px);
            width: 100%;
            z-index: -1;
            padding: 0 }
        #chords {
          display: flex;
          flex-flow: column;
          gap: 2em 0;
          margin-top: 1em;
          max-width: inherit;
          overflow-x: scroll }
        #chords:has(.hourglass:last-child)::before { content: "To display chords, select a temperament" }
        #chords:not(.computing):has(.hourglass:last-child) { color: #666 }
        #chords.computing::before {
          line-height: 0;
          overflow: hidden }
        #chords.computing > .hourglass {
          display: inline;
          margin-top: -2.3em;
          align-self: center }
          .chord {
            display: grid;
            width: fit-content;
            gap: .5em .3em }
            .chord-intervals, .chord-pitches {
              grid-template-columns: subgrid;
              display: grid;
              grid-column: span 6;
              align-items: baseline }
            .chord-spelling { grid-column: span 6 }
            .chord-spelling::before { content: "Spelling: " }
            .chord-controls { grid-column: span 7 }
              .chord-interval-harmonic, .chord-pitches-harmonic,
                .chord-interval-steps, .chord-pitches-steps {
                justify-self: right;
                width: max-content }
              :is(.chord-interval-harmonic, .chord-pitches-harmonic,
                .chord-interval-steps, .chord-pitches-steps)::before { content: "[" }
              :is(.chord-interval-harmonic, .chord-pitches-harmonic,
                .chord-interval-steps, .chord-pitches-steps)::after { content: "]" }
              .play-chord { cursor: pointer }
              #chords:not(.cycling) .play-chord::before { content: "âµ" }
              #chords.cycling .play-chord:not(.active)::before { content: "Play âµ" }
              #chords.cycling .play-chord.active::before { content: "Pause â¸" }
      #track-file {
        display: flex;
        flex-flow: row;
        margin-bottom: .5em }
        #track-file > :nth-last-child(n+2) { margin-right: .5em }
        #track-name { flex: 1 }
        #track-name > * {
          display: none;
          vertical-align: middle }
        #track-name-text { cursor: text }
        #track-name-text:empty::before {
          color: #666;
          content: "..." }
        #track-name:not(.editingTrackName) > #track-name-text,
          #track-name.editingTrackName > input { display: inline }
        #track-name-field.invalid { outline: 1px solid red }
        #track-file:not(.saved) > :is(#track-savestate, #track-delete) { display: none }
        #track-savestate.saving::before {
          content: "...";
          color: orange }
        #track-savestate:not(.saving)::before {
          content: "âœ“";
          color: lawngreen }
      #track-edit {
        max-width: calc(100dvw - 1.5em);
        height: 10em }
      #insert-accidental {
        display: none;
        margin-top: .5em;
        grid-template-columns: repeat(auto-fill, 3em);
        text-align: center;
        line-height: 3em;
        gap: .5em;
        justify-content: space-evenly }
      #insert-accidental.activeSelect {
        display: grid;
        height: 6.5em;
        overflow: scroll }
        #insert-accidental > * {
          display: inline-block;
          background-color: #fff2;
          border-radius: .5em;
          cursor: pointer }
  main {
    touch-action: none;
    background-color: #000;
    overflow: hidden }
    main.hover { cursor: pointer }
    canvas {
      transform: scale(.5);
      transform-origin: 0 0;
      /* mix-blend-mode: lighten; */
      background-size: cover;
      background-position-y: center;
      pointer-events: none }
  dialog { padding: 1em 0 }
    #dialog-prompt { padding: 0 1em }
    dialog > form { justify-content: space-evenly }
input[type="number"] { min-width: calc(var(--size) * .8rem) }
.switch {
  position: relative;
  display: inline-block;
  height: 1.4em;
  width: 2.4em;
  border-radius: .7em;
  background-color: #666;
  vertical-align: bottom;
  cursor: pointer }
.switch:has(input:checked) { background-color: #ddd }
  .switch input { display: none }
  .slider {
    position: absolute;
    top: 0;
    left: 0 }
  .slider:before {
    position: absolute;
    content: "";
    top: .2em;
    left: .2em;
    height: 1em;
    width: 1em;
    border-radius: 50%;
    background-color: #222 }
    input:checked + .slider:before { transform: translateX(1em) }
.copyable { user-select: none }
body.copying .copyable:hover {
  border: 2px dashed #ddd8;
  padding: 2px;
  margin: -4px;
  cursor: cell }
  #drag-feedback {
    position: absolute;
    opacity: 50%;
    z-index: 10 }
#hourglass-template, .hourglass {
  display: none;
  fill: #ddd;
  width: 2em }
#hourglass text { font: 10px Netto }
  </style>
</head>
<body>
  <nav tabindex="0">
    <div id="dropdown">
      <div id="keyboard-select">
        <span>Keyboard</span>
        <select></select>
        <button id="keyboard-settings-button" type="button">â›­</button>
      </div>
      <div id="temperament-menu">
        <span>Temperaments</span>
        <button id="generate-temperaments" type="button">ğŸ’¡</button>
      </div>
      <div id="clipboard-item-select">
        <span>Clipboard</span>
        <span id="clipboard-peek" draggable="true"></span>
      </div>
      <div id="track-select">
        <span>Track</span>
        <select>
          <option name="None">None</option>
          <hr>
          <option name="New">New</option>
        </select>
      </div>
      <button class="info" type="button">â„¹</button>
    </div>
    <div id="controls">
      <div id="volume">
        <span>Volume</span>
        <input type="range" min="0" max="100" step="1">
      </div>
      <div id="octaves">
        <span>Octaves</span>
        <input type="number" value="2" min="1" max="5" steps="1" size="2">
      </div>
      <div id="info">
        <span id="edo-info"></span>
        <span id="limit-info"></span>
      </div>
      <div id="track-controls">
        <button id="track-loop" type="button">Loop</button>
        <button id="track-play" type="button"></button>
      </div>
      <button id="refresh" type="button">Refresh</button>
      <button id="panic" type="button">Panic</button>
      <button id="fullscreen" type="button"></button>
    </div>
  </nav>
  <menu>
    <li id="breadcrumbs">
      <span id="breadcrumb-text"></span>
      <div id="menu-actions"></div>
    </li>
    <li id="keyboard-settings">
      <form>
        <fieldset>
          <legend>Shape</legend>
          <label id="gstep">Horizontal steps: <input type="number" min="1" step="1" size="4"></label>
          <label id="hstep">Diagonal steps: <input type="number" min="1" step="1" size="4"></label>
          <label id="orientation">Orientation:
            <select>
              <option value="">Choose</option>
            </select>
          </label>
          <label id="unit">Key size: <input type="number" min="5" step="1" size="5"> px</label>
        </fieldset>
        <fieldset>
          <legend>Note</legend>
          <label id="refNote">Tuning root note: <input type="number" min="0" step="1" size="4"></label>
          <label id="freqBasis">Tuning root frequency: <input type="number" min="10" max="40000" size="6"> Hz</label>
          <div id="scale">Scale:
            <label id="edo">Divisions of octave: <input type="number" min="1" step="1" max="270" size="4"></label>
            <output></output>
          </div>
        </fieldset>
        <fieldset id="harmonic-mapping">
          <legend>Harmonic mapping</legend>
          <label id="limit">Harmonic limit: <input type="number" value="9" min="3" step="2" size="3"></label>
          <label id="maxError">Maximum error: <input type="number" value="30" min="0" max="100" size="4"> Â¢</label>
          <div id="mapping"></div>
          <div id="interval-view" class="choice">
            <label id="diamond-choice"><input type="radio" name="interval-view" checked>Tonality diamond</label>
            <label id="table-choice"><input type="radio" name="interval-view">Interval table</label>
          </div>
          <div id="diamond-wrapper" class="interval-display"><div id="diamond"></div></div>
          <div id="ivtable-wrapper" class="interval-display"><div id="interval-table"></div></div>
        </fieldset>
        <fieldset>
          <legend>Waveform</legend>
          <label id="instrument">Output:
            <select>
              <option value="osc">Local</option>
              <option value="midi">MIDI</option>
            </select>
          </label>
          <label id="instrument-option">
            <span>Oscillator</span>
            <select>
              <option value="custom">Custom</option>
            </select>
            <button type="button">Choose</button>
          </label>
        </fieldset>
      </form>
    </li>
    <li id="temperaments">
      <form>
        <fieldset id="temperament-list">
          <legend>Temperaments</legend>
          <div id="commas">
            <div id="computing-commas">
              <svg xmlns="http://www.w3.org/2000/svg" class="hourglass" viewBox="-6,-6,12,12">
                <use href="#hourglass"></use>
              </svg>
            </div>
          </div>
        </fieldset>
        <fieldset id="chord-list">
          <legend>Chords</legend>
          <div class="chord-settings">
            <div>Cycle inversions <label class="switch"><input type="checkbox"><span class="slider"></span></label></div>
            <div>Comma: <span id="comma-info"></span></div>
          </div>
          <div class="heading-border"></div>
          <div id="chords">
            <svg xmlns="http://www.w3.org/2000/svg" class="hourglass" viewBox="-6,-6,12,12">
              <use href="#hourglass"></use>
            </svg>
          </div>
        </fieldset>
      </form>
    </li>
    <li id="track-editor">
      <form>
        <div id="track-file">
          <div id="track-name">
            <span id="track-name-text"></span>
            <input id="track-name-field" type="text">
          </div>
          <span id="track-savestate"></span>
          <button id="toggle-accidentals" type="button">î‰¡</button>
          <button class="info" type="button">â„¹</button>
          <button id="track-delete" type="button">âœ—</button>
        </div>
        <textarea id="track-edit"></textarea>
        <div id="insert-accidental">
          <div>î‰ </div><div>î‰¡</div><div>î‰¢</div><div>î‰£</div><div>î‰¤</div><div>î‰¥</div><div>î‰¦</div>
          <div>î‹€</div><div>î‹</div><div>î‹‚</div><div>î‹ƒ</div><div>î‹„</div><div>î‹…</div><div>î‹†</div><div>î‹‡</div><div>î‹ˆ</div><div>î‹‰</div><div>î‹Š</div><div>î‹‹</div><div>î‹Œ</div><div>î‹</div><div>î‹</div><div>î‹</div><div>î‹</div><div>î‹‘</div><div>î‹’</div><div>î‹“</div><div>î‹”</div><div>î‹•</div><div>î‹–</div><div>î‹—</div><div>î‹˜</div><div>î‹™</div><div>î‹š</div><div>î‹›</div><div>î‹œ</div><div>î‹</div><div>î‹</div><div>î‹Ÿ</div><div>î‹ </div><div>î‹¡</div><div>î‹¢</div><div>î‹£</div><div>î‹¤</div><div>î‹¥</div><div>î‹¦</div><div>î‹§</div><div>î‹¨</div><div>î‹©</div><div>î‹ª</div><div>î‹«</div><div>î‹¬</div><div>î‹­</div>
        </div>
      </form>
    </li>
  </menu>
  <main>
    <canvas id="hex"></canvas>
  </main>
  <dialog id="delete-dialog">
    <div id="dialog-prompt">Delete track "<span id="delete-track-name"></span>"?</div>
    <form method="dialog">
      <button type="button" data-action="Cancel">Cancel</button>
      <button type="button" data-action="Delete">Delete</button>
    </form>
  </dialog>
  <template id="breadcrumb-level">
    <span></span>
  </template>
  <template id="menu-action">
    <button type="button"></button>
  </template>
  <template id="option">
    <option></option>
  </template>
  <template id="harmonic">
    <label class="harmonic">
      <span class="nth-harmonic harm-obj copyable" draggable="true"></span> (<span class="harmonic-name"></span>) at <input class="steps" type="number" step="1" size="4"><span class="steps"></span> steps <button type="button">âµ</button>,
      <span class="nth-harmonic subharm-obj copyable" draggable="true"></span> (<span class="subharmonic-name"></span>) at <span class="sub-steps"></span> steps <button data-is-subharm type="button">âµ</button>, <span id="error"></span> error <input class="hcolour" type="color">
    </label>
  </template>
  <template id="interval-cell">
    <div class="interval-cell">
      <span class="interval-obj copyable" draggable="true"></span> (<span></span>), <span></span> steps <button type="button">âµ</button>
    </div>
  </template>
  <template id="interval-th">
    <div class="interval-th">
      <span></span>
   </div>
   <div class="table-border"></div>
  </template>
  <template id="interval-td">
    <div class="interval-td"></div>
  </template>
  <template id="comma">
    <div class="comma">
      1 â‰… <span class="comma-ratio"></span> (<span class="numerator-decomp"></span>/<span class="denominator-decomp"></span>),
        size <span class="comma-size"></span>Â¢, spelling C = <span class="comma-spelling"></span>
    </div>
  </template>
  <template id="chord">
    <div class="chord copyable" data-inv="0" draggable="true">
      <div class="chord-intervals">
        Intervals:<span class="chord-interval-harmonic"></span>=<span class="chord-interval-steps"></span>â§¹<span class="chord-edo"></span>
      </div>
      <div class="chord-pitches">
        Pitches:<span class="chord-pitches-harmonic"></span>=<span class="chord-pitches-steps"></span>â§¹<span class="chord-edo"></span>
      </div>
      <div class="chord-spelling"></div>
      <div class="chord-controls">
        <span class="chord-is-symmetric">
          <button type="button">Otonal</button>
          <button type="button">Utonal</button>
        </span>
        <button class="inversion" type="button">Next inversion</button>
        <button class="play-chord" type="button"></button>
      </div>
    </div>
  </template>
  <template id="clipboard-item-harmonic">
    <div class="item-harmonic">
      <div class="item-colour"></div>
      <span class="item-harmonic-order"></span>
      (<span class="item-spelling"></span>)
    </div>
  </template>
  <template id="clipboard-item-interval">
    <div class="item-interval">
      <div class="item-colour"></div>
      <span class="item-interval-ratio"></span>
      (<span class="item-spelling"></span>)
    </div>
  </template>
  <template id="clipboard-item-chord">
    <div class="item-chord"></div>
  </template>
  <svg xmlns="http://www.w3.org/2000/svg" id="hourglass-template" viewBox="-6,-6,12,12">
    <g id="hourglass">
      <mask id="sand">
        <rect x="-2.4" y="-4.6" width="4.8" height="4.6" fill="white">
          <animate attributeName="height" attributeType="XML" values="4.6; 0; 0; 4.6" keyTimes="0; .3333; 1; 1" dur="3s" repeatCount="indefinite" />
          <animate attributeName="y" attributeType="XML" values="-4.6; 0; 0; -4.6" keyTimes="0; .3333; 1; 1" dur="3s" repeatCount="indefinite" />
        </rect>
        <rect x="-2.4" y="4.6" width="4.8" height="0" fill="white">
          <animate attributeName="height" attributeType="XML" values="0; 4.6; 4.6; 0" keyTimes="0; .3333; 1; 1" dur="3s" repeatCount="indefinite" />
          <animate attributeName="y" attributeType="XML" values="4.6; 0; 0; 4.6" keyTimes="0; .3333; 1; 1" dur="3s" repeatCount="indefinite" />
        </rect>
      </mask>
      <path mask="url(#sand)" d="M -2.4 -4.6 L -2.4 -2.5 L -.5 0 L -2.4 2.5 L -2.4 4.6 L 2.4 4.6 L 2.4 2.5 L .5 0 L 2.4 -2.5 L 2.4 -4.6 Z" />
      <text dominant-baseline="middle" text-anchor="middle" transform="translate(0 1.8)">âŒ›</text>
      <animateTransform attributeName="transform" attributeType="XML" type="rotate" values="0; 0; 180; 0" keyTimes="0; .6667; 1; 1" dur="3s" repeatCount="indefinite" />
    </g>
  </svg>
  <script src="js/machine.js"></script>
  <script>



// Utilities

class Common {
  static #allPrimes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 ]
  static #allPrimesBig = this.#allPrimes.map(BigInt)
  
  static versionCmp = (a, b) => {
    if (![a, b].every(s => s.match(/^\d+(?:\.\d+)*$/))) throw new Error("Version error: malformed version string");
    return [a, b].sort()[0] === a ? a === b ? 0 : -1 : 1
  }
  static between = (min, max, val) => val <= max && val >= min
  static clamp = (min, max, val) => (max >= min && Number(val) === val) ? Math.max(min, Math.min(max, val)) : undefined
  static lerp = (a, b, t) => a * (1 - t) + b * t
  static mod = (n, m) => ((n % m) + m) % m
  static non2 = h => h / (h & (~--h))
  static gcd = (a, b) => !b ? a : this.gcd(b, a % b)
  static groupBy = (ar, groupFn = x => x, mapFn = x => x) => ar.reduce((a, v) => {
    const k = groupFn(v);
    a[k] = (a[k] ?? []).concat([mapFn(v)]);
    return a
  }, {})
  static mapBy = (ar, groupFn = x => x, mapFn = x => x) => ar.reduce((a, v) => {
    const k = groupFn(v);
    return a.set(k, (a.get(k) ?? []).concat([mapFn(v)]))
  }, new Map())
  static group = (ar, cmp = (a, b) => a === b) => ar.reduce((a, v) => {
    const i = a.findIndex(vs => cmp(vs[0], v));  // quadratic in cmp
    return ~i ? a.with(i, a[i].concat([v])) : a.concat([[v]])
  }, [])
  static decomp = (...iv) => iv.map(r => { // use 2s?
    let ivh = this.non2(r), raw = [], res = new Map(), i = 1;
    while (ivh !== 1) {
      const p = this.#allPrimes[i];
      if (this.gcd(ivh, p) === 1) i++;
      else { raw.push(p); ivh /= p }
    }
    for (let [ k, v ] of this.mapBy(raw)) res.set(parseInt(k), v.length)
    return res
  })
  static comp = ar => ar.reduce((n, [p, rad]) => n * p ** rad, 1)
  static bigLog2 = x => {
    const str = x.toString(16), d = str.slice(0, 13);
    return Math.log2(parseInt(d, 16) / 16 ** d.length) + 4 * str.length
  }
  static decompBig = (...iv) => iv.map(r => { // use 2s?
    let ivh = this.non2(r), raw = [], res = new Map(), i = 1;
    while (ivh !== 1n) {
      const p = this.#allPrimesBig[i];
      if (this.gcd(ivh, p) === 1n) i++;
      else { raw.push(p); ivh /= p }
    }
    for (let [ k, v ] of this.mapBy(raw)) res.set(parseInt(k), v.length)
    return res
  })

  static scaleVolume = value => value && 10 ** (2 * (value / 100 - 1))
  static ordinal = (() => {
    const rule = new Intl.PluralRules("en-AU", { type: "ordinal" }),
          suf = new Map([ ["one", "st"], ["two", "nd"], ["few", "rd"], ["other", "th"] ]);
    return n => `${n}${suf.get(rule.select(n))}`
  })()

  static noteFromFactors = (() => {  // Any way to generalise? Use u/e26c and u/e26d ?
    const degree = [["F", "IV", 4], ["C", "I", 1], ["G", "V", 5], ["D", "II", 2],
            ["A", "VI", 6], ["E", "III", 3], ["B", "VII", 7]]
            .reduce((acc, vals, i) => ({ ...acc, [i - 1]: vals }), {}),
          hejiRatios = {
            5: [[[3, 4]], [[5, 1]]],
            7: [[], [[3, 2], [7, 1]]],
            11: [[[3, 1], [11, 1]], []],
            13: [[[3, 3]], [[13, 1]]],
            17: [[[3, 7]], [[17, 1]]],
            19: [[[3, 3], [19, 1]], []],
            23: [[[23, 1]], [[3, 6]]],
            29: [[[3, 2], [29, 1]], []],
            31: [[], [[31, 1]]],
            37: [[[37, 1]], [[3, 2]]],
            41: [[[41, 1]], [[3, 4]]],
            43: [[[3, 1], [43, 1]], []],
            47: [[47, 1], [[3, 6]]]
          };
    return factors => {
      let accid = {};
      factors = structuredClone(factors);
      const
        { mod, bigLog2, comp } = Common,
        logHigh = mod((bigLog2(comp(factors[0])) - bigLog2(comp(factors[1]))), 1) > .5;

      // Factorise out commas
      structuredClone(factors).forEach((d, i) => {
        d.forEach(([p, rad]) => {
          if (p === 3) return;
          const tone = hejiRatios[p].findIndex(side => ~side.findIndex(([q]) => p === q));
          accid[p] = (1 - 2 * (i ^ tone)) * rad;
          hejiRatios[p].forEach((side, j) => side.forEach(([q, qrad]) => {
            const targetSide = i ^ j ^ !tone, k = factors[targetSide].findIndex(([r]) => q === r);
            ~k ? (factors[targetSide][k][1] += qrad * rad) : factors[targetSide].push([q, qrad * rad])
          }))
        })
      });

      // Normalise to Pythagorean key
      factors[1].forEach(([p, rad], i, dc1) => {
        const j = factors[0].findIndex(([q]) => p === q);
        if (!~j) return;
        const qrad = factors[0][j][1];
        if (rad > qrad) factors[1][i][1] -= qrad;
        else factors[1][i] = [];
        if (rad < qrad) factors[0][j][1] -= rad;
        else factors[0].splice(j, 1);
      });
      factors[1] = factors[1].filter(ar => ar.length);

      // Build string
      const tone = factors.findIndex(d => d.length),
            fifths = (1 - 2 * tone) * (~tone ? factors[tone][0][1] : 0),
            sharps = Math.floor((fifths + 1) / 7);
      let acstring = "", pref5 = () => "", prefNo5 = "";
      if (sharps < -2) {
        pref5 = n => ["", String.fromCodePoint(0xe2c1 + n), String.fromCodePoint(0xe2c0 + n)][(sharps === -3) - sharps % 3];
        prefNo5 = ["", String.fromCodePoint(0xe260), String.fromCodePoint(0xe264)][-sharps % 3];
        acstring = sharps === -3 && (5 in accid) ? String.fromCodePoint(0xe264) : String.fromCodePoint(0xe266).repeat(Math.floor(-sharps / 3))
      } else if (sharps > 2) {
        pref5 = n => sharps % 2 ? String.fromCodePoint(0xe2c3 + n) : String.fromCodePoint(0xe2c4 + n);
        prefNo5 = sharps % 2 ? String.fromCodePoint(0xe265) : String.fromCodePoint(0xe263).repeat(2);
        acstring = String.fromCodePoint(0xe263).repeat(Math.floor((sharps - 1) / 2) - !(5 in accid))
      } else {
        pref5 = n => String.fromCodePoint(0xe2c0 + n + (sharps + 2) % 5);
        prefNo5 = sharps === 0 ? "" : String.fromCodePoint(0xe260 + (sharps + 6) % 5)
      }
      if (5 in accid) {
        const arr = accid[5];
        if (Math.abs(arr) <= 3) {
          const arrowsOffset = 5 * (arr > 0 ? 2 * arr - 1 : -2 - 2 * arr);
          acstring += pref5(arrowsOffset);
        } else {
          const arrowsOffset = 5 * (arr > 0 ? 2 * (arr % 3) - 1 : 2 * (-arr % 3) - 2);
          acstring += (arrowsOffset < 0 ? "" : pref5(arrowsOffset)) + String.fromCodePoint(0xe2d6 + 5 * (arr > 0)).repeat(Math.floor(Math.abs(arr) / 3))
        }
      } else acstring = prefNo5 + acstring;
      if (7 in accid) {
        const sep = accid[7];
        acstring += String.fromCodePoint(0xe2e0 + (sep > 0)).repeat(Math.floor((Math.abs(sep) - 1) / 2)) + 
          String.fromCodePoint(0xe2de + (sep > 0) + 2 * Math.abs((sep + 1) % 2));
      }
      Object.keys(hejiRatios).slice(2).forEach((p, i) => acstring += accid[p] > 0 ?
        String.fromCodePoint((i < 7 ? 0xe2e3 : 0xee41) + 2 * i).repeat(accid[p]) :
        String.fromCodePoint((i < 7 ? 0xe2e2 : 0xee40) + 2 * i).repeat(-accid[p]));
      const
        [ key, roman, num ] = degree[ mod(fifths + 1, 7) - 1 ],
        revac = acstring.split("").reverse().join(""),
        oct = fifths / 12,
        numAdj = oct > 0 ? -(oct >= 8 - num) : oct < 0 ? + (oct <= 1 - num) : 0,
        baseIvNum = num - 2 * (numAdj < 0) + 7 * ((num === 1 && logHigh) || numAdj);
      return {
        accid: { "3": fifths, ...accid },
        number: revac + (numAdj < 0 ? `(${baseIvNum})` : baseIvNum),
        roman: revac + roman,
        romanlow: revac + roman.toLowerCase(),
        letter: key + acstring
      };
    }
  })()
}



// Harmonic mapping

class HarmonicMapping {

  // Static
  static #isPrime (pdec) {
    let sum = 0;
    for (let [, rad] of pdec) sum += rad;
    return sum === 1
  }
  static #transp = mat => Array(mat[0].length).fill()
    .reduce((row, _, i) => row.concat([mat.reduce((cols, row) =>
      cols.concat([row[i]]), [])]), [])

  static #invDet (mat, decs, ps) { // TODO: use leading value
    const
      rows = mat.length, cols = mat[0].length,
      aug = mat.map((row, i) => row.concat(Array(rows).fill(0).with(i, 1)));
    if (mat.length === 0) return null;
    let det = 1, lcm = 1;
    for (let i = 0; i < rows; i++) {
      if (aug[i][i] === 0) {
        let m = 0;
        for (m = i + 1; m < rows; m++) if (aug[m][i] !== 0) {
          ([ aug[m], aug[i], decs[m], decs[i] ] = [ aug[i], aug[m], decs[i], decs[m] ]);
          for (let j = 0; j < rows; j++)
            ([ aug[j][cols + m], aug[j][cols + i] ] = [ aug[j][cols + i], aug[j][cols + m] ]);
          det = -det;
          break
        }
        if (m === rows) return {}
      }
      const val0 = aug[i][i];
      lcm = val0 / Common.gcd(lcm, val0);
      for (let j = 0; j < rows; j++) if (i !== j) {
        const val1 = aug[j][i], c = Common.gcd(val0, val1);
        if (i < ps.length) det *= val0 / c;
        for (let k = 0; k < rows + cols; k++)
          aug[j][k] = (val0 * aug[j][k] - val1 * aug[i][k]) / c;
      }
    }
    mat = this.#transp(aug);
    det = mat.slice(0, ps.length).reduce((acc, row, i) => acc * row[i], 1) / det
    const degen = aug.findIndex(row => !row.slice(0, cols).some(x => x));
    if (~degen) aug.splice(degen);
    return {
      det, lcm,
      mods: aug.slice(0, ps.length).map((row, i) => [ ps[i], lcm / row[i] ]),
      inv: mat.slice(cols, cols + ps.length).map((row, i) => [ decs[i][0], row ]),
      verify: mat.slice(aug.length, cols).map((vec, i) => [ ps[aug.length + i], vec ])
    }
  }

  static * #subsets (args, { minlength = 1, maxlength = args.length } = {}) {
    for (let n = minlength; n <= maxlength; n++) {
      let max = -1, counter = [];
      while (max + n <= args.length) {
        if (~max) yield counter.map(k => args[k]);
        const i = counter.findLastIndex((j, k) => j < max + k);
        if (~i) counter[i]++;
        else counter = Array(n).fill().map((_, j) => j).with(-1, n + max++);
      }
    }
  }

  // Instance
  #keyboard; #scale
  rawHarmonicList; harmonicList = new Map()
  nonHarmonics = new Set() // TODO: Cached blacklist
  indexPrimes = []; primes = []; params = []; index = []; verify = () => true; stepsBasis
  #properIntervalSet = new IntervalSet(this); intervalSet = new IntervalSet(this); unison
  ready = false
  #temperaments = new Map(); temperament
  mask // TODO: for temperings

  constructor ({ keyboard, scale, hmap }) { // Map([ odd, number ])
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Mapping error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (!(Scale.prototype.isPrototypeOf(scale))) throw new Error("Mapping error: must provide Scale object");
    this.#scale = scale;
    const { edo } = keyboard, { maxError } = scale;
    if (!Map.prototype.isPrototypeOf(hmap) || [ ...hmap ].some(v => v.some(u => typeof u !== "number") ||
      v.some(u => u % 1) || v[0] < 3 || v[0] > app.maxHarmonic || v[0] % 2 !== 1 || v[1] < 0 || v[1] > edo)) throw new Error("Mapping error: bad interval-step mapping");
    const harr = [ ...hmap ];

    const
      decs = Common.decomp(...harr.map(([h]) => h)).map((pdec, i) => [ harr[i][0], pdec ]),
      { true: primeDecs = [], false: compositeDecs = [] } = Common.groupBy(
        decs, ([, a]) => HarmonicMapping.#isPrime(a)),
      { true: simpleDecs = [], false: residueDecs = [] } = Common.groupBy(
        compositeDecs.map(([ h, pdec ]) => [ h, [...pdec].filter(([p]) => !~primeDecs.findIndex(([q]) => q === p)) ]),
        ([ , pp ]) => pp.length === 0, ([p]) => compositeDecs.find(([q]) => q === p)),
      ps = [ ...residueDecs.reduce((acc, [, pdec]) => {
        for (let [p] of pdec) acc.add(p);
        return acc
      }, new Set()).values() ].sort((a, b) => a > b),
      { true: residuePrimeDecs = [], false: simplePrimeDecs = [] } = Common.groupBy(
        primeDecs, ([p]) => ps.includes(p)),
      residue = residuePrimeDecs.concat(residueDecs);
      
    this.indexPrimes = ps;
    this.primes = simplePrimeDecs.map(([h]) => h);

    simplePrimeDecs.forEach(([h]) => this.harmonicList.set(h, new Harmonic({ keyboard, mapping: this, order: h,
      countingFn: (...params) => params[ simplePrimeDecs.findIndex(([p]) => p === h) ] })));
    simpleDecs.forEach(([h, hdec]) => {
      const
        just = Math.log2(h) % 1,
        steps = [ ...hdec ].reduce((acc, [p, rad]) => acc + hmap.get(p) * rad, 0) % edo,
        error = (steps / edo - just) * 1200;
      if (Math.abs(error) >= maxError || steps + edo * maxError / 1200 < 1 ||
        steps - edo * maxError / 1200 > edo - 1) hmap.delete(i);
      else this.harmonicList.set(h, new Harmonic({ keyboard, mapping: this, order: h }))
    });

    if (residue.length) {
      let system, best = 0, dims = -1;
      const cols = ps.length;
      for (let hs of HarmonicMapping.#subsets(residue)) { // TODO: memoise?
        const mat = [], rows = hs.length;
        for (let [, pdec] of hs) mat.push(ps.map(p => pdec.get(p) ?? 0));
        if (rows < cols) mat.splice(Infinity, Infinity, ...Array(cols - rows).fill().map(() => mat.at(-1).slice()));
        if (rows > cols) mat.forEach((row, i) => row.splice(Infinity, Infinity, ...(i < cols ? Array(rows - cols).fill(0) :
          Array(rows - cols).fill(0).with(i - cols, -1))));
        const { inv, det } = HarmonicMapping.#invDet(mat, hs, ps);
        if (det === undefined) continue;
        if ((best !== 0 && Math.abs(det) < Math.abs(best)) || (best === 0 && (det !== 0 || inv.length > dims)))
          ([system, best, dims] = [hs, det, inv.length]);
        if (Math.abs(det) === 1) break;
      }
      const
        hs = system.reduce((acc, [h], i) => { // TODO: nicer ordering
          const j = acc.findIndex(([p]) => p === h);
          ([ acc[i], acc[j] ] = [ acc[j], acc[i] ]);
          return acc
        }, residue),
        rows = hs.length, mat = [];
      for (let [, pdec] of hs) mat.push(ps.map(p => pdec.get(p) ?? 0));
      if (rows > cols) mat.forEach((row, i) => row.splice(Infinity, Infinity, ...(i < cols ? Array(rows - cols).fill(0) :
        Array(rows - cols).fill(0).with(i - cols, -1))));

      // TODO: Can I use det to exclude harmonics before running the counting function?
      const { mods, inv, det, lcm, verify } = HarmonicMapping.#invDet(mat, hs, ps);

      this.index = system.map(([h]) => h);
      this.params = residue.filter(([d]) => !~system.findIndex(([h]) => h === d));

      // if underdetermined, the params must be provided
      // if overdetermined, these components must be verified
      this.verify = (...primeVec) => {
        const
          dps = primeVec.slice(0, residue.length),
          vps = primeVec.slice(residue.length);
        return verify.every(([p, vec], i) => dps.reduce((a, x, j) => a + x * vec[j] * (mods[j]?.[1] ?? 1), 0) === vps[i])
      };

      inv.forEach(([h, vec]) => this.harmonicList.set(h, new Harmonic({ keyboard, mapping: this, order: h,
        countingFn: (...params) => {
          const rawNum = hs.reduce((a, _, i) => a + (params[i] ?? 0) * vec[i] * (mods[i]?.[1] ?? 1), 0);
          return rawNum % lcm ? null : rawNum / lcm // Null means failure
        } }), true));
      residue.filter(([d]) => !~inv.findIndex(([h]) => h === d))
        .forEach(([h, dec]) => {
          if (~residueDecs.findIndex(([p]) => p === h)) {
            const
              just = Math.log2(h) % 1,
              primeVec = this.indexPrimes.map(p => dec.get(p) ?? 0),
              steps = this.index.reduce(
                (count, h) => count + hmap.get(h) * this.harmonicList.get(h).countingFn(...primeVec),
                this.primes.reduce((count, p) => count + hmap.get(p) * (dec.get(p) ?? 0), 0)) % edo,
              error = (steps / edo - just) * 1200;
            if (Math.abs(error) >= maxError || steps + edo * maxError / 1200 < 1 ||
              steps - edo * maxError / 1200 > edo - 1) {
              hmap.delete(i);
              return
            }
          }
          this.harmonicList.set(h, new Harmonic({ keyboard, mapping: this, order: h }))
      })
    }
    this.rawHarmonicList = hmap;

    // Generate all intervals
    const withUnison = [1].concat(decs.map(([h]) => h));
    for (let n of withUnison) for (let d of withUnison) {
      const
        params = Array(this.params.length).fill(0),
        iv = new Interval({ keyboard: this.#keyboard, mapping: this, n, d, params, isProper: true });
      this.#properIntervalSet.add(iv);
      this.intervalSet.add(iv);
      if (d === 1 && n !== 1) this.harmonicList.get(n).withQuality("harmonic", true)
    }
    this.setSteps(new Map(hmap));
    
    this.unison = this.#properIntervalSet.getRatio(1, 1);
    this.ready = true
  }

  decomp (n, d) { //Null is failure
    const pdec = Common.decomp(n)[0], dec = [];
    if (d) {
      for (let [p, rad] of Common.decomp(d)[0]) if (pdec.has(p)) {
        const nrad = pdec.get(p);
        if (nrad === rad) pdec.delete(p);
        else pdec.set(p, nrad - rad)
      } else pdec.set(p, -rad)
    }
    const { params, index, indexPrimes, primes, harmonicList, verify } = this;
    for (let p of primes) {
      if (!pdec.has(p)) continue;
      else dec.push([ p, pdec.get(p) ]);
      pdec.delete(p)
    }
    const primeVec = indexPrimes.map(p => pdec.get(p) ?? 0);
    for (let [p] of pdec) if (!indexPrimes.includes(p)) return null;
    if (!verify(...primeVec)) return null;
    return index.reduce((fn, h) => (...params) => {
      const acc = fn(...params);
      if (acc === null) return null;
      const res = harmonicList.get(h).countingFn(...primeVec, ...params);
      return res === null ? null : res === 0 ? acc : acc.concat([[ h, res ]])
    }, () => dec)
  }

  getProperIntervals () { return new IntervalSet(this, this.#properIntervalSet) }
  addInterval (interval) { intervalSet.add(interval) }

  setSteps (stepsMap) {  // Map([ harmonic, steps ])
    const { index } = this, { edo } = this.#keyboard, stepsBasis = new Map(stepsMap);
    if (index.some(h => {
      const s = stepsMap.get(h);
      return s === undefined || s < 0 || s % 1
    })) throw new Error("Could not set steps for mapping");
    for (let [h, steps] of stepsMap) stepsBasis.set(h, steps + edo * Math.floor(Math.log2(h)));
    this.stepsBasis = stepsBasis
  }

  // Temperaments
  * #mults () { // Not correct for indexed mappings
    const
      ps = this.primes.concat([2], this.index).sort((a, b) => a > b),
      lps = ps.map(Math.log2), bps = ps.map(BigInt), list = [[ 1n, 0 ]];
    let len = 1;
    while (true) {
      const [ k, l ] = list.splice(0, 1)[0];
      len--;
      for (let i = 0, low = 0; i < ps.length; i++) {
        const val = k * bps[i], log = l + lps[i];
        let high = len;
        while (low < high) {
          const mid = (low + high) >>> 1;
          if (list[mid][0] < val) low = mid + 1;
          else high = mid
        }
        if (list[low]?.[0] === val) continue;
        list.splice(low, 0, [ val, log ]);
        len++
      }
      yield [ k, l ]
    }
  }

  * #commas () {
    let prev = [];
    const lps = this.primes.concat([2], this.index).map(Math.log2).sort((a, b) => a > b); // Fix this...
    for (let [ k, l ] of this.#mults()) {
      prev = prev.filter(([pk, pl]) => l - pl < this.#scale.maxError / 400);
      for (let [ pk, pl ] of prev) if (Common.gcd(k, pk) === 1n) yield [ k, l, pk, pl ];
      prev.push([ k, l ])
    }
  }

  takeCommas = (() => {
    const gen = this.#commas();
    let v = false;
    return function * (upperBound) {
      if (v) {
        yield v;
        if (v[0] > upperBound) {
          v = false;
          return
        }
      }
      while (true) if ((v = gen.next().value)[0] > upperBound) {
        upperBound = (1n + v[0] / 100n) * 100n;
        break
      } else yield v;
    }
  })()

  // Chords
  #harmCombs = (dec, acc = [], cur = 0) => [ ...this.harmonicList ]
    .reduce((ar, [ n, { primeDecomp } ], i) => {
      if (cur > i) return ar;
      const
        newDec = primeDecomp.reduce((a, [ p, prad ]) => {
          if (a === null) return null;
          const rad = a.get(p);
          return rad >= prad ? rad === prad ? (a.delete(p), a) : a.set(p, rad - prad) : null
        }, new Map(dec));
      return newDec === null ? ar : ar.concat([[n, newDec, i]])
    }, [])
    .reduce((ar, [n, newDec, cur]) => ar.concat(newDec.size === 0 ?
      [ acc.concat([n]) ] : this.#harmCombs(newDec, acc.concat([n]), cur)), [])

  #enumStacks (ots, uts) {
    let flag = ots.flat().length > uts.flat().length;
    if (flag) ([ots, uts] = [uts, ots]);  // ots lesser than uts
    return ots.reduce((a, oharm) =>
      oharm.reduce((b, h, i) => 
        b.concat(a.map(([o, ivs]) => [
          i === oharm.length - 1 ? o : o.concat([ oharm.toSpliced(oharm.length - 1 - i) ]),
          ivs.concat(oharm.toSpliced(i + 1).map(h => [h, 1]))
        ])), a.map(([o, ivs]) => [ o.concat([oharm]), ivs ])),
      [[[], []]])
      .reduce((a, [o, ivs]) =>
        a.concat(o.reduce((b, oharm) => 
          b.reduce((c, [puts, pivs]) =>
            c.concat(puts.reduce((d, puharm, i) =>
              d.reduce((e, [pputs, ppivs, poharm]) => {
                const min = Math.max(0, poharm.length - pputs.slice(i + 1).flat().length)
                return e.concat(
                  poharm.slice(min, puharm.length)
                    .map((oh, k) => [
                      pputs.with(i, puharm.slice(min + k)),
                      ppivs.concat(Array(min + k).fill([oh, puharm[0]])),
                      poharm.slice(min + k)
                    ])
                    .concat([[
                      pputs.with(i, puharm.slice(poharm.length)),
                      ppivs.concat(poharm.toSpliced(puharm.length).fill([poharm[0], puharm[0]])),
                      poharm.slice(puharm.length)
                    ]])
                )
              }, []),
              [[puts, pivs, oharm]])),
            []),
          [[uts, ivs]])),
        [])
      .map(([puts, pivs]) => flag ?
        pivs.map(([u, o]) => [o, u]).concat(puts.flat().map(h => [h, 1])):
        pivs.concat(puts.flat().map(h => [1, h])))
  }

  #partitionComma (iv, { octaves = 1 } = {}) {
    const
      { intervalSet } = this, { edo } = this.#keyboard,
      [ nCombs, dCombs ] = iv.splitDecomp.map(side => side.length ?
        this.#harmCombs(new Map(side)).map(p => Common.group(p)) : [[]]);
    let acc = [];
    for (let otones of nCombs) for (let utones of dCombs)
      for (let partition of this.#enumStacks(otones, utones)) {
        const
          partIvs = partition.map(([n, d]) => intervalSet.getRatio(n, d).withOctave(0)),
          invIvs = partition.map(([d, n]) => intervalSet.getRatio(n, d).withOctave(0));
        if (partIvs.reduce((a, iv) => a + iv.steps(), 0) === octaves * edo) acc.push(partIvs);
        if (invIvs.reduce((a, iv) => a + iv.steps(), 0) === octaves * edo) acc.push(invIvs)
      }
    return acc
  }

  #enumChords = ivs => {  // Joe Sawada, A fast algorithm to generate necklaces with fixed content
    const
      ivClasses = Common.group(ivs),
      ns = ivClasses.map((kl, i) => kl.length - !i),
      word = ivs.slice().fill(0);
    function * necklaces (t, p) {
      if (t > ivs.length && ivs.length % p === 0) yield word.map(i => ivClasses[i][0]);
      else for (let i = word[t - p - 1]; i < ivClasses.length; i++) if (ns[i] > 0) {
        word[t - 1] = i;
        ns[i]--;
        if (i === word[t - p - 1]) yield * necklaces(t + 1, p);
        else yield * necklaces(t + 1, t);
        ns[i]++
      }
    }
    return necklaces(2, 1)
  }

  chords (iv) {
    const existing = this.#temperaments.get(iv)
    if (existing) {
      this.temperament = existing
      return existing.chords;
    }
    const comma = iv.fraction;
    if (Common.bigLog2(comma[0]) - Common.bigLog2(comma[1]) >= this.#scale.maxError / 400)
      throw new Error("Mapping error: comma to temper must be within error bounds");
    const
      { intervalSet } = this, keyboard = this.#keyboard,
      properIntervals = this.getProperIntervals(),
      ivOrder = (a, b) => {
        const [ an, ad ] = a.fraction, [ bn, bd ] = b.fraction;
        return an * bd > ad * bn
      },
      harms = [1].concat([ ...this.harmonicList.keys() ]
        .filter(h => Common.gcd(h, iv.n) > 1 || Common.gcd(h, iv.d) > 1)
        .sort((a, b) => Math.log2(a) % 1 < Math.log2(b) % 1)),

      { true: pairs = [], false: basicStacks = [] } = Common.groupBy(this.#partitionComma(iv), ivs => ivs.length === 2),
      enharms = pairs.reduce((m, [a, b]) => a === b ?  // Could be a map
        m.set(a, a.inverse()) : m.set(a, b.inverse()).set(b, a.inverse()), new Map()),
      stacks = basicStacks.map(ivs => ivs.reduce((acc, iv) => {
        const
          ni = harms.indexOf(iv.n), di = harms.indexOf(iv.d),
          divs = ni > di ?
            harms.slice(ni + 1).concat(harms.toSpliced(di)) :
            harms.slice(ni + 1, di),
          ivPartitions = divs.reduce((acc, h) => acc.map(basePart => {
            const [ n, d ] = basePart.at(-1);
            return [ basePart, basePart.toSpliced(-1).concat([ [n, h], [h, d] ]) ]
          }).flat(), [[ iv.fraction ]])
          .map(ivs => ivs.map(([n, d]) => intervalSet.getRatio(n, d).withOctave(0)));
        return acc.map(pch => ivPartitions.map(ivpart => pch.concat(ivpart))).flat()
      }, [[]])).flat()
      .reduce((acc, ivs) => {
        ivs.sort((a, b) => ivOrder(b, a)); // Ascending order
        let low = 0, high = acc.length;
        while (low < high) {
          const mid = (low + high) >>> 1, checkIvs = acc[mid];
          if (checkIvs.length < ivs.length || (checkIvs.length === ivs.length &&
            checkIvs.reduce((b, iv, i) => {
              if (b !== null) return b;
              const [ an, ad ] = iv.fraction, [ bn, bd ] = ivs[i].fraction, l = an * bd, r =  ad * bn;
              return l < r ? true : l > r ? false : null
            }, null))) low = mid + 1;  // Lex order
          else high = mid
        }
        if (acc[low]?.every((iv, i) => iv === ivs[i])) return acc;
        return acc.toSpliced(low, 0, ivs)
      }, []),

      chordIvs = new Set(stacks.flatMap(ivs => ivs)),
      equivs = Common.mapBy(stacks
        .flatMap(ivs => ivs.map((iv, i) => [ iv.inverse(), ivs.toSpliced(i, 1).sort(ivOrder) ]))
        .filter(([iv, ch], i, ar) => {
          if (i === 0) return true;
          const [ iv0, ch0 ] = ar[i - 1];
          return iv.n !== iv0.n || iv.d !== iv0.d || !ch.every((iv, i) => iv === ch0[i])
        }), ([a]) => a, ([,b]) => b),
      chords = stacks.map(ivs => [ ...this.#enumChords(ivs) ]).flat()
        .reduce((acc, ch) => {
          const intIvs = ch.map(iv => Array(ch.length - 1).with(0, iv));
          ch.forEach((iv, i) => intIvs[(i + 1) % ch.length][ch.length - 2] = iv.inverse());
          for (let j = 2; j <= ch.length / 2; j++) for (let i = 0; i < ch.length / (1 + (ch.length === j * 2)); i++) {
            const
              subchs = (i + j >= ch.length ?
                [ ch.slice(i).concat(ch.toSpliced(i + j - ch.length)), ch.slice(i + j - ch.length, i) ] :
                [ ch.slice(i, i + j), ch.slice(i + j).concat(ch.toSpliced(i)) ]).map(subch => subch.toSorted(ivOrder)),
              facts = subchs.map(subch => {
                const [ n, d ] = subch.reduce(([ao, au], iv) => [ao * iv.n, au * iv.d], [1, 1]);
                return new Interval({ keyboard, mapping: this, n, d })
              }),
              natural = facts.reduce((res, fact, p) => res || (properIntervals.has(fact) &&
                ((comma[0] % fact.n && comma[1] % fact.d) || (comma[0] % fact.d && comma[1] % fact.n)) &&
                (p ? fact.inverse() : fact)), false),
              tempered = subchs.reduce((b, subch, p) => {
                if (b) return b;
                const entry = [ ...equivs ].find(([, ar]) => ~ar.findIndex(x => x.length === subch.length && x.every((iv, i) => iv === subch[i])));
                return entry && (p ? entry[0].inverse() : entry[0]);
              }, false);
            const equiv = natural || tempered;
            if (!equiv) return acc;
            intIvs[i][j - 1] = equiv;
            intIvs[(i + j) % ch.length][ch.length - 1 - j] = equiv.inverse()
          }
          return acc.concat([intIvs])
        }, [])
        .map(internalIntervals => {
          internalIntervals.forEach(ivs => ivs.unshift(this.unison));
          return new Chord({ keyboard, mapping: this, type: "essentially tempered", internalIntervals })
        });
    const temperament = new Temperament({ keyboard, mapping: this, comma: iv, chords, enharms });
    this.#temperaments.set(iv, temperament);
    this.temperament = temperament;
    return temperament.chords
  }

  setTemperament (n, d) {
    const
      keyboard = this.#keyboard,
      temp = this.#temperaments.get(new Interval({ keyboard, mapping: this, n, d }));
    if (temp) this.temperament = temp
  }

}

class Harmonic {
  #keyboard; #mapping; order; isBasis; countingFn = null; decomp; primeDecomp
  isSubHarm = false; label
  constructor ({ keyboard, mapping, order, countingFn, isSubHarm = false }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Harmonic error: must provide Keyboard object");
    if (!(HarmonicMapping.prototype.isPrototypeOf(mapping))) throw new Error("Harmonic error: must provide HarmonicMapping object");
    this.#keyboard = keyboard;
    this.#mapping = mapping;
    this.order = order;
    this.isSubHarm = isSubHarm;
    this.primeDecomp = [ ...Common.decomp(order)[0] ];
    if (order === 1) { // Unison
      this.isBasis = false;
      this.decomp = () => []
    } else {
      const
        { nonHarmonics, index, primes, ready } = mapping,
        doErr = () => { throw new Error("Harmonic not in mapping") };
      if (ready) {
        let decomp = mapping.decomp(order);
        if (nonHarmonics.has(order) || decomp === null) doErr();
        this.isBasis = false;
        this.decomp = decomp
      } else {
        if (this.isBasis = primes.concat(index).includes(order)) this.countingFn = countingFn;
        else this.decomp = mapping.decomp(order)()
      }
    }
  }
  withQuality (q, mutate = false) {
    if (!["harmonic", "subharmonic"].includes(q)) return;
    const mapping = this.#mapping, { order } = this, isSubHarm = q === "subharmonic";
    if (mutate) {
      this.isSubHarm = isSubHarm;
      this.label = isSubHarm ?
        mapping.intervalSet.getRatio(1, order).noteSpelling.romanlow :
        mapping.intervalSet.getRatio(order, 1).noteSpelling.roman;
      return this
    } else return new Harmonic({
      keyboard: this.#keyboard, mapping,
      order: this.order, countingFn: this.countingFn, isSubHarm
    }).withQuality(q, true)
  }
}

class Interval {
  #keyboard; #mapping; n; d; params; octave; fraction; decomp; noteSpelling; isProper
  octaveAdjust; splitDecomp
  constructor ({ keyboard, mapping, n, d, params = [], isProper = false }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Interval error: must provide Keyboard object");
    if (!(HarmonicMapping.prototype.isPrototypeOf(mapping))) throw new Error("Interval error: must provide HarmonicMapping object");
    const c = Common.gcd(n, d);
    n = n / c;
    d = d / c;
    if (mapping.intervalSet.hasRatio(n, d)) return mapping.intervalSet.getRatio(n, d).withOctave(0);
    this.#keyboard = keyboard;
    this.#mapping = mapping;
    this.n = Common.non2(n);
    this.d = Common.non2(d);
    const
      isBig = typeof n === "bigint",
      log2 = isBig ? Common.bigLog2 : Math.log2,
      decomp = Common[isBig ? "decompBig" : "decomp"];
    this.octave = Math.floor(log2(n) - log2(d));
    const octave = this.octave = isBig ? BigInt(this.octave) : this.octave;
    this.octaveAdjust = octave;
    this.params = params;
    this.isProper = isProper;
    this.fraction = [ octave < 0 ? n << -octave : n, octave > 0 ? d << octave : d ];
    // this.decomp = mapping.decomp(n, d)(...params); // TODO: BigInt

    const pdec = decomp(n).concat([ new Map() ]);
    if (d) {
      for (let [p, rad] of decomp(d)[0]) if (pdec[0].has(p)) {
        const nrad = pdec[0].get(p);
        if (nrad <= rad) pdec[0].delete(p);
        if (nrad > rad) pdec[0].set(p, nrad - rad);
        else if (nrad < rad) pdec[1].set(p, rad - nrad);
      } else pdec[1].set(p, rad)
    }
    this.splitDecomp = pdec.map(m => [ ...m ].sort(([a], [b]) => a > b));
    this.decomp = this.splitDecomp.reduce((n, d) => n.concat(d.map(([p, rad]) => [p, -rad])))
      .sort(([a], [b]) => a > b);
    this.noteSpelling = Common.noteFromFactors(this.splitDecomp)
  }
  withOctave (o) {
    const
      octave = this.octaveAdjust = this.octave - o,
      { n, d } = this;
    this.fraction = [ octave < 0 ? n << -octave : n, octave > 0 ? d << octave : d ];
    return this
  }
  steps () {
    const { stepsBasis } = this.#mapping, { edo } = this.#keyboard;
    return this.decomp.reduce((acc, [p, rad]) => acc + stepsBasis.get(p) * rad, 0) - Number(this.octaveAdjust) * edo
  }
  inverse () { return new Interval({ keyboard: this.#keyboard, mapping: this.#mapping, n: this.d, d: this.n }) }
}

class IntervalSet {
  #mapping; #rawMap // Map([ denominator, Map([ numerator, interval ]) ])
  constructor (mapping, intervalList = []) {
    this.#mapping = mapping;
    this.#rawMap = new Map();
    for (let interval of intervalList) this.add(interval)
  }
  add (interval) {
    const { n, d } = interval, dMap = this.#rawMap.get(d) ?? this.#rawMap.set(d, new Map()).get(d);
    if (!dMap.has(n)) dMap.set(n, interval)
  }
  has (interval) {
    const { n, d } = interval;
    return Boolean(this.#rawMap.get(d)?.has(n))
  }
  hasRatio (n, d) {
    const c = Common.gcd(n, d);
    return Boolean(this.#rawMap.get(Common.non2(d / c))?.has(Common.non2(n / c)))
  }
  get (interval) {
    const { n, d } = interval;
    return this.#rawMap.get(d)?.get(n)
  }
  getRatio (n, d) {
    const c = Common.gcd(n, d), iv = this.#rawMap.get(Common.non2(d / c))?.get(Common.non2(n / c));
    if (iv === undefined) return iv;
    return iv.withOctave(Math.floor(Math.log2(n / d)))
  }
  * [ Symbol.iterator ] () { for (let [g, s] of this.#rawMap) for (let [h, iv] of s) yield iv }
}



// Keyboard grid

class HexGrid { // TODO: set w, h, theta within HexGrid
  #keyboard
  w = 0; h = 0; c; unit; r; octLen
  gstep; hstep; orientations; theta = 0
  orientation
  #hexes = new Map(); #edges; #notes
  #active = new Map() // Map([hex, Set(id)])
  #bgImgCache

  constructor ({ keyboard, gstep, hstep, unit, orientation }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("HexGrid error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (typeof gstep !== "number" || gstep < 1 || gstep > app.maxEdo || gstep % 1 ||
      typeof hstep !== "number" || hstep < 1 || hstep > app.maxEdo || hstep % 1) throw new Error("Keyboard error: bad grid steps");
    if (typeof unit !== "number" || unit < 5 || unit > 1e4) throw new Error("Keyboard error: bad button size");
    if (!("length" in orientation) || orientation.length !== 2 || orientation.some(v => v < 0 || v > app.maxEdo || v % 1) ||
      orientation[0] * gstep + orientation[1] * hstep !== keyboard.edo) throw new Error("Keyboard error: bad orientation");
    this.gstep = gstep;
    this.hstep = hstep;
    this.genOrientations();
    this.setOrientation(...orientation);
    this.unit = unit;
    this.r = this.unit * 2
  }

  #newHex (g, h, isGhost) {
    const row = this.#hexes.get(g) ?? this.#hexes.set(g, new Map()).get(g),
          hex = new HexButton({ keyboard: this.#keyboard, hexGrid: this, g, h, isGhost });
    row.set(h, hex);
    return hex
  }

  getHex (g, h) { return this.#hexes.get(g)?.get(h) }
  hasHex (g, h) { return this.#hexes.get(g)?.has(h) ?? false }

  * [Symbol.iterator] () { for (let [ , row ] of this.#hexes) for (let [ , hex ] of row) yield hex }

  addToActive (hex, id) {
    const active = this.#active;
    active.set(hex, (active.get(hex) ?? new Set()).add(id))
  }
  removeFromActive (hex, id) {
    const active = this.#active, ids = active.get(hex);
    if (!ids) return;
    ids.delete(id);
    if (ids.size === 0) active.delete(hex)
  }

  genOrientations () {
    const { gstep, hstep } = this, { edo } = this.#keyboard, res = [];
    for (let y = 0; y <= edo / hstep; y++) {
      const x = (edo - hstep * y) / gstep;
      if (x === Math.floor(x)) res.push ([ x, y ])
    }
    this.orientations = res;
  }
  setOrientation (g, h) {
    this.orientation = [ g, h ];
    const { unit, w } = this, x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5;
    this.theta = Math.atan(y / x)
  }
  setLattice ({ gstep, hstep }) {
    Object.assign(this, { gstep, hstep });
    this.genOrientations();
    const
      { orientations } = this,
      orientation = orientations.find(([g, h]) => g + h === 7) || orientations[0];
    if (!orientation) return false;
    this.setOrientation(...orientation)
    return true
  }

  updateGrid (force) {
    if (this.#notes && !force) return;
    const
      { gstep, hstep, c, w, octLen, orientation: [ g, h ] } = this,
      { edo } = this.#keyboard;

    // Central line
    this.#hexes = new Map();
    this.#edges = new Set([this.#newHex(0, 0, false)]);
    this.#notes = new Set([0]);
    let left = .5, right = .5, focus = [ [0, 0], [0, 0] ];
    for (let i = 1; i <= g + h; i++) {
      if (left / i <= h / (g + h)) { left++; focus[0][1]++ } else focus[0][0]++;
      if (right / i < h / (g + h)) { right++; focus[1][1]++ } else focus[1][0]++;
      this.#edges.add(this.#newHex(...focus[0], false));
      this.#notes.add(focus[0][0] * gstep + focus[0][1] * hstep);
      if (focus[0].every((v, i) => v === focus[1][i])) continue
      this.#edges.add(this.#newHex(...focus[1], false));
      this.#notes.add(focus[1][0] * gstep + focus[1][1] * hstep)
    }

    // One octave
    const rank = (g, h) => Common.mod(g * gstep + h * hstep, edo),
          dev = coord => Math.abs(this.h / 2 - HexButton.centre(...coord, this)[1]);
    this.fillGrid({
      candidate: (g0, h0) => Common.between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(rank(g0, h0)),
      filter: hexes => Common.group(hexes, ([a, b], [c, d]) => rank(a - c, b - d) === 0)
        .map(enhs => enhs.sort((a, b) => dev(a) > dev(b))[0]),
      isGhost: () => false
    });

    // Two octaves
    this.#notes = new Set();
    this.fillGrid({
      candidate: (g0, h0) => Common.between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(rank(g0, h0)),
      filter: hexes => Common.group(hexes, ([a, b], [c, d]) => rank(a - c, b - d) === 0)
        .filter(([[g0, h0]]) => !this.#notes.has(rank(g0, h0)))
        .map(enhs => enhs.sort((a, b) => dev(a) > dev(b))[0]),
      isGhost: () => true
    });

    // Fill to sides
    const home = [ ...this ];
    this.fillGrid({
      candidate: (g0, h0) => {
        const homeEquiv = ~home.findIndex(hex => {
                const [ baseG, baseH ] = hex.getCoord();
                return (baseG - g0) * h === (baseH - h0) * g // require gcd(g, h) === 1
              });
        return homeEquiv && HexButton.vertices(g0, h0, this).some(([ px, py ]) =>
          px > 0 && px < this.w && py > 0 && py < this.h)
      },
      isGhost: (g0, h0) => home.find(hex => {
        const [ baseG, baseH ] = hex.getCoord();
        return (baseG - g0) * h === (baseH - h0) * g
      }).isGhost
    });

    // Notes
    for (let hex of this) if (!hex.isGhost) {
      const
        [ octave, rank ] = hex.note(),
        note = this.#keyboard.scale.addNote({ octave, rank });
      if (octave === 0) note.getKey().setHome(hex)
    }
  }

  async fillGrid ({ candidate, filter = x => x, isGhost }) {
    let viewEdges = new Set([ ...this.#edges ]);
    while (viewEdges.size > 0) {
      let newViewEdges = new Map(), removeViewEdges = new Set(), newNotes = new Set();
      for (let hex of viewEdges) {
        let remove = true;
        for (let [g, h] of hex.neighbours()) {
          const thisHex = this.getHex(g, h);
          if (thisHex) { if (viewEdges.has(thisHex)) removeViewEdges.add(thisHex) }
          else if (candidate(g, h)) {
            newViewEdges.get(g)?.add(h) ?? newViewEdges.set(g, new Set([h]));
            newNotes.add(Common.mod(g * this.gstep + h * this.hstep, this.#keyboard.edo));
          } else remove = false;
        }
        removeViewEdges.add(hex)
        if (remove) this.#edges.delete(hex)
      }
      filter([ ...(function * () {
        for (let [g, s] of newViewEdges) for (let h of s) yield [g, h]
      })() ]).forEach(([g, h]) => {
        const nextHex = this.#newHex(g, h, isGhost(g, h));
        this.#edges.add(nextHex);
        viewEdges.add(nextHex)
      });
      removeViewEdges.forEach(hex => viewEdges.delete(hex));
      this.#notes = new Set([ ...this.#notes, ...newNotes ])
    }
  }

  rotate (x, y, rev = false) {
    const cx = this.w / 2, cy = this.h / 2, theta = rev ? -this.theta : this.theta,
          cos = Math.cos(theta), sin = Math.sin(theta);
    return [ cos * (x - cx) + sin * (y - cy) + cx, cos * (y - cy) - sin * (x - cx) + cy ]
  }

  getCoord (x, y) {
    const { r, w: width, h: height, c } = this;
    ([ x, y ] = this.rotate(x * 2 + c, y * 2, true));
    const a = (x - width / 2) / r / Math.sqrt(3) * 2,
          b = (y - height / 2) / r * 2,
          band = Math.floor(Math.floor((b + 1) / 3));
    if (((Math.floor(b % 3)) + 3) % 3 === 1) {
      const clampedA = ((a % 1) + 1) % 1, clampedB = ((b % 1) + 1) % 1,
            topLeft = clampedA + clampedB > 1, bottomLeft = clampedA < clampedB,
            h = 2 * Math.floor((b + 4) / 6), g = Math.floor((a - h) / 2);
      if (band % 2) return Math.floor(a) % 2 ? [ g + 1, h - !topLeft ] : [ g + !bottomLeft, h - !bottomLeft ];
      else return Math.floor(a) % 2 ? [ g + !bottomLeft, h + bottomLeft ] : [ g, h + topLeft ]
    } else return [ Math.floor((a - band + 1) / 2), band ]
  }

  // TODO urgent: needs BigInt Interval
  classifyKeys (force) {
    if (this.#notes && !force) return;
    const 
      { scale, edo } = this.#keyboard, { mapping } = scale,
      { primes, indexPrimes, index, intervalSet, harmonicList, rawHarmonicList } = mapping,
      bases = primes.map(p => [ p, p ])
        .concat(indexPrimes.map(p => [ p, index.find(h => harmonicList.get(h).primeDecomp.some(([q]) => q === p)) ]))
        .sort(([a], [b]) => a > b).map(([ , h ]) => intervalSet.getRatio(h, 1).withOctave(0));
    let i = edo - 1, full, prev, k = 0, result = Array(edo).fill(), prevResult,
        ivset = mapping.getProperIntervals(), prevIvset;
    result[0] = [[[], []]];
    for (let basis of bases) {
      const [ pn, pd ] = basis.fraction.map(Common.non2), pstep = basis.steps();
      prevIvset = new IntervalSet(mapping, ivset);
      full = i;
      prev = null;
      while (i > 0 && (i !== prev || i === full) && rawHarmonicList.size) {
        full = null;
        prev = i;
        prevResult = structuredClone(result);
        for (let iv of prevIvset) {
          const [ n, d ] = iv.fraction.map(Common.non2), step = iv.steps();
          let s = Common.mod(step + k * pstep, edo);
          if (prevResult[s] === undefined && mapping.decomp(n * pn ** k, d * pd ** k)()) {
            const newIv = new Interval({ keyboard: this.#keyboard, mapping, n: n * pn ** k, d: d * pd ** k });
            (result[s] ??= (i--, [])).push(newIv.splitDecomp);
            ivset.add(newIv)
          }
          s = Common.mod(step - k * pstep, edo);
          if (k > 0 && prevResult[s] === undefined && mapping.decomp(n * pd ** k, d * pn ** k)()) {
            const newIv = new Interval({ keyboard: this.#keyboard, mapping, n: n * pd ** k, d: d * pn ** k });
            (result[s] ??= (i--, [])).push(newIv.splitDecomp);
            ivset.add(newIv)
          }
        }
        k++
      }
      if (i <= 0) break;
      k = 1
    }
    for (let iv of ivset) mapping.intervalSet.add(iv);
    for (let hex of this) {
      const
        [ octave, rank ] = hex.note(), labels = [],
        scaleKey = scale.getKey(rank),
        note = scaleKey.addNote(octave);
      hex.setNote(note);
      if (result[rank]) for (let i = 0, ivs = result[rank]; i < ivs.length; i++) {
        const { accid, ...labelStrings } = Common.noteFromFactors(ivs[i]);
        let keyClass = Common.between(6, 10, Common.mod(accid[3], 12)) ? "black" : "white";
        const ot = ivs[i][0].findLast(([p]) => p !== 3);
        if (ot) keyClass += ot[0] + "o";
        const ut = ivs[i][1].findLast(([p]) => p !== 3);
        if (ut) keyClass += ut[0] + "u";
        labels.push({ ...labelStrings, keyClass, interval: ivs[i] })
      }
      if (!scaleKey.getLabels().length) scaleKey.setLabels(labels)
    }
  }

  redraw (force) {
    const { gridctx, canvas } = app.state(), { width, height } = canvas;
    this.updateGrid(force);
    this.classifyKeys(force);
    gridctx.fillStyle = "#000000";
    gridctx.fillRect(0, 0, width, height);
    for (let hex of this) hex.colour();  // Redraw by local hexes?
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(new Blob([blob]));
      canvas.style.backgroundImage = `url('${url}'), url('${this.#bgImgCache ?? url}')`;
      this.#bgImgCache = url
    })
  }

  colour () {
    const { gridctx, canvas } = app.state(), { width, height } = canvas;
    gridctx.clearRect(0, 0, width, height);
    for (let [hex] of this.#active) hex.colour({ bgColour: Keyboard.noteColours.active })
  }
}

class HexButton {
  static #colourMix = (hc1, hc2, t) => {
    if (![hc1, hc2].every(hc => hc.match(/#\p{Hex_Digit}{6}/ug))) return null;
    const [r1, g1, b1] = hc1.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
    const [r2, g2, b2] = hc2.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
    return "#" + [[r1, r2], [g1, g2], [b1, b2]].reduce((a, [l, r]) => a + Math.round(Common.lerp(l, r, t)).toString(16).padStart(2, "0"), "")
  }
  static #contrast = hc => {
    if (!hc.match(/#\p{Hex_Digit}{6}/ug)) return null;
    const [r, g, b] = hc.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
    return r * .299 + g * .587 + b * .114 >= 128 ? "#222222" : "#dddddd"
  }

  static vertices (g, h, grid) {
    const { r, w, h: ht, c } = grid, x = w / 2, y = ht / 2, k = .5 * Math.sqrt(3),
          origin = [
            [ x, y - r ], [ x - r * k, y - r / 2 ], [ x - r * k, y + r / 2 ],
            [ x, y + r ], [ x + r * k, y + r / 2 ], [ x + r * k, y - r / 2 ]
          ];
    return origin.map(([ a, b ]) => {
      const [ rx, ry ] = grid.rotate(
              Math.floor(a + r * k * (h + 2 * g)),
              Math.floor(b + 1.5 * r * h)
            );
      return [ rx - c, ry ]
    })
  }
  static centre (g, h, grid) {
    const { r, w: width, h: height, c } = grid, k = .5 * Math.sqrt(3),
          [ rx, ry ] = grid.rotate(
            Math.floor(width / 2 + r * k * (h + 2 * g)),
            Math.floor(height / 2 + 1.5 * r * h)
          );
    return [ rx - c, ry ]
  }

  #keyboard; #hexGrid; #g; #h; #note; isGhost
  constructor ({ keyboard, hexGrid, g, h, isGhost = false }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("HexButton error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (!(HexGrid.prototype.isPrototypeOf(hexGrid))) throw new Error("HexButton error: must provide HexGrid object");
    this.#hexGrid = hexGrid;
    this.#g = g;
    this.#h = h;
    this.isGhost = isGhost
  }
  vertices () { return HexButton.vertices(this.#g, this.#h, this.#hexGrid) }
  centre () { return HexButton.centre(this.#g, this.#h, this.#hexGrid) }

  neighbours () {
    const g = this.#g, h = this.#h;
    return [
      [ g - 1, h ], [ g, h - 1 ], [ g + 1, h - 1 ],
      [ g + 1, h ], [ g, h + 1 ], [ g - 1, h + 1 ]
    ]
  }

  getCoord () { return [ this.#g, this.#h ] }

  note () { // TODO: rename
    const n = this.#g * this.#hexGrid.gstep + this.#h * this.#hexGrid.hstep, { edo } = this.#keyboard;
    return [ Math.floor(n / edo), (n % edo + edo) % edo ]
  }
  setNote (note) { this.#note = note }
  getNote () { return this.#note }

  colour ({ bgColour, ctx } = {}) {
    ctx ??= app.state().gridctx;
    const
      { noteColours } = Keyboard,
      [ colourBase, oharm, uharm ] = this.#note.getKey().getLabel().keyClass
        ?.match(/(black|white)(?:(\d{1,2})o)?(?:(\d{1,2})u)?/)?.slice(1) ?? [],
      vertices = this.vertices(), { isGhost } = this,
      drawHex = c => {
        ctx.beginPath();
        ctx.moveTo(...vertices[5]);
        for (let [ x, y ] of vertices) ctx.lineTo(x, y);
        ctx.strokeStyle = isGhost ? c : "#dddddd";
        ctx.fillStyle = isGhost ? "#00000000" : c;
        ctx.lineWidth = isGhost ? 6 : 1;
        ctx.fill();
        ctx.stroke();
      }
    ctx.globalCompositeOperation = isGhost ? "lighten" : "source-over";
    if (bgColour) drawHex(bgColour);
    else if (colourBase) {
      const
        bc = noteColours[isGhost ? colourBase === "white" ? "black" : "white" : colourBase],
        oc = oharm ? HexButton.#colourMix(bc, noteColours[oharm] ?? noteColours.default, .1) : null,
        uc = uharm ? HexButton.#colourMix(bc, noteColours[uharm] ?? noteColours.default, .1) : null;
      if (oc && uc) {
        bgColour = HexButton.#colourMix(oc, uc, .5);
        drawHex(HexButton.#colourMix(oc, noteColours.white, .1));
        const [cx, cy] = this.centre();
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, this.#hexGrid.r, 0, Math.PI);
        ctx.closePath();
        ctx.clip();
        drawHex(HexButton.#colourMix(uc, noteColours.black, .1));
        ctx.restore();
      } else drawHex(bgColour = (oc ? HexButton.#colourMix(oc, noteColours.white, .1) : uc ?
        HexButton.#colourMix(uc, noteColours.black, .1) : bc))
    } else drawHex(bgColour = noteColours.default);
    ctx.font = (isGhost ? "bold  " : "") + (.5 * this.#hexGrid.r) + "px HEJI2, Ratafly";
    const [ x, y ] = this.centre(),
          { letter } = this.#note.getKey().getLabel(),
          { width } = ctx.measureText(letter);
    ctx.fillStyle = isGhost ? bgColour : HexButton.#contrast(bgColour);
    ctx.fillText(letter ?? this.note()[1], x - width / 2, y)
  }

  turnOn (id) { this.#hexGrid.addToActive(this, id) }
  turnOff (id) { this.#hexGrid.removeFromActive(this, id) }

}



// Keyboard

class Keyboard {

  // Static
  static presets = {
    "12edo": {
      gstep: 2, hstep: 1, orientation: [5, 2], unit: 45, refNote: 9, freqBasis: 220,
      edo: 12, limit: 9, maxError: 33, hmap: [[3, 7], [5, 4], [7, 10], [9, 2]], instrument: "triangle"
    },
    "19edo": {
      gstep: 3, hstep: 2, orientation: [5, 2], unit: 45, refNote: 14, freqBasis: 220,
      edo: 19, limit: 9, maxError: 22, hmap: [[3, 11], [5, 6], [7, 15], [9, 3]], instrument: "triangle"
    },
    "22edo": {
      gstep: 4, hstep: 1, orientation: [5, 2], unit: 45, refNote: 16, freqBasis: 220,
      edo: 22, limit: 11, maxError: 18, hmap: [[3, 13], [5, 7], [7, 18], [9, 4], [11, 10]], instrument: "triangle"
    },
    "31edo": {
      gstep: 5, hstep: 3, orientation: [5, 2], unit: 45, refNote: 23, freqBasis: 220,
      edo: 31, limit: 11, maxError: 12, hmap: [[3, 18], [5, 10], [7, 25], [9, 5], [11, 14]], instrument: "triangle"
    },
    "41edo": {
      gstep: 7, hstep: 3, orientation: [5, 2], unit: 45, refNote: 30, freqBasis: 220,
      edo: 41, limit: 15, maxError: 9, hmap: [[3, 24], [5, 13], [7, 33], [9, 7], [11, 19], [13, 29], [15, 37]], instrument: "triangle"
    },
    "53edo": {
      gstep: 5, hstep: 4, orientation: [5, 7], unit: 45, refNote: 39, freqBasis: 220,
      edo: 53, limit: 15, maxError: 8, hmap: [[3, 31], [5, 17], [7, 43], [9, 9], [11, 24], [13, 37], [15, 48]], instrument: "triangle"
    },
    "94edo": {
      gstep: 9, hstep: 7, orientation: [5, 7], unit: 45, refNote: 69, freqBasis: 220,
      edo: 94, limit: 21, maxError: 4, hmap: [[3, 55], [5, 30], [7, 76], [9, 16], [11, 43], [13, 66], [15, 85], [17, 8], [19, 23], [21, 37]], instrument: "triangle"
    },
  }

  static noteColours = {
    default: "#333333", active: "#ffff00",
    white: "#222222", black: "#777777",
    5: "#ff0000", 7: "#0000ff", 11: "#00ff00", 13: "#ff00ff"
  }

  static selectEl; static edoInfoEl; static limitInfoEl
  static gstepEl; static hstepEl; static orientationSelectEl; static unitEl
  static refNoteEl; static freqBasisEl; static edoEl; static limitEl; static maxErrorEl
  static scaleOutputEl
  static attach ({
    selectEl, edoInfoEl, limitInfoEl,
    gstepEl, hstepEl, orientationSelectEl, unitEl, refNoteEl, freqBasisEl,
    edoEl, limitEl, maxErrorEl, scaleOutputEl
  }) { Object.assign(this, {
    selectEl, edoInfoEl, limitInfoEl,
    gstepEl, hstepEl, orientationSelectEl, unitEl, refNoteEl, freqBasisEl,
    edoEl, limitEl, maxErrorEl, scaleOutputEl
  }) }

  static load ({ keyboards }) {
    let storedKeyboards = localStorage.getItem("keyboards");
    storedKeyboards ?
      Object.assign(keyboards ??= {}, JSON.parse(storedKeyboards)) :
      localStorage.setItem("keyboards", JSON.stringify(keyboards = Keyboard.presets));
    Object.keys(keyboards).forEach(name => {
      const el = $.load("option", "", Keyboard.selectEl)[0][0]
      el.innerText = name;
      el.setAttribute("name", name)
    });
    const customKeybOptEl = $.load("option", "", Keyboard.selectEl)[0][0]
    customKeybOptEl.innerText = "Custom";
    customKeybOptEl.setAttribute("name", "Custom");
    customKeybOptEl.disabled = true;

    let storedKeyboardSelection = localStorage.getItem("keyboardSelection"), keyboardSelection;
    storedKeyboardSelection ?
      (keyboardSelection = Keyboard.selectEl.value = storedKeyboardSelection) :
      localStorage.setItem("keyboardSelection", keyboardSelection = Object.keys(keyboards)[0]);

    let keyboard = keyboardSelection === "Custom" ? JSON.parse(localStorage.getItem("keyboard")) : keyboards[keyboardSelection];
    Keyboard.edoInfoEl.innerText = keyboard.edo;
    Keyboard.limitInfoEl.innerText = keyboard.limit;

    let noteColours = localStorage.getItem("noteColours");
    if (noteColours) Keyboard.noteColours = JSON.parse(noteColours);
    else localStorage.setItem("noteColours", JSON.stringify(Keyboard.noteColours));

    return { keyboard: new Keyboard({ name: keyboardSelection, ...keyboard }), keyboards }
  }

  static setColour (harm, colour, isBlackKeys) {
    if (harm === 3) Keyboard.noteColours[isBlackKeys ? "black" : "white"] = colour;
    else Keyboard.noteColours[harm] = colour;
    localStorage.setItem("noteColours", JSON.stringify(Keyboard.noteColours));
    this.getScope().keyboard.hexGrid.redraw()
  }

  static ready = false
  static getScope () { return app.menuState.at(-2) === "keyboard-settings" ? app.menuState[1] : app }

  // Instance
  name; edo; hexGrid; scale; instrument = "triangle"
  touches = new Map(); mousedown = false
  hoveredKey; wheelVal = 0; wheelSensitivity = 200
  clipboard = []; clipboardPeekIndex
  constructor ({
    name, edo,
    gstep, hstep, unit, orientation,
    limit, refNote, freqBasis, maxError,
      hmap,
    // instrument
  }) {
    // TODO: validation helper?
    if (typeof name !== "string" || name === "" || name.length > app.maxKeyboardNameLength) throw new Error("Keyboard error: bad name");
    if (typeof edo !== "number" || edo < 0 || edo > app.maxEdo || edo % 1) throw new Error("Keyboard error: bad EDO");
    this.name = name;
    this.edo = edo;
    this.hexGrid = new HexGrid({ keyboard: this, gstep, hstep, unit, orientation });
    this.scale = new Scale({ keyboard: this, limit, refNote, freqBasis, maxError })
  }

  load () {
    const { selectEl, edoInfoEl, limitInfoEl } = Keyboard, keyboardSelection = selectEl.value, keyboard = {};
    localStorage.setItem("keyboardSelection", keyboardSelection);
    if (keyboardSelection === "Custom") {
      Object.assign(keyboard, {
        name: "Custom",
        orientation: Keyboard.orientationSelectEl.value.split(",").map(v => parseInt(v)),
        hmap: $.all(".harmonic.prime > input.steps")
          .map(el => [parseInt(el.parentElement.dataset.harm), el.valueAsNumber])
      });
      [ "gstep", "hstep", "unit", "refNote", "freqBasis", "edo", "limit", "maxError" ]
        .forEach(dataname => keyboard[dataname] = Keyboard[dataname + "El"].valueAsNumber);
      Keyboard.getScope().keyboard = new Keyboard(keyboard);
      localStorage.setItem("keyboard", JSON.stringify(keyboard))
    } else {
      selectEl.namedItem("Custom").disabled = true;
      Object.assign(keyboard, app.keyboards[keyboardSelection], { name: keyboardSelection });
      localStorage.removeItem("keyboard");
      (Keyboard.getScope().keyboard = new Keyboard(keyboard)).fillSettings()
    }
    edoInfoEl.innerText = keyboard.edo;
    limitInfoEl.innerText = keyboard.limit;
    app.emit("generate-keyboard");
    return { keyboardSelection }
  }

  save () {
    const
      { name, edo, hexGrid, scale } = this,
      { gstep, hstep, unit, orientation } = hexGrid,
      { limit, refNote, freqBasis, maxError, mapping } = scale,
      { hmap } = mapping,
      storeObj = {
        edo, gstep, hstep, unit, orientation,
        limit, refNote, freqBasis, maxError, hmap
      },
      keyboardsObj = JSON.parse(localStorage.getItem("keyboards"));
    localStorage.setItem("keyboards", JSON.stringify(Object.assign(keyboardsObj, { [name]: storeObj })))
  }

  fillSettings () {
    const
      { gstepEl, hstepEl, orientationSelectEl, unitEl, refNoteEl, freqBasisEl,
        edoEl, limitEl, maxErrorEl, scaleOutputEl } = Keyboard,
      { edo, hexGrid, scale } = this,
      { gstep, hstep, unit, orientation, orientations } = hexGrid,
      { limit, refNote, freqBasis, maxError } = scale;
    gstepEl.value = gstep;
    hstepEl.value = hstep;
    $.all(":scope > *", orientationSelectEl).forEach(el => el.remove());
    orientations.forEach(coord => {
      const el = $.load("option", "", orientationSelectEl)[0][0];
      el.innerText = coord;
      el.setAttribute("name", coord)
    });
    orientationSelectEl.options.namedItem(orientation.join(",")).selected = true;
    unitEl.value = unit;
    refNoteEl.value = refNote;
    freqBasisEl.value = freqBasis;
    edoEl.value = edo;
    limitEl.value = limit;
    maxErrorEl.value = maxError
    scaleOutputEl.value = `One step of ${edo}EDO = ${(1200 / edo).toFixed(2)}Â¢`;
  }

  update () {
    const
      { orientationSelectEl, gstepEl, hstepEl, edoEl } = Keyboard,
      { keyboard } = Keyboard.getScope(), { hexGrid } = keyboard,
      gstep = gstepEl.valueAsNumber,
      hstep = hstepEl.valueAsNumber,
      edo = edoEl.valueAsNumber,
      applyButton = $("#keyboard-settings-apply");
    $.all(":scope > *", orientationSelectEl).forEach(el => el.remove());
    if (Common.gcd(gstep, hstep) !== 1) return applyButton.disabled = true;
    this.edo = edo;
    applyButton.disabled = false;
    if (!hexGrid.setLattice({ gstep, hstep })) return applyButton.disabled = true;
    hexGrid.orientations.forEach(coord => {
      const el = $.load("option", "", orientationSelectEl)[0][0];
      el.innerText = coord;
      el.setAttribute("name", coord)
    })
    orientationSelectEl.namedItem(hexGrid.orientation).selected = true
  }

  play (g, h, id) { // Convert g, h to hex?
    const
      { hexGrid, scale, touches } = this, hex = hexGrid.getHex(g, h),
      [ octave, rank ] = hex.note(), note = scale.getNote({ octave, rank });
    hex.turnOn(id);
    hexGrid.colour();
    note.turnOn(id);
    touches.set(id, { hex, note });
  }

  stop (id) {
    const { hexGrid, scale, touches } = this, touch = touches.get(id);
    if (!touch) return;
    touch.hex.turnOff(id)
    hexGrid.colour()
    touch.note.turnOff(id);
    touches.delete(id);
  }

  cycle (which, delta) {
    const { wheelSensitivity } = this;
    if (Common.between(0, wheelSensitivity, this.wheelVal += delta)) return;
    const { wheelVal } = this;
    this.wheelVal = Common.mod(wheelVal, wheelSensitivity);
    switch (which) {
      case "label":
        const { hoveredKey } = this;
        hoveredKey.setLabel(Common.mod(Math.floor(wheelVal / wheelSensitivity) + hoveredKey.getLabelIndex(), hoveredKey.getLabels().length));
        app.emit("resize", true);
        this.hexGrid.redraw();
        break
      case "clipboard":
        const { clipboard, clipboardPeekIndex } = this;
        this.clipboardPeekIndex = Common.mod(Math.floor(wheelVal / wheelSensitivity) + clipboardPeekIndex, clipboard.length);
        app.emit("clipboard-display-peek")
    }
  }

  refresh () {
    this.touches = new Map();
    this.scale.refresh();
    this.hexGrid.redraw(true)
  }

}

// Musical aspect of keyboard
class Scale {
  #keyboard; limit
  mapping; refNote; freqBasis; maxError
  #keys = new Map() // Map([ rank, key ])
  #active = new Map() // Map([ note, Set(id) ])
  constructor ({ keyboard, limit, hmap, refNote, freqBasis, maxError }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Scale error: must provide Keyboard object");
    this.#keyboard = keyboard;
    const { edo } = keyboard;
    if (typeof limit !== "number" || limit < 3 || limit > app.maxHarmonic || limit % 2 !== 1) throw new Error("Scale error: bad harmonic limit");
    if (typeof refNote !== "number" || refNote < 0 || refNote >= edo || refNote % 1) throw new Error("Scale error: bad reference note");
    if (typeof freqBasis !== "number" || freqBasis < 10 || freqBasis > 4e4) throw new Error("Scale error: bad reference frequency");
    if (typeof maxError !== "number" || freqBasis < 0 || freqBasis > 1200) throw new Error("Scale error: bad max pitch variation");
    this.limit = limit;
    this.maxError = maxError;
    this.refNote = refNote;
    this.mapping = new HarmonicMapping({ keyboard, scale: this, hmap: this.#genRawHMap({ edo, limit, maxError }) });
    this.freqBasis = freqBasis;

    for (let i = 0; i < edo; i++) this.#keys.set(i, new Key({ keyboard, scale: this, rank: i }))
  }

  #genRawHMap ({ edo, limit, maxError }) {
    let hmap = new Map();
    for (let i = 3; i <= limit; i += 2) {
      const
        just = Math.log2(i) % 1,
        maybeSteps = Math.round(just * edo),
        error = (maybeSteps / edo - just) * 1200;
      if (Math.abs(error) < maxError && maybeSteps + edo * maxError / 1200 >= 1 &&
        maybeSteps - edo * maxError / 1200 < edo) hmap.set(i, maybeSteps)
    }
    return hmap
  }

  getKey (rank) { return this.#keys.get(rank) }
  addNote ({ rank, octave }) { return this.#keys.get(rank).addNote(octave) }
  getNote ({ rank, octave }) { return this.#keys.get(rank)?.getNote(octave) }
  play (note, id) {
    const active = this.#active, ids = active.get(note);
    if (ids) ids.add(id);
    else {
      active.set(note, new Set([id]))
      note.start();
    } 
  }
  stop (note, id) {
    const active = this.#active, ids = active.get(note);
    if (!ids) return;
    ids.delete(id);
    if (ids.size === 0) {
      note.stop();
      active.delete(note)
    }
  }
  refresh () { this.#active = new Map() }
}

class Key {
  #keyboard; #scale; #notes = new Map(); #labels = []; #labelIndex = 0; #home; rank
  constructor ({ keyboard, scale, rank }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Key error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (!(Scale.prototype.isPrototypeOf(scale))) throw new Error("Key error: must provide Scale object");
    this.#scale = scale;
    this.rank = rank
  }
  addNote (octave) {
    const note = new Note({ keyboard: this.#keyboard, scale: this.#scale, rank: this.rank, octave });
    this.#notes.set(octave, note);
    return note
  }
  getNote (octave) { return this.#notes.get(octave) }
  getNotes () { return [ ...this.#notes ] }
  getLabels () { return this.#labels.slice() }
  getLabel () { return this.#labels[this.#labelIndex] ?? { label: this.rank } }
  getLabelIndex () { return this.#labelIndex }
  setLabels (labels) { this.#labels = labels }
  setLabel (i) { this.#notes.forEach(note => {
    if (Common.between(0, this.#labels.length - 1, i)) this.#labelIndex = i
  }) }
  setHome (hex) { this.#home = hex }
  getHome () { return this.#home }
}

class Note {
  #keyboard; #scale; #osc; #volume; rank; octave
  constructor ({ keyboard, scale, rank, octave }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("HexGrid error: must provide Keyboard object");
    if (!Scale.prototype.isPrototypeOf(scale)) throw new Error("Note error: must provide Scale object");
    const existing = scale.getNote({ rank, octave })
    if (existing) return existing;
    this.#keyboard = keyboard;
    this.#scale = scale;
    this.rank = rank;
    this.octave = octave
  }
  getKey () { return this.#scale.getKey(this.rank) }
  start () {
    const
      { audioctx, masterVolume } = app.state(),
      { rank, octave } = this, { freqBasis, refNote } = this.#scale, { edo } = this.#keyboard,
      osc = this.#osc = audioctx.createOscillator(),
      volume = this.#volume = audioctx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freqBasis * 2 ** (octave + ((refNote + rank) / edo));
    osc.connect(volume);
    volume.connect(masterVolume);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime)
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime + .05)
    osc.start(audioctx.currentTime)
  }
  stop () {
    const
      { audioctx } = app.state(),
      osc = this.#osc, volume = this.#volume;
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime + .05);
    osc.stop(audioctx.currentTime + .05);
    this.#osc = null;
    this.#volume = null
  }

  turnOn (id) { this.#scale.play(this, id) }
  turnOff (id) { this.#scale.stop(this, id) }
}



// Temperaments

class Temperament {
  #keyboard; #mapping; comma; #chords
  constructor ({ keyboard, mapping, comma, chords, enharms }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Temperament error: must provide Keyboard object");
    if (!(HarmonicMapping.prototype.isPrototypeOf(mapping))) throw new Error("Temperament error: must provide HarmonicMapping object");
    this.#keyboard = keyboard;
    this.#mapping = mapping;
    this.comma = comma;
    this.#chords = chords;
    this.enharms = enharms
  }
  get chords () { return this.#chords.map(ch => ch.withRoot(0, true)) }
  getChordByIntervals (ivs) {
    ivs = ivs.map(([n, d]) => new Interval({ keyboard: this.#keyboard, mapping: this.#mapping, n, d }));
    for (let chord of this.chords) {
      const civs = chord.intervals, m = ivs.length;
      if (m !== civs.length) continue;
      const i = civs.findIndex((_, j) => ivs.every((iv, k) => iv === civs[(j + k) % m]));
      if (~i) return chord.withRoot(i)
    }
  }
}

class Chord {  // TODO BigNum
  static types = [ "harmonic series", "essentially tempered" ]
  #keyboard; #mapping; type; adicity; #intervals; #internalIntervals
  harmonics; isSubHarm; #inversion
  constructor ({ keyboard, mapping, type, harmonics, bass, isSubHarm = false, internalIntervals }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Chord error: must provide Keyboard object");
    if (!(HarmonicMapping.prototype.isPrototypeOf(mapping))) throw new Error("Chord error: must provide HarmonicMapping object");
    this.#keyboard = keyboard;
    this.#mapping = mapping;
    if (typeof type !== "string" && !Chord.types.includes(type)) throw new Error("Chord error: unknown type");
    this.type = type;
    switch (type) {
      case "harmonic series":
      if (typeof bass !== "number" || !harmonics.includes(bass) || !("length" in harmonics) || harmonics.length < 2 ||
        harmonics.some(h => typeof h !== "number" || !mapping.decomp(h, bass)()))
        throw new Error("Chord error: harmonic not supported by temperament");
      this.adicity = harmonics.length;
      this.harmonics = harmonics;
      this.isSubHarm = isSubHarm;
      this.#inversion = 0;
      const ordHarms = harmonics.sort((a, b) => Math.log2(a) % 1 > Math.log2(b) % 1)
      // const octIndex = harmonics.length - ordHarms.indexOf(bass);
      ordHarms.splice(0, 0, ...ordHarms.splice(ordHarms.indexOf(bass)));
      this.#internalIntervals = ordHarms.map(d => ordHarms.map(n =>
        new Interval({ keyboard, mapping, ...(isSubHarm ? { n: d, d: n } : { n, d }) })));
      this.#intervals = this.internalIntervals.map(ivs => ivs[1])
      break
    case "essentially tempered":
      if (!("length" in internalIntervals) || internalIntervals.length < 2 ||
        internalIntervals.some((ivs, _, ar) => !("length" in ivs) || ivs.length !== ar.length ||
          !ivs.every(iv => Interval.prototype.isPrototypeOf(iv))))
        throw new Error("Chord error: malformed interval data");
      this.adicity = internalIntervals.length;
      this.#inversion = 0;
      this.#internalIntervals = internalIntervals;
      this.#intervals = internalIntervals.map(ivs => ivs[1])
    }
  }
  get inversion () { return this.#inversion }
  set inversion (i) {
    if (!Common.between(0, this.adicity - 1, i)) return;
    this.#inversion = i
  }
  get intervals () {
    const intervals = this.#intervals.slice();
    intervals.splice(0, 0, ...intervals.splice(this.#inversion));
    return intervals
  }
  get internalIntervals () { return this.#internalIntervals[this.#inversion].slice() }
  withRoot (i, mutate = false) {
    if (!Common.between(0, this.adicity - 1, i)) return;
    if (mutate) {
      this.#inversion = i;
      return this
    } else {
      const { type, harmonics } = this;
      let opts
      if (type === "harmonic series") opts = { harmonics, isSubHarm: this.isSubHarm, root: harmonics[0] };
      else if (type === "essentially tempered") opts = { internalIntervals: this.#internalIntervals };
      return new Chord({ keyboard: this.#keyboard, mapping: this.#mapping, type, ...opts }).withRoot(i, true)
    }
  }
  start (id) {
    const { scale } = this.#keyboard;
    this.internalIntervals.forEach((iv, i) =>
      this.#keyboard.play(...scale.getKey(iv.steps()).getHome().getCoord(), id + "-" + i))
  }
  stop (id) { for (let i = 0; i < this.adicity; i++) this.#keyboard.stop(id + "-" + i) }
}



// Track

class Track {}



// Menu state

class MenuState {}



// Page state

class Listeners {
  static dragDropTouch = ((img, dx, dy) => ({
    touchstart (e) {
      e.preventDefault();
      const
        { changedTouches: [ { pageX, pageY } ] } = e,
        { left, top } = this.getBoundingClientRect();
      dx = pageX - left;
      dy = pageY - top;
      img = this.cloneNode(true);
      img.id = "drag-feedback";
      img.style.setProperty("left", pageX - dx + "px");
      img.style.setProperty("top", pageY - dy + "px")
      $("body").appendChild(img)
    },
    touchmove ({ changedTouches: [ { pageX, pageY } ] }) {
      img.style.setProperty("left", pageX - dx + "px");
      img.style.setProperty("top", pageY - dy + "px");
      const clipboardEl = $("#clipboard-item-select");
      $("#clipboard-item-select").classList
        .toggle("active", document.elementsFromPoint(pageX, pageY).includes(clipboardEl))
    },
    touchend ({ changedTouches: [ { pageX, pageY } ] }) {
      img.remove();
      const clipboardEl = $("#clipboard-item-select");
      if (document.elementsFromPoint(pageX, pageY).includes(clipboardEl)) {
        const
          e = new Event("drop", { bubbles: true, cancelable: true }),
          tr = new DataTransfer(), { classList } = this;
        let data;
        if (classList.contains("harm-obj")) data = { type: "harmonic", order: this.parentElement.dataset.harm };
        else if (classList.contains("subharm-obj")) data = { type: "subharmonic", order: this.parentElement.dataset.harm };
        else if (classList.contains("interval-obj")) data = { type: "interval", interval: this.parentElement.dataset.interval };
        else if (classList.contains("chord")) data = { type: "chord", intervals: $(".chord-intervals", this).dataset.intervals };
        tr.setData("text/plain", JSON.stringify(data));
        tr.effectAllowed = "copy";
        tr.dropEffect = "copy";
        e.dataTransfer = tr;
        clipboardEl.dispatchEvent(e)
      }
    }
  }))()
}

// TODO: add freeze property feature to machine.js
var app = new $.Machine({
    // Version
      version: "0.0.1",

    // Navigation
      menuState: [],

      // Keyboard
      maxEdo: 270,
      maxKeyboardNameLength: 255,
      maxHarmonic: 51,

      keyboard: null,
      keyboards: null,
      keyboardSelection: null,

      canvas: null,
      gridctx: null,
      audioctx: null,
      masterVolume: null,

      octaves: null,

      // Track
      tracks: {},
      trackSelection: null
    });



// Events

$.targets({

  load () { app.emit("init") },

  keydown (e) { switch (e.key) {
    case "Control": $("body").classList.add("copying"); break
    case "Escape": document.activeElement.blur()
  } },
  keyup (e) { if (e.key === "Control") $("body").classList.remove("copying") },

  resize () {
    if (!Keyboard.ready) return;
    app.emit("resize", true);
    Keyboard.getScope().keyboard.hexGrid.redraw(true)
  },

  contextmenu (e) { e.preventDefault() },

  "touchstart touchend touchmove" (e) {
    if (!Keyboard.ready) return;
    const nav = $("nav");
    if (e.type === "touchstart" && document.activeElement === nav && !e.composedPath().includes(nav)) nav.blur();
    const canvas = $("canvas");
    if (e.target === $("main")) for (let { clientX, clientY, identifier } of e.changedTouches) {
      const
        x = clientX - canvas.offsetLeft, y = clientY - canvas.offsetTop,
        { keyboard } = Keyboard.getScope(), { hexGrid } = keyboard;
      if (keyboard && (keyboard.touches.has("touch-" + identifier) || e.type === "touchstart") &&
        (hexGrid.hasHex(...hexGrid.getCoord(x, y)) || e.type === "touchend"))
        app.emit("press", x, y, "touch", e.type.slice(5), identifier)
    }
  },

  mousedown (e) {
    if (!Keyboard.ready) return;
    const { keyboard } = Keyboard.getScope(), { hexGrid } = keyboard;
    if (e.target === $("main") && hexGrid.hasHex(...hexGrid.getCoord(e.layerX, e.layerY))) {
      keyboard.mousedown = true;
      app.emit("press", e.layerX, e.layerY, "mouse", "start")
    } else if (e.ctrlKey) {
      const mbCopy = e.target.closest(".copyable");
      if (mbCopy) app.emit("copy", { node: mbCopy })
    }
  },
  mousemove (e) {
    if (!Keyboard.ready) return;
    const
      { keyboard } = Keyboard.getScope(), { hexGrid, mousedown } = keyboard,
      hex = hexGrid.getHex(...hexGrid.getCoord(e.layerX, e.layerY)), main = $("main");
    main.classList.toggle("hover", (mousedown || e.target === main) && Boolean(hex));
    if (!mousedown) keyboard.hoveredKey = e.target === main ? hex?.getNote().getKey() : null;
    if (mousedown && hex) app.emit("press", e.layerX, e.layerY, "mouse", "move");
  },
  "mouseup mouseout" (e) {
    if (!Keyboard.ready) return;
    const { keyboard } = Keyboard.getScope();
    if (keyboard.mousedown && e.type !== "mouseout") {
      keyboard.mousedown = false;
      app.emit("press", e.layerX, e.layerY, "mouse", "end")
    }
  },

  wheel (e) {
    const { keyboard } = Keyboard.getScope();
    if (keyboard.hoveredKey) keyboard.cycle("label", e.deltaY);
    else if (e.composedPath().includes($("#clipboard-peek"))) keyboard.cycle("clipboard", e.deltaY)
  },

  document: { fonts: { loadingdone () {
    if (!Keyboard.ready) return;
    app.emit("resize", true);
    Keyboard.getScope().keyboard.hexGrid.redraw(true)
  } } },

  app: {

    init () {
      const { version } = this;
      if (Common.versionCmp(version, localStorage.getItem("version") ?? "0") > 0) {
        localStorage.clear();
        localStorage.setItem("version", version)
      }
      this.canvas = $("#hex");
      this.gridctx = this.canvas.getContext("2d");

      new ResizeObserver(() => {  // Put these elsewhere? TODO: reset css vars on resize
        this.emit("resize", true);
        Keyboard.getScope().keyboard.hexGrid.redraw(true)
      }).observe($("main"));
      const
        keyboardSettingsEl = $("#keyboard-settings"),
        mappingFieldsetEl = $("#harmonic-mapping"),
        ivInnerTableEl = $("#interval-table"), diamondEl = $("#diamond");
      new ResizeObserver(() =>
        mappingFieldsetEl.style.setProperty("--iv-display-height", `${Math.round(keyboardSettingsEl.offsetHeight)}px`)
      ).observe(keyboardSettingsEl);
      const
        ro1 = new ResizeObserver(() => {
          const height = diamondEl.offsetHeight || ivInnerTableEl.offsetHeight;
          mappingFieldsetEl.style.setProperty("--iv-display-scrollHeight", `${Math.round(height)}px`)
        }),
        ro2 = new ResizeObserver(() => {
          const
            { offsetHeight, offsetTop } = $("#interval-view"), { offsetTop: fsTop } = mappingFieldsetEl,
            { offsetLeft: x } = $("#keyboard-settings > form");
          mappingFieldsetEl.style.setProperty("--iv-display-offsetTop", `${Math.round(offsetHeight + offsetTop - fsTop - x)}px`)
        });
      ro1.observe(diamondEl);
      ro1.observe(ivInnerTableEl);
      ro2.observe(keyboardSettingsEl);
      ro2.observe($("#mapping"));
      ro2.observe($("#ivtable-wrapper"));
      const
        tempsEl = $("#temperaments"), tempsListEl = $("#temperament-list"),
        loadingCommasEl = $("#computing-commas");
      let iv, isInt;
      new IntersectionObserver(es => es.forEach(e => {
        const { isIntersecting } = e;
        if (!iv) iv = setInterval(() => {
          if (isInt) this.emit("generate-temperaments");
          else {
            clearInterval(iv);
            iv = false
          }
        }, 0);
        loadingCommasEl.classList.toggle("active", isInt = isIntersecting)
      }), { threshold: [0, .01] }).observe(loadingCommasEl);
      let prevTpWidth = 0;
      new ResizeObserver(() => {
        tempsListEl.style.setProperty("--tp-display-height", `${Math.round(tempsEl.offsetHeight)}px`);
        tempsListEl.style.setProperty("--tp-display-width", `${prevTpWidth = Math.max(prevTpWidth, 2 + Math.round(tempsListEl.offsetWidth))}px`)
      }).observe(tempsListEl);

      $.all("input[size]").forEach(el => el.style.setProperty("--size", el.size));

      const
        audioctx = this.audioctx = new AudioContext(),
        masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = Common.scaleVolume($("#volume > input").valueAsNumber);
      $("#track-select > select").selectedIndex = 0;

      Keyboard.attach({
        // Keyboard selection
        selectEl: $("#keyboard-select > select"),
        edoInfoEl: $("#edo-info"),
        limitInfoEl: $("#limit-info"),

        // Keyboard settings
        gstepEl: $("#gstep > input"),
        hstepEl: $("#hstep > input"),
        orientationSelectEl: $("#orientation > select"),
        unitEl: $("#unit > input"),
        refNoteEl: $("#refNote > input"),
        freqBasisEl: $("#freqBasis > input"),
        edoEl: $("#edo > input"),
        limitEl: $("#limit > input"),
        maxErrorEl: $("#maxError > input"),
        scaleOutputEl: $("#scale > output")
      });
      Keyboard.limitEl.max = this.maxHarmonic;
      this.emit("load-presets");
    },

    "clear-storage" () { localStorage.clear() },

    "load-presets" () {
      const octaves = localStorage.getItem("octaves");
      if (!octaves) {
        this.octaves = $("#octaves > input").valueAsNumber;
        localStorage.setItem("octaves", this.octaves);
      } else this.octaves = $("#octaves > input").value = parseInt(octaves);

      const { keyboard, keyboards } = Keyboard.load({ keyboards: this.keyboards, keyboardSelection: this.keyboardSelection });
      Object.assign(this, { keyboard, keyboards, keyboardSelection: keyboard.name });

      keyboard.fillSettings();
      this.keyboard = keyboard;
      Keyboard.ready = true;

      // Tracks
      let tracks = localStorage.getItem("tracks");
      if (!tracks) {
        this.tracks = {};
        localStorage.setItem("tracks", "{}");
      } else this.tracks = tracks = JSON.parse(tracks);
      const trackSelEl = $("#track-select select"), selectHrEl = $("#track-select hr");
      Object.keys(this.tracks).forEach(name => {
        const el = $.load("option", "#track-select > select")[0][0];
        el.innerText = name;
        el.setAttribute("name", name);
        trackSelEl.insertBefore(el, selectHrEl)
      })

    },

    resize (reset) {
      const
        { hexGrid } = Keyboard.getScope().keyboard,
        { canvas, octaves } = this, { unit, orientation: [g, h], theta } = hexGrid,
        x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5,
        { width, height } = $("main").getBoundingClientRect(),
        r = hexGrid.r = Math.min(unit * 2, width / (Math.hypot(x, y) * octaves + 2) * 2);
      if (reset) {
        hexGrid.w = canvas.width = Math.ceil(width) * 2,
        hexGrid.h = canvas.height = Math.ceil(height) * 2;
        this.gridctx.textBaseline = "middle"
      }
      hexGrid.c = (octaves % 2) * Math.hypot(x, y) * r / 2;
      hexGrid.octLen = Math.hypot(x, y) * r;

      const tempsListEl = $("#temperament-list");
      if (tempsListEl) {
        tempsListEl.style.setProperty("--tp-display-height", `${Math.round($("#temperaments").offsetHeight)}px`);
        tempsListEl.style.setProperty("--tp-display-width", `${2 + Math.round(tempsListEl.offsetWidth)}px`)
      }
    },

    press (x, y, type, action, id) {
      id = type + "-" + id;
      const
        { keyboard } = Keyboard.getScope(),
        coord = keyboard.hexGrid.getCoord(x, y), [g, h] = coord;
      let hex, note;
      switch (action) {
        case "start": keyboard.play(g, h, id); break;
        case "move":
          if (keyboard.touches.get(id).hex.getCoord().some((v, i) => v !== coord[i])) {
            keyboard.stop(id);
            keyboard.play(g, h, id)
          }
          break;
        case "end": keyboard.stop(id)
      }
    },

    copy ({ node, text }) {
      let type, objEl;
      if (text) {
        const data = JSON.parse(text);
        ({ type } = data);
        switch (type) {
          case "harmonic": objEl = $(`[data-harm="${data.order}"] > .harm-obj`); break
          case "subharmonic": objEl = $(`[data-harm="${data.order}"] > .subharm-obj`); break
          case "interval": objEl = $(`[data-interval="${data.interval}"] > .interval-obj`); break
          case "chord": objEl = $(`.chord:has([data-intervals="${data.intervals}"])`)
        }
      } else {
        const { classList } = objEl = node;
        type = classList.contains("harm-obj") ? "harmonic" :
          classList.contains("subharm-obj") ? "subharmonic" :
          classList.contains("interval-obj") ? "interval" :
          classList.contains("chord") ? "chord" : null
      }
      const
        clipboardEl = $("#clipboard-item-select"), clipboardPeekEl = $("#clipboard-peek"),
        { keyboard } = Keyboard.getScope(), { scale, clipboard } = keyboard, { mapping } = scale;
      let
        itemEl, chord,
        data = {
          start: function (id) {
            this.classList.add("active");
            for (let iv of chord.internalIntervals) {
              const key = scale.getKey(iv.steps());
              key.setLabel(key.getLabels().findIndex(({ letter }) => letter === iv.noteSpelling.letter))
            }
            Keyboard.getScope().keyboard.hexGrid.redraw();
            chord.start("pointer-" + id)
          }.bind(clipboardPeekEl),
          stop: function (id) {
            this.classList.remove("active");
            chord.stop("pointer-" + id)
          }.bind(clipboardPeekEl)
        };
      switch (type) {
        case "harmonic": case "subharmonic":
          data.item = mapping.harmonicList.get(parseInt(objEl.parentElement.dataset.harm)).withQuality(type);
          chord = new Chord({ keyboard, mapping, type: "harmonic series", harmonics: [ data.item.order, 1 ], root: 1, isSubHarm: data.item.isSubHarm })
          break
        case "interval":
          data.item = mapping.intervalSet.getRatio(...objEl.parentElement.dataset.interval.split("/"));
          const { n, d } = data.item;
          chord = new Chord({ keyboard, mapping, type: "harmonic series", harmonics: [ n, d ], root: n < d ? n : d, isSubHarm: n < d });
          break
        case "chord":
          data.item = this.keyboard.scale.mapping.temperament
            .getChordByIntervals(JSON.parse($(".chord-intervals", objEl).dataset.intervals));
          chord = data.item
      }
      clipboard.unshift(data);
      keyboard.clipboardPeekIndex = 0;
      this.emit("clipboard-display-peek")
    },

    uncopy () {
      const { keyboard } = Keyboard.getScope(), { clipboard, clipboardPeekIndex } = keyboard;
      clipboard.splice(clipboardPeekIndex, 1);
      keyboard.clipboardPeekIndex = clipboard.length === 0 ? null :
        Math.min(clipboardPeekIndex, clipboard.length - 1);
      this.emit("clipboard-display-peek")
    },

    "clipboard-display-peek" () {
      const { clipboard, clipboardPeekIndex } = Keyboard.getScope().keyboard, data = clipboard[clipboardPeekIndex];
      $("#clipboard-peek > *")?.remove();
      if (!data) return;
      else if (Harmonic.prototype.isPrototypeOf(data.item)) {
        const
          itemEl = $.load("clipboard-item-harmonic", "#clipboard-peek")[0][0],
          [ hColourEl, hOrderEl, hSpellingEl ] = itemEl.children,
          colours = $.all(`.harmonic[data-harm="${data.item.order}"] > .hcolour`).map(el => el.value)
        if (colours.length === 1) hColourEl.style.setProperty("--colour", colours[0]);
        else {  // TODO: won't work for 15 without 3 and 5
          hColourEl.classList.add("split-colours");
          hColourEl.style.setProperty("--colour-1", colours[0]);
          hColourEl.style.setProperty("--colour-2", colours[1]);
        }
        hOrderEl.innerText = Common.ordinal(data.item.order);
        hSpellingEl.innerText = data.item.label
      } else if (Interval.prototype.isPrototypeOf(data.item)) {
        const
          itemEl = $.load("clipboard-item-interval", "#clipboard-peek")[0][0],
          [ iColourEl, ratioEl, spellingEl ] = itemEl.children, { fraction, splitDecomp } = data.item,
          colours = splitDecomp.map(side => side.findLast(([p]) => p !== 3)?.[0])
            .filter(Boolean).map(h => Keyboard.noteColours[h]);
        if (colours.length === 1) iColourEl.style.setProperty("--colour", colours[0]);
        else {
          if (colours.length === 0) ([ colours[0], colours[1] ] = [ Keyboard.noteColours.white, Keyboard.noteColours.black ]);
          iColourEl.classList.add("split-colours");
          iColourEl.style.setProperty("--colour-1", colours[0]);
          iColourEl.style.setProperty("--colour-2", colours[1]);
        }
        ratioEl.innerHTML = `<sup>${fraction[0]}</sup>â„<sub>${fraction[1]}</sub>`;
        spellingEl.innerText = data.item.noteSpelling.number
      } else if (Chord.prototype.isPrototypeOf(data.item))
        $.load("clipboard-item-chord", "#clipboard-peek")[0][0].innerText = data.item.internalIntervals.map(iv => iv.noteSpelling.letter).join(" ")
    },

    panic () {
      this.audioctx.close();
      const
        audioctx = this.audioctx = new AudioContext(),
        masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
    },

    fullscreen (state) { state ? $("body").requestFullscreen() : document.exitFullscreen() },



    // Keyboard

    "generate-keyboard" () {
      const
        { limitEl, maxErrorEl, edoEl, refNoteEl, freqBasisEl } = Keyboard,
        limit = limitEl.valueAsNumber,
        maxError = maxErrorEl.valueAsNumber,
        edo = edoEl.valueAsNumber,
        refNote = refNoteEl.valueAsNumber,
        freqBasis = freqBasisEl.valueAsNumber,
        { keyboard } = Keyboard.getScope();
      $.all(".harmonic").forEach(el => el.remove());
      
      const
        scale = new Scale({ keyboard, limit, maxError, refNote, freqBasis }), { mapping } = scale,
        { rawHarmonicList, harmonicList, primes, indexPrimes, index, intervalSet } = mapping;

      for (let [ harmonic, steps ] of rawHarmonicList) {
        const
          dec = Common.decomp(harmonic)[0],
          primeHarmonic = [ ...dec ][0][0],
          isPrime = primes.concat(indexPrimes).includes(harmonic),
          harmObj = harmonicList.get(harmonic),
          just = Math.log2(harmonic) % 1,
          labelEl = $.load("harmonic", "#mapping")[0][0],
          [ , spellingEl, inputEl, compositeStepsEl, ,
            , subSpellingEl, subStepsEl, , errorEl, colourEl ] = labelEl.children;
        labelEl.dataset.harm = harmonic;
        $.all(".nth-harmonic", labelEl).forEach(el => el.innerText = Common.ordinal(harmonic));
        spellingEl.innerText = mapping.intervalSet.getRatio(harmonic, 1).noteSpelling.roman;
        inputEl.setAttribute("value", steps);
        inputEl.setAttribute("min", Math.max(1, Math.ceil((just - maxError / 1200) * edo)));
        inputEl.setAttribute("max", Math.min(edo - 1, Math.floor((just + maxError / 1200) * edo)));
        inputEl.style.setProperty("--size", inputEl.size);
        // TODO eg hcolour when 15 in but 3, 5 out
        if (harmObj.isBasis) labelEl.classList.add("basis");
        if (isPrime) labelEl.classList.add("prime");
        else {
          compositeStepsEl.innerText = steps;
          if (dec.size === 1 && [ ...dec ][0][1] > 1) labelEl.classList.add("prime", "power"); // Not correct
        }
        subSpellingEl.innerText = mapping.intervalSet.getRatio(1, harmonic).noteSpelling.romanlow;
        subStepsEl.innerText = edo - steps;
        errorEl.innerText = ((steps / edo - just) * 1200).toFixed(2);
        if (harmObj.isBasis && primeHarmonic === 3) { // Not correct!
          colourEl.value = Keyboard.noteColours.white;
          labelEl.appendChild(colourEl.cloneNode()).value = Keyboard.noteColours.black;
        } else if (isPrime) colourEl.value = Keyboard.noteColours[harmonic] ??= Keyboard.noteColours.default;
        const
          harm = new Chord({ keyboard, mapping, type: "harmonic series", harmonics: [ harmonic, 1 ], root: 1 }),
          subharm = new Chord({ keyboard, mapping, type: "harmonic series", harmonics: [ harmonic, 1 ], root: 1, isSubHarm: true });
        $.queries({
          "input.steps": { change () { app.emit("generate-keyboard") } },
          "input.hcolour": { change () { Keyboard.setColour(primeHarmonic, this.value, this === $.all("input.hcolour", labelEl)[1]) } },
          button: {
            pointerdown (e) {
              this.setPointerCapture(e.pointerId);
              const
                isSubHarm = "isSubharm" in this.dataset,
                hsteps = isSubHarm ? edo - steps : steps,
                { keyboard } = Keyboard.getScope(), { mapping } = keyboard.scale,
                key = keyboard.scale.getKey(hsteps),
                enhi = key.getLabels().findIndex(({ interval: iv }) =>
                  Common.comp(iv[Number(isSubHarm)]) === harmonic && iv[Number(!isSubHarm)].length === 0);
              ~enhi && key.setLabel(enhi);
              keyboard.hexGrid.redraw();
              if (isSubHarm) subharm.start("pointer-" + e.pointerId);
              else harm.start("pointer-" + e.pointerId);
            },
            "pointerup lostpointercapture" (e) {
              ("isSubharm" in this.dataset ? subharm : harm).stop("pointer-" + e.pointerId);
              this.releasePointerCapture(e.pointerId)
            }
          },
          ".copyable": {
            dragstart (e) {
              e.dataTransfer.effectAllowed = "copy";
              e.dataTransfer.dropEffect = "copy";
              e.dataTransfer.setData("text/plain", JSON.stringify({
                type: this.classList.contains("harm-obj") ? "harmonic" : "subharmonic",
                order: this.parentElement.dataset.harm
              }))
            },
            ...Listeners.dragDropTouch
          }
        }, labelEl)
      }
      Object.assign(keyboard, { edo, scale, name: "Custom" });

      // Tonality diamond
      const diamondEl = $("#diamond");
      $.all(":scope > *", diamondEl).forEach(el => el.remove());
      const
        temperings = $.all(".harmonic").map(el => [ parseInt(el.dataset.harm), $("input", el).valueAsNumber ])
          .sort(([p], [q]) => Math.log2(p) % 1 > Math.log2(q) % 1),
        h = temperings.length, chords = new Map();
      diamondEl.style.setProperty("--size", 2 * h + 1);
      for (let i = 0; i <= h; i++) {
        const
          cell = $.load("interval-cell", "#diamond")[0][0],
          [ interval, note, width, button ] = $.all(":scope > *", cell);
        cell.style.gridArea = `${h + 1}/${2 * i + 1}/span 1/span 2`;
        interval.innerHTML = "<sup>1</sup>â„<sub>1</sub>";
        note.innerText = "I";
        width.innerText = button.dataset.steps = 0
        cell.dataset.interval = "1/1"
      }
      for (let i = h; i > 0; i--) for (let j = 0; j < i; j++) {
        const
          upperCell = $.load("interval-cell", "#diamond",)[0][0],
          lowerCell = $.load("interval-cell", "#diamond",)[0][0],
          [ upperInterval, upperNote, upperWidth, upperButton ] = $.all(":scope > *", upperCell),
          [ lowerInterval, lowerNote, lowerWidth, lowerButton ] = $.all(":scope > *", lowerCell),
          upperIv = intervalSet.getRatio(temperings[h - i + j][0], temperings[j - 1]?.[0] ?? 1).withOctave(0),
          lowerIv = intervalSet.getRatio(temperings[j - 1]?.[0] ?? 1, temperings[h - i + j][0]).withOctave(0),
          [nUp, dUp] = upperIv.fraction, [nLo, dLo] = lowerIv.fraction;
        upperCell.style.gridArea = `${i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        lowerCell.style.gridArea = `${2 * h + 2 - i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        upperInterval.innerHTML = `<sup>${nUp}</sup>â„<sub>${dUp}</sub>`;
        lowerInterval.innerHTML = `<sup>${nLo}</sup>â„<sub>${dLo}</sub>`;
        upperNote.innerText = upperIv.noteSpelling[upperIv.n > upperIv.d ? "roman" : "romanlow"];
        lowerNote.innerText = lowerIv.noteSpelling[lowerIv.n > lowerIv.d ? "roman" : "romanlow"];
        upperCell.dataset.interval = upperIv.fraction.join("/");
        lowerCell.dataset.interval = lowerIv.fraction.join("/");
        upperWidth.innerText = upperButton.dataset.steps = upperIv.steps();
        lowerWidth.innerText = lowerButton.dataset.steps = lowerIv.steps();
        chords.set(upperInterval, new Chord({ keyboard, mapping, type: "harmonic series", harmonics: [ nUp, dUp ], root: dUp }));
        chords.set(lowerInterval, new Chord({ keyboard, mapping, type: "harmonic series", harmonics: [ nLo, dLo ], root: nLo, isSubHarm: true }))
      }
      app.emit("resize", true);
      keyboard.hexGrid.redraw(true);

      // Interval table
      const ivTable = $("#interval-table"), ps = primes.concat(indexPrimes).sort((a, b) => a > b);
      $.all(":scope > *", ivTable).forEach(el => el.remove());
      ivTable.style.setProperty("--harms", ps.length);
      ivTable.style.setProperty("--edo", edo);
      const [ cornerEl, firstBorderEl ] = $.load("interval-th", "", ivTable)[0];
      cornerEl.classList.add("column-head", "row-head");
      $("span", cornerEl).innerText = "Steps";
      firstBorderEl.remove();
      ps.forEach((p, k) => {
        const [ el, bel ] = $.load("interval-th", "", ivTable)[0];
        el.classList.add("column-head");
        el.style.gridColumnStart = 2 * k + 2;
        $("span", el).innerText = p;
        bel.style.gridArea = `1/${2 * k + 3}/span calc(2 * var(--edo))/span 1`;
      });
      $("div:last-of-type", ivTable).remove();
      for (k = 0; k < edo; k++) {
        const [ el, bel ] = $.load("interval-th", "", ivTable)[0];
        el.classList.add("row-head");
        el.style.gridRowStart = 2 * k + 2;
        $("span", el).innerText = k;
        bel.style.gridArea = `${2 * k + 3}/1/span 1/span calc(2 * var(--harms))`;
      }
      $("div:last-of-type", ivTable).remove();
      $.all(".column-head:last-of-type, .row-head:last-of-type")
      for (let steps = 0; steps < edo; steps++) scale.getKey(steps).getLabels()
        .forEach(({ interval: iv, number, keyClass }) => {
          const
            [ n, d ] = iv.map(side => side.reduce(([big, log], [p, rad]) =>
              [big * BigInt(p) ** BigInt(rad), log + Math.log2(p) * rad], [1n, 0]))
              .reduce(([bn, ln], [bd, ld]) => {
                const oct = BigInt(Math.floor(ln - ld));
                return [oct < 0 ? bn << -oct : bn, oct > 0 ? bd << oct : bd]
              }),
            curh = keyClass.match(/\d{1,2}/g)
              ?.map(s => parseInt(s)).sort((a, b) => a < b)[0] ?? (steps ? 3 : 1);
          let td = $(`.interval-td[data-cell="${steps},${curh}"]`);
          if (!td) {
            td = $.load("interval-td", "", ivTable)[0][0];
            td.style.gridArea = steps === 0 ?
              `2/2/span 1/span ${2 * ps.length}` :
              `${2 * steps + 2}/${2 * ps.findIndex(p => p % curh === 0) + 2}`;
            td.dataset.cell = `${steps},${curh}`
          }
          const
            cell = $.load("interval-cell", "", td)[0][0],
            [ interval, note, width, button ] = $.all(":scope > *", cell);
          if (steps === 0) cell.id = "table-unison";
          interval.innerHTML = `<sup>${n}</sup>â„<sub>${d}</sub>`;
          note.innerText = number;
          width.innerText = button.dataset.steps = steps
          cell.dataset.interval = `${n}/${d}`;
          const N = Number(n), D = Number(d);
          chords.set(interval, new Chord({  // TODO use correct quality
            keyboard, mapping, type: "harmonic series", harmonics: [ N, D ],
            root: N < D ? N : D, isSubHarm: N < D
          }))
        });

      // Play interval buttons
      $.queries({
        '.interval-display button[data-steps="0"]': (hex => ({
          pointerdown (e) {
            this.setPointerCapture(e.pointerId);
            if (this.closest("#diamond"))
              $.all('.interval-display button[data-steps="0"]').forEach(el => el.parentElement.classList.add("activeEnharmonic"));
              Keyboard.getScope().keyboard.play(0, 0, "pointer-" + e.pointerId)
          },
          "pointerup lostpointercapture" (e) {
            $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
            Keyboard.getScope().keyboard.stop("pointer-" + e.pointerId);
            this.releasePointerCapture(e.pointerId)
          }
        }))(),
        '.interval-display button:not([data-steps="0"])': (chord => ({
          pointerdown (e) {
            this.setPointerCapture(e.pointerId);
            const
              { keyboard } = Keyboard.getScope(), { mapping } = keyboard.scale,
              steps = parseInt(this.dataset.steps),
              [n, d] = this.parentElement.dataset.interval.split("/").map(v => Common.non2(parseInt(v))),
              key = keyboard.scale.getKey(steps),
              enhi = key.getLabels().findIndex(({ interval: iv }) => Common.comp(iv[0]) === n && Common.comp(iv[1]) === d);
            $.all(`button[data-steps="${steps}"]`, this.closest(".interval-display"))
              .forEach(el => el.parentElement.classList.add("activeEnharmonic"));
            ~enhi && key.setLabel(enhi);
            keyboard.hexGrid.redraw();
            chords.get($(".interval-obj", this.parentElement)).start("pointer-" + e.pointerId)
          },
          "pointerup lostpointercapture" (e) {
            $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
            chords.get($(".interval-obj", this.parentElement)).stop("pointer-" + e.pointerId);
            this.releasePointerCapture(e.pointerId)
          }
        }))(),
        ".interval-display .copyable": {
          dragstart (e) {
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.dropEffect = "copy";
            e.dataTransfer.setData("text/plain", JSON.stringify({ type: "interval", interval: this.parentElement.dataset.interval }))
          },
          ...Listeners.dragDropTouch
        }
      })
    },



    // Temperaments

    "generate-temperaments" () {
      const
        { keyboard } = Keyboard.getScope(), { edo } = keyboard,
        { mapping } = keyboard.scale, ps = mapping.primes.concat(mapping.index).sort((a, b) => a > b),
        commasEl = $("#commas");
      let n, upperBound = parseInt(commasEl.dataset.upperBound);
      for (let [n1, l1, n2, l2] of mapping.takeCommas(upperBound)) {
        n = n1;
        const iv = new Interval({ keyboard, mapping, n: n1, d: n2 });
        if (Common.mod(iv.steps(), edo) === 0) {
          const
            commaEl = $.load("comma", "", commasEl)[0][0],
            [ ratioSpan, nDecompSpan, dDecompSpan, sizeSpan, spellingSpan ] = commaEl.children;
          commaEl.dataset.comma = [ n1, n2 ];
          commaEl.dataset.factors = JSON.stringify(iv.splitDecomp);
          ratioSpan.innerText = `${n1}/${n2}`;
          const t1 = Common.bigLog2(n1 & -n1), t2 = Common.bigLog2(n2 & -n2);
          nDecompSpan.innerHTML = (t1 > 0 ? [[2, t1]] : []).concat(iv.splitDecomp[0])
            .map(([p, rad]) => p + (rad > 1 ? `<sup>${rad}</sup>` : "")).join(".");
          dDecompSpan.innerHTML = (t2 > 0 ? [[2, t2]] : []).concat(iv.splitDecomp[1])
            .map(([p, rad]) => p + (rad > 1 ? `<sup>${rad}</sup>` : "")).join(".");
          sizeSpan.innerText = `${((l1 - l2) * 1200).toFixed(2)}`;
          spellingSpan.innerText = iv.noteSpelling.letter;
          $.queries({ "": { click () { app.emit("generate-chords", this) } } }, commaEl)
        }
      }
      if (n) commasEl.dataset.upperBound = (1n + n / 100n) / 100n;
      commasEl.scrollTo(0, $("#computing-commas").offsetTop - commasEl.offsetTop - commasEl.offsetHeight)
    },

    async "generate-chords" (commaEl) {
      $(".comma.active")?.classList.remove("active");
      commaEl.classList.add("active");
      $.all(".chord").forEach(el => el.remove());
      const
        [ n, d ] = commaEl.dataset.comma.split(",").map(x => parseInt(x)),
        { keyboard } = Keyboard.getScope(), { edo, scale } = keyboard, { mapping } = scale,
        tempsEl = $("#temperaments");
      $("#comma-info").innerText = n + "/" + d;

      await new Promise(requestAnimationFrame);
      tempsEl.scrollTo(0, 32767);
      $("#chords").classList.add("computing");
      await new Promise(requestAnimationFrame);
      
      // TODO urgent: move off main thread
      const chords = mapping.chords(new Interval({ keyboard, mapping, n, d }));
      $("#chords").classList.remove("computing");
      for (let chord of chords) {
        const chordEl = $.load("chord", "#chords")[0][0], chordIvsEl = $(".chord-intervals", chordEl);
        chordIvsEl.dataset.intervals = JSON.stringify(chord.intervals.map(({ fraction }) => fraction));

        app.emit("display-chord", chord, chordEl);
        $.queries({
          "button.play-chord": (id => ({
            pointerdown (e) {
              this.setPointerCapture(e.pointerId);
              for (let iv of chord.internalIntervals) {
                const key = scale.getKey(iv.steps());
                key.setLabel(key.getLabels().findIndex(({ letter }) => letter === iv.noteSpelling.letter))
              }
              keyboard.hexGrid.redraw();
              if ($(".switch input:checked")) id = setInterval(() => {
                chord.stop("pointer-" + e.pointerId);
                chord.inversion = (chord.inversion + 1) % chord.adicity;
                app.emit("display-chord", chord, chordEl);
                setTimeout(() => chord.start("pointer-" + e.pointerId), 20)
              }, 667);
              chord.start("pointer-" + e.pointerId)
            },
            "pointerup lostpointercapture" (e) {
              clearInterval(id);
              chord.stop("pointer-" + e.pointerId);
              this.releasePointerCapture(e.pointerId)
            }
          }))(),
          "button.inversion": { click () {
            const inv = chord.inversion = chordEl.dataset.inv = ++chordEl.dataset.inv % chord.adicity;
            chordIvsEl.dataset.intervals = JSON.stringify(chord.intervals.map(({ fraction }) => fraction));
            app.emit("display-chord", chord, chordEl)
          } },
          button: { "touchstart touchmove touchend" (e) { e.stopPropagation() } },
          "": {
            dragstart (e) {
              e.dataTransfer.effectAllowed = "copy";
              e.dataTransfer.setData("text/plain", JSON.stringify({
                type: "chord", intervals: $(".chord-intervals", this).dataset.intervals
              }))
            },
            ...Listeners.dragDropTouch
          }
        }, chordEl)
      }
      tempsEl.scrollTo(0, $("fieldset:has(#chords)").offsetTop - tempsEl.offsetTop)
    },

    "display-chord" (chord, chordEl) {
      const
        { keyboard } = Keyboard.getScope(), { edo } = keyboard, { mapping } = keyboard.scale,
        [ chIntervalsEl, chPitchesEl, chSpellingEl, chControlsEl ] = chordEl.children,
        [ chIvHarmonicEl, chIvStepsEl ] = chIntervalsEl.children,
        [ chPcHarmonicEl, chPcStepsEl ] = chPitchesEl.children,
        [ chIsSymmetricEl, chNextInvBtn, chPlayChordBtn ] = chControlsEl.children;
      $.all(".chord-edo", chordEl).forEach(el => el.innerText = edo);
      chIvHarmonicEl.innerHTML = chord.intervals.map(({ fraction }) => `<sup>${fraction[0]}</sup>â„<sub>${fraction[1]}</sub>`).join(" ");
      chIvStepsEl.innerText = chord.intervals.map(iv => iv.steps()).join(" ");
      chPcHarmonicEl.innerHTML = chord.internalIntervals.map(({ fraction }) => `<sup>${fraction[0]}</sup>â„<sub>${fraction[1]}</sub>`).join(" â€“ ");
      chPcStepsEl.innerText = `${chord.internalIntervals.map(iv => iv.steps()).join("-")}-${edo}`;
      chSpellingEl.innerText = chord.internalIntervals.map(iv => iv.noteSpelling.letter).join(" â€“ ");
    },



    // Track editor

    "track-name-update" (name) {
      const { tracks, trackSelection } = this, trackSelEl = $("#track-select > select");
      if (name === "New" || name in tracks && trackSelEl.value !== name) {
        $("#track-name-field").classList.add("invalid");
        return
      }
      $("#track-file").classList.add("saved");
      delete this.tracks[trackSelection];
      this.tracks[name] = $("#track-edit").value;
      this.trackSelection = name;
      $("#track-name-text").innerText = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name").classList.remove("editingTrackName");
      $(`#track-select option[name='${trackSelection}']`)?.remove();
      const el = $.load("option", "#track-select > select")[0][0];
      el.innerText = name;
      el.setAttribute("name", name);
      trackSelEl.insertBefore(el, $("#track-select hr"));
      el.selected = true;
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
    },

    "track-editor" (name) {
      const { tracks } = this;
      if (!name) {
        const
          nth = Object.keys(tracks)
            .map(tn => tn.match(/^Untitled( [1-9]\d*)?$/)?.slice(1).map(v => v ? parseInt(v) : 0))
            .flat().sort().findLastIndex((k, i) => k === i) + 1;
        name = "Untitled" + (nth ? " " + nth : "");
        $("#track-edit").value = "";
        $("#track-file").classList.remove("saved")
      } else {
        $("#track-edit").value = tracks[name];
        $("#track-file").classList.add("saved")
      }
      this.trackSelection = name;
      $("#track-name-field").value = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name-text").innerText = name;
      $("#track-name").classList.remove("editingTrackName");
    },

    "track-save" () {
      $("#track-file").classList.add("saved");
      $("#track-savestate").classList.add("saving");
      clearInterval(this.menuState[1].saveDebounce);
      this.menuState[1].saveDebounce = setTimeout(() => {
        localStorage.setItem("tracks", JSON.stringify(this.tracks));
        $("#track-savestate").classList.remove("saving")
      }, 500)
      const trackSelection = $("#track-name-field").value;
      let el;
      if (!(trackSelection in this.tracks)) {
        el = $.load("option", "#track-select > select")[0][0];
        el.innerText = trackSelection;
        el.setAttribute("name", trackSelection);
        $("#track-select select").insertBefore(el, $("#track-select hr"));
        el.selected = true
      } else el = $("#track-select > select").namedItem(trackSelection);
      this.trackSelection = $("#track-name-field").value;
      this.tracks[this.trackSelection] = $("#track-edit").value;
      el.innerText = trackSelection;
      el.setAttribute("name", trackSelection)
    },

    "track-delete" (response) {
      $("#delete-dialog").close(response);
      if (response === "Cancel") return;
      const { tracks, trackSelection } = this;
      delete this.tracks[trackSelection];
      this.trackSelection = null;
      $(`#track-select option[name='${trackSelection}']`).remove();
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
      this.emit("menu-cancel")
    },



    // Menu

    "menu-select" (which, ...data) {
      const
        breadcrumbText = {
          "keyboard-settings": "Keyboard â›­",
          "temperaments": "Temperament ğŸ’¡",
          "track-editor": "Track âœ"
        },
        prevMenu = this.menuState;
      this.emit("menu-cancel");
      this.menuState = which.concat([null]);
      const menuLeaf = which.at(-1);
      $("body").classList.add("menuActive");
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $("#" + menuLeaf).classList.add("activeMenu");
      $.all("#breadcrumb-text > *").forEach(el => el.remove());
      which.forEach((level, i) => {
        const levelEl = $.load("breadcrumb-level", "#breadcrumb-text")[0][0];
        levelEl.innerText = breadcrumbText[level];
        if (i < which.length - 1) levelEl.dataset.menu = which.toSpliced(i + 1)
      });
      $.queries({ "#breadcrumb-text > :nth-last-child(n+2)": { click () {
        app.emit("menu-select", this.dataset.menu.split(","))
      } } });
      let cancelEl, applyEl;
      switch (menuLeaf) {
        case "keyboard-settings":
          cancelEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(cancelEl, { innerText: "Cancel", id: "keyboard-settings-cancel" });
          applyEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(applyEl, { innerText: "Apply", id: "keyboard-settings-apply" });
          $.queries({
            "#keyboard-settings-cancel": { click () { app.emit("menu-cancel") } },
            "#keyboard-settings-apply": { click () {
              app.keyboard = app.menuState[1].keyboard;
              app.keyboardSelection = app.keyboard.load().keyboardSelection;
              app.emit("menu-cancel")
            } }
          });
          this.menuState[1] = { keyboard: this.keyboard };
          this.keyboard.fillSettings();
          this.emit("generate-keyboard");
          break;
        case "temperaments":
          $("#commas").dataset.upperBound = 100;
          $.all("#commas > .comma").forEach(el => el.remove());
          $.all("#chords > .chord").forEach(el => el.remove());
          this.menuState[1] = { keyboard: this.keyboard };
          // this.menuState[1] = prevMenu[0] === "keyboard-settings" ? prevMenu[1] : { keyboard: this.keyboard };
          this.emit("resize", true);
          this.emit("generate-temperaments")
          break;
        case "track-editor":
          $("#track-controls").classList.add("activeControls");
          $("#track-select > select").namedItem(data[0] ?? "New").selected = true;
          closeEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(closeEl, { innerText: "Close", id: "track-editor-close" });
          $.queries({ "#track-editor-close": {
            click () { app.emit("menu-cancel") }
          } });
          this.menuState[1] = { saveDebounce: null };
          this.emit("track-editor", ...data)
      }
    },
    "menu-cancel" () {
      $("body").classList.remove("menuActive")
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $.all("#menu-actions > *").forEach(el => el.remove());
      switch(this.menuState[0]) {
        case "track-editor":
          $("#track-controls").classList.remove("activeControls");
          $("#track-select > select").selectedIndex = 0
      }
      this.menuState = [];
      this.emit("resize", true);
      Keyboard.getScope().keyboard.hexGrid.redraw(true)
    },

    "volume-change" (value) { this.masterVolume.gain.value = Common.scaleVolume(value) }

  }
});



// Elements

$.queries({

  nav: { touchstart (e) { if ($.all("#refresh, #panic, #fullscreen, #volume > input").every(el => e.target !== el)) this.focus() } },
  form: { submit (e) { e.preventDefault() } },
  "#volume > input": { change () { app.emit("volume-change", this.valueAsNumber) } },
  "#octaves > input": { change () {
    localStorage.setItem("octaves", app.octaves = this.valueAsNumber);
    app.emit("resize", true);
    Keyboard.getScope().keyboard.hexGrid.redraw(true)
  } },
  "#refresh": { click () {
    app.emit("resize", true);
    const { keyboard } = Keyboard.getScope();
    keyboard.refresh()
  } },
  "#panic": { click () { app.emit("panic") } },
  "#fullscreen": { click () { app.emit("fullscreen", this.classList.toggle("active")) } },

  "#keyboard-settings-button": { click () {
    if (app.menuState[0] === "keyboard-settings") app.emit("menu-cancel"); 
    else app.emit("menu-select", [ "keyboard-settings" ])
  } },
  "#keyboard-settings": {
    scroll ({ SCROLL_PAGE_DOWN }) {  // TODO: Allow simultaneous x and y scrolling
      if (!$("#table-choice > input").checked) return;
      const
        { scrollTop } = this, el = $("#ivtable-wrapper"), { scrollLeft } = el,
        { offsetTop, offsetHeight } = $("#interval-view"), { clientHeight } = $("#keyboard-settings"),
        { offsetTop: y, offsetLeft: x, offsetHeight: height } = $("#keyboard-settings > form"),
        offset = offsetTop + offsetHeight - y + x;
      if (Common.between(offset, height - clientHeight + 2 * x, scrollTop)) el.scrollTo(scrollLeft, scrollTop - offset);
      else if (scrollTop < offset) el.scrollTo(scrollLeft, 0);
      else el.scrollTo(scrollLeft, SCROLL_PAGE_DOWN)
    }
  },
  "#keyboard-settings > form": { change (e) { Keyboard.selectEl.value = "Custom" } },
  "#keyboard-select > select": { change () {
    app.keyboardSelection = app.keyboard.load().keyboardSelection;

    $("#commas").dataset.upperBound = 100;
    $.all("#commas > .comma").forEach(el => el.remove());
    $.all("#chords > .chord").forEach(el => el.remove())
  } },
  "#edo > input": { change () {
    const
      { refNoteEl, maxErrorEl, scaleOutputEl } = Keyboard,
      edo = this.valueAsNumber;
    refNoteEl.value = Math.round(Math.log2(5 / 3) * edo); // C-A = 5/3
    scaleOutputEl.value = `One step of ${edo}edo = ${(1200 / edo).toFixed(2)}Â¢`;
    maxErrorEl.value = Math.floor(400 / edo);
    Keyboard.getScope().keyboard.update();
    app.emit("generate-keyboard");
    this.focus()
  } },
  ":is(#gstep, #hstep) > input": { change () {
    const { keyboard } = Keyboard.getScope(), { orientationSelectEl } = Keyboard;
    keyboard.update();
    if (orientationSelectEl.children.length) {
      app.emit("resize", true);
      keyboard.hexGrid.redraw(true);
      orientationSelectEl.showPicker();
    }
  } },
  "#orientation > select": { change () {
    const { hexGrid } = Keyboard.getScope().keyboard;
    hexGrid.setOrientation(...JSON.parse(`[${this.value}]`));
    app.emit("resize", true);
    hexGrid.redraw(true);
    this.focus()
  } },
  "#unit > input": { change () {
    const { hexGrid } = Keyboard.getScope().keyboard;
    hexGrid.unit = this.valueAsNumber;
    app.emit("resize", true);
    hexGrid.redraw(true)
  } },
  ":is(#limit, #maxError) > input": { change () { app.emit("generate-keyboard") } },

  "#generate-temperaments": { click () { app.emit("menu-select", [ "temperaments" ]) } },

  "#clipboard-item-select": {
    "dragenter dragover" (e) {
      e.preventDefault();
      this.classList.add("active")
    },
    dragleave (e) { this.classList.remove("active") },
    drop (e) {
      e.stopPropagation();
      this.classList.remove("active");
      const text = e.dataTransfer.getData('text/plain');
      if (text !== "self") app.emit("copy", { text })
    },
    dragstart (e) { e.dataTransfer.setData("text/plain", "self") },
    dragend ({ x, y }) {
      if (!document.elementsFromPoint(x, y).includes(this)) app.emit("uncopy")
    }
  },
  "#clipboard-peek": {
    ...((x, prevX, y, threshhold, phase) => ({
      pointerdown ({ pointerId, ctrlKey, pageX, pageY }) {
        this.setPointerCapture(pointerId);
        if (!this.firstChild) return;
        if (ctrlKey) return app.emit("uncopy");
        const
          { height } = this.getBoundingClientRect(),
          { clipboard, clipboardPeekIndex } = Keyboard.getScope().keyboard,
          data = clipboard[clipboardPeekIndex];
        x = pageX;
        y = pageY;
        threshhold = height;
        phase = 0;
        data.start(pointerId)
      },
      pointermove ({ clientX, pageX, pageY, pointerId }) {
        if (this.children.length === 0) return;
        const { keyboard } = Keyboard.getScope(), { clipboard, clipboardPeekIndex } = keyboard;
        if (phase === 0 && Math.hypot(pageX - x, pageY - y) > threshhold) {
          phase = 1 + (Math.abs(pageX - x) < Math.abs(pageY - y));
          prevX = pageX;
          if (Math.abs(pageX - x) < Math.abs(pageY - y)) {
            clipboard[clipboardPeekIndex].stop(pointerId);
            app.emit("uncopy")
          }
        } else if (phase === 1) {
          keyboard.cycle("clipboard", (-prevX + (prevX = pageX)) * 4);
          if (keyboard.clipboardPeekIndex !== clipboardPeekIndex) {
            clipboard[clipboardPeekIndex].stop(pointerId);
            clipboard[keyboard.clipboardPeekIndex].start(pointerId)
          }
        }
      },
      "pointerup lostpointercapture" ({ pointerId }) {
        const { clipboard, clipboardPeekIndex } = Keyboard.getScope().keyboard;
        clipboard[clipboardPeekIndex]?.stop(pointerId);
        this.releasePointerCapture(pointerId)
      }
    }))()
  },

  "#track-select > select": { change () {
    if (this.value === "None") app.emit("menu-cancel");
    else app.emit("menu-select", [ "track-editor" ], ...(this.value === "New" ? [] : [ this.value ]))
  } },
  "#track-name-text": { click () {
    $("#track-name").classList.add("editingTrackName");
    $("#track-name-field").focus()
  } },
  "#track-name-field": { "keyup blur" (e) {
    if (e.type === "blur" || e.key === "Enter") app.emit("track-name-update", this.value = this.value.trim())
  } },
  "#track-delete": { click () {
    $("#delete-track-name").innerText = app.trackSelection;
    $("#delete-dialog").showModal()
  } },
  "#delete-dialog button": { click () { app.emit("track-delete", this.dataset.action) } },
  "#track-edit": { keyup () { if (this.value !== app.tracks[app.trackSelection]) app.emit("track-save") } },
  "#toggle-accidentals": { click () { $("#insert-accidental").classList.toggle("activeSelect") } },
  "#insert-accidental > *": { click () {
    const { value } = $("#track-edit"), editorEl = $("#track-edit"), selStart = editorEl.selectionStart;
    $("#track-edit").value = value.slice(0, selStart) + this.innerText + value.slice(editorEl.selectionEnd)
    if ($("#track-edit").value !== app.tracks[app.trackSelection]) app.emit("track-save")
    editorEl.setSelectionRange(selStart + 1, selStart + 1);
    editorEl.focus()
  } }

})



  </script>
  <noscript>Only viewable with JavaScript enabled.</noscript>
</body>
</html>