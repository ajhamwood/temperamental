<!doctype html>
<html>
<head>
  <title>Temperamental ⁂ Microtonal music explorer</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='music, xenharmony, xenrhythm'>
  <meta name='description' content='Web app for composing, playing, and noodling on microtonal music.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
@font-face {
  font-family: HEJI2;
  src: url('fonts/HEJI2Text.woff2') format('woff2'),
       url('fonts/HEJI2Text.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
  unicode-range: U+E260-E266, U+E2C0-E2FA;
  size-adjust: 150%;
  ascent-override: 0%;
  descent-override: 0% }
@font-face {
  font-family: ArbutusSlab;
  src: url('fonts/ArbutusSlab-Regular.woff2') format('woff2'),
       url('fonts/ArbutusSlab-Regular.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap }

@media (min-aspect-ratio: 1) {
  body.menuActive { grid: "nav nav" auto "menu main" 1fr / min-content 1fr }
  menu { max-width: 50dvw }
  #track-editor > form > textarea {
    width: 20em;
    min-width: 10em }
  #diamond-wrapper, #mapping { max-width: calc(50dvw - 3.5em - 2px) } }
@media (max-aspect-ratio: 1) {
  body.menuActive { grid: "nav" auto "menu" min-content "main" auto / 100dvw }
  menu { max-height: calc(50dvh - 4.9em) }
  #track-editor > form > textarea {
    width: 100% !important;
    resize: vertical }
  #diamond-wrapper, #mapping { max-width: calc(100dvw - 3.5em - 2px) } }

html, body { height: 100dvh }
body, button, select, input, textarea { font-family: HEJI2, ArbutusSlab }
body {
  margin: 0;
  background-color: #222;
  color: #ddd;
  display: grid;
  grid: "nav" auto "main" 1fr / 100dvw;
  overflow: hidden;
  touch-action: none }
  nav {
    grid-area: nav;
    display: flex;
    flex-flow: column }
    nav > * {
      padding: .5em;
      flex-flow: row;
      justify-content: space-between }
    #controls { display: flex }
      #controls > :nth-child(2) { flex: 1 }
        #controls > :nth-last-child(n+2),
        #track-controls > * { margin-right: .5em }
      #volume > * { vertical-align: middle }
      #track-controls { display: none }
      #track-controls.activeControls { display: flex }
        #track-play:not(.trackPlaying)::before { content: "Play ▶" }
        #track-play.trackPlaying::before { content: "Pause ⏸" }
    nav:focus-within:not(:has(:is(#refresh, #panic, #volume > input):focus)) > #dropdown,
    body.menuActive #dropdown { display: flex }
    #dropdown {
      display: none;
      background-color: #000 }
      #dropdown > :nth-last-child(n+2) { margin-right: 2em }
        #dropdown > * > * { vertical-align: middle }
      #track-select { flex: 1 }
  menu {
    padding: 0;
    margin: 0;
    min-height: 0;
    display: none }
  body.menuActive > menu { display: block }
    menu > li { padding: .5em }
    menu > li:not(#breadcrumbs) {
      overflow-y: scroll;
      height: calc(100% - 3.4em);
      display: none }
    menu > li.activeMenu { display: list-item !important }
    #breadcrumbs {
      background-color: #ddd;
      color: #222;
      display: flex;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
      #breadcrumb-text { font-size: small }
      #breadcrumb-text::before { content: "// " }
        #menu-actions > :nth-last-child(n+2) { margin-right: .5em }
    form {
      display: flex;
      flex-flow: row wrap;
      gap: 0 .6em }
      #track-editor > form > * { width: 100% }
      fieldset {
        display: flex;
        flex-flow: column;
        align-items: start;
        flex: auto }
        fieldset > * { margin: .3em }
          input[type="number"] { width: 3.5em }
          :is(#scale, #mapping) > * {
            display: block;
            margin-left: 1em }
          #mapping { display: grid }
            .harmonic {
              grid-template-columns: subgrid;
              display: grid !important;
              grid-column: span 9;
              gap: .3em }
              .harmonic > :not(input) { text-align: end }
              .harmonic:not(.prime) > input, .harmonic.prime > span.steps,
              .harmonic.prime.power > input.hcolour  { display: none }
              #error::after { content: "¢" }
          #diamond-wrapper, #mapping { overflow-x: scroll }
          #diamond {
            display: grid;
            grid-template-columns: 1fr repeat(var(--size), auto);
            grid-template-rows: repeat(var(--size), 2em);
            justify-items: end;
            width: max-content }
            .diamond-cell.activeEnharmonic { border-bottom: 1px solid }
        #track-file {
          display: flex;
          flex-flow: row;
          margin-bottom: .5em }
          #track-file > :nth-last-child(n+2) { margin-right: .5em }
          #track-name { flex: 1 }
          #track-name > * {
            display: none;
            vertical-align: middle }
          #track-name-text { cursor: text }
          #track-name-text:empty::before {
            color: #666;
            content: "..." }
          #track-name:not(.editingTrackName) > #track-name-text,
          #track-name.editingTrackName > input { display: inline }
          #track-name-field.invalid { outline: 1px solid red }
          #track-file:not(.saved) > :is(#track-savestate, #track-delete) { display: none }
          #track-savestate.saving::before {
            content: "...";
            color: orange }
          #track-savestate:not(.saving)::before {
            content: "✓";
            color: lawngreen }
        #track-edit {
          max-width: calc(100dvw - 1.5em);
          height: 10em }
        #insert-accidental {
          display: none;
          margin-top: .5em;
          grid-template-columns: repeat(auto-fill, 3em);
          text-align: center;
          line-height: 3em;
          gap: .5em;
          justify-content: space-evenly }
        #insert-accidental.activeSelect {
          display: grid;
          height: 6.5em;
          overflow: scroll }
          #insert-accidental > * {
            display: inline-block;
            background-color: #fff2;
            border-radius: .5em;
            cursor: pointer }
  main {
    overflow: hidden;
    background-blend-mode: soft-light;
    background-size: cover;
    background-position-y: center }
    main.hover { cursor: pointer }
    canvas {
      transform: scale(.5);
      transform-origin: 0 0 }
  dialog { padding: 1em 0 }
    #dialog-prompt { padding: 0 1em }
    dialog > form { justify-content: space-evenly }
  </style>
</head>
<body>
  <nav tabindex="0">
    <div id="dropdown">
      <div id="keyboard-select">
        <span>Keyboard</span>
        <select></select>
        <button id="keyboard-settings-button" type="button">⚙️</button>
      </div>
      <div id="track-select">
        <span>Track</span>
        <select>
          <option name="None">None</option>
          <hr>
          <option name="New">New</option>
        </select>
      </div>
      <button class="info" type="button">ⓘ</button>
    </div>
    <div id="controls">
      <div id="volume">
        <span>Volume</span>
        <input type="range" min="0" max="100" step="1">
      </div>
      <div id="octaves">
        <span>Octaves</span>
        <input type="number" value="2" min="1" max="5" steps="1">
      </div>
      <div id="track-controls">
        <button id="track-loop" type="button">Loop</button>
        <button id="track-play" type="button"></button>
      </div>
      <button id="refresh" type="button">Refresh</button>
      <button id="panic" type="button">Panic</button>
    </div>
  </nav>
  <menu>
    <li id="breadcrumbs">
      <span id="breadcrumb-text"></span>
      <div id="menu-actions"></div>
    </li>
    <li id="keyboard-settings">
      <form>
        <fieldset>
          <legend>Shape</legend>
          <label id="gstep">Horizontal steps: <input type="number" min="0" step="1"></label>
          <label id="hstep">Diagonal steps: <input type="number" min="0" step="1"></label>
          <label id="orientation">Orientation:
            <select>
              <option value="">Choose</option>
            </select>
          </label>
          <label id="unit">Key size: <input type="number" min="5" step="1"> px</label>
        </fieldset>
        <fieldset>
          <legend>Note</legend>
          <label id="refNote">Tuning root note: <input type="number" min="0" step="1"></label>
          <label id="freqBasis">Tuning root frequency: <input type="number" min="10" max="40000"> Hz</label>
          <div id="scale">Scale:
            <label id="edo">Divisions of octave: <input type="number" min="1" step="1" max="270"></label>
            <output></output>
          </div>
        </fieldset>
        <fieldset>
          <legend>Harmonic mapping</legend>
          <label id="limit">Harmonic limit: <input type="number" value="9" min="3" max="51" step="2"></label>
          <label id="maxerror">Maximum error: <input type="number" value="30" min="0" max="100"> ¢</label>
          <div id="mapping"></div>
          <div>Tonality diamond:</div>
          <div id="diamond-wrapper"><div id="diamond"></div></div>
        </fieldset>
        <fieldset>
          <legend>Waveform</legend>
          <label id="instrument">Output:
            <select>
              <option value="osc">Local</option>
              <option value="midi">MIDI</option>
            </select>
          </label>
          <label id="instrument-option">
            <span>Oscillator</span>
            <select>
              <option value="custom">Custom</option>
            </select>
            <button type="button">Choose</button>
          </label>
        </fieldset>
      </form>
    </li>
    <li id="track-editor">
      <form>
        <div id="track-file">
          <div id="track-name">
            <span id="track-name-text"></span>
            <input id="track-name-field" type="text">
          </div>
          <span id="track-savestate"></span>
          <button id="toggle-accidentals" type="button"></button>
          <button class="info" type="button">ⓘ</button>
          <button id="track-delete" type="button">✖</button>
        </div>
        <textarea id="track-edit"></textarea>
        <div id="insert-accidental">
          <div></div><div></div><div></div><div></div><div></div><div></div><div></div>
          <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>
        </div>
      </form>
    </li>
  </menu>
  <main>
    <canvas id="hex"></canvas>
  </main>
  <dialog id="delete-dialog">
    <div id="dialog-prompt">Delete track "<span id="delete-track-name"></span>"?</div>
    <form method="dialog">
      <button type="button" data-action="Cancel">Cancel</button>
      <button type="button" data-action="Delete">Delete</button>
    </form>
  </dialog>
  <template id="menu-action">
    <button type="button"></button>
  </template>
  <template id="option">
    <option></option>
  </template>
  <template id="harmonic">
    <label class="harmonic">
      <span id="nth-harmonic"></span> harmonic: <input class="steps" type="number" step="1"><span class="steps"></span> steps, <span id="error"></span> error
      <button type="button">▶</button>
      <input class="hcolour" type="color">
    </label>
  </template>
  <template id="diamond-cell">
    <div class="diamond-cell">
      <span></span> (<span></span>, <span></span> steps) <button type="button">▶</button>
    </div>
  </template>
  <script src="js/machine.js"></script>
  <script>

//Utils

const primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 ],

      clamp = (min, max, val) => (max >= min && Number(val) === val) ? Math.max(min, Math.min(max, val)) : undefined,
      lerp = (a, b, t) => a * (1 - t) + b * t,
      between = (min, max, val) => val <= max && val >= min,
      mod = (n, m) => ((n % m) + m) % m,
      gcd = (a, b) => !b ? a : gcd(b, a % b),
      non2 = h => h / (h & (~(h - 1))),

      group = (ar, cmp = (a, b) => a === b) => ar.reduce((a, v) => {
        const i = a.findIndex(vs => cmp(vs[0], v));
        return ~i ? a.with(i, a[i].concat([v])) : a.concat([[v]])
      }, []),
      decomp = (...iv) => iv.map(r => {
        let ivh = non2(r), res = [], i = 1;
        while (ivh !== 1) {
          const p = primes[i];
          if (gcd(ivh, p) === 1) i++;
          else { res.push(p); ivh /= p }
        }
        return group(res).map(ar => [ar[0], ar.length])
      }),
      comp = (...iv) => iv.map(ar => ar.reduce((n, [p, rad]) => n * p ** rad, 1)),

      ordinal = (() => {
        const rule = new Intl.PluralRules("en-AU", { type: "ordinal" }),
              suf = new Map([ ["one", "st"], ["two", "nd"], ["few", "rd"], ["other", "th"] ]);
        return n => `${n}${suf.get(rule.select(n))}`
      })(),
      contrast = hc => {
        if (!hc.match(/\p{Hex_Digit}{6}/ug)) return null;
        const [r, g, b] = hc.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
        return r * .299 + g * .587 + b * .114 >= 128 ? "#222222" : "#dddddd"
      },
      colourMix = (hc1, hc2, t) => {
        if (![hc1, hc2].every(hc => hc.match(/\p{Hex_Digit}{6}/ug))) return null;
        const [r1, g1, b1] = hc1.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
        const [r2, g2, b2] = hc2.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
        return "#" + [[r1, r2], [g1, g2], [b1, b2]].reduce((a, [l, r]) => a + Math.round(lerp(l, r, t)).toString(16), "")
      },
      scaleVolume = value => value && 10 ** (2 * (value / 100 - 1)),

      noteFromFactors = (() => {
        const pythag = "FCGDAEB".split("").reduce((acc, key, i) => ({ ...acc, [i - 1]: key }), {}),
              hejiRatios = {
                5: [[[3, 4]], [[5, 1]]],
                7: [[], [[3, 2], [7, 1]]],
                11: [[[3, 1], [11, 1]], []],
                13: [[[3, 3]], [[13, 1]]],
                17: [[[3, 7]], [[17, 1]]],
                19: [[[3, 3], [19, 1]], []],
                23: [[[23, 1]], [[3, 6]]],
                29: [[[3, 2], [29, 1]], []],
                31: [[], [[31, 1]]],
                37: [[[37, 1]], [[3, 2]]],
                41: [[[41, 1]], [[3, 4]]],
                43: [[[3, 1], [43, 1]], []],
                47: [[47, 1], [[3, 6]]]
              };
        return factors => {
          let accid = {};
          factors = structuredClone(factors);

          // Factorise out commas
          structuredClone(factors).forEach((d, i) => {
            d.forEach(([p, rad]) => {
              if (p === 3) return;
              const tone = hejiRatios[p].findIndex(side => ~side.findIndex(([q]) => p === q));
              accid[p] = (1 - 2 * (i ^ tone)) * rad;
              hejiRatios[p].forEach((side, j) => side.forEach(([q, qrad]) => {
                const targetSide = i ^ j ^ !tone, k = factors[targetSide].findIndex(([r]) => q === r);
                ~k ? (factors[targetSide][k][1] += qrad * rad) : factors[targetSide].push([q, qrad * rad])
              }))
            })
          });

          // Normalise to Pythagorean key
          factors[1].forEach(([p, rad], i, dc1) => {
            const j = factors[0].findIndex(([q]) => p === q);
            if (!~j) return;
            const qrad = factors[0][j][1];
            if (rad > qrad) factors[1][i][1] -= qrad;
            else factors[1][i] = [];
            if (rad < qrad) factors[0][j][1] -= rad;
            else factors[0].splice(j, 1);
          });
          factors[1] = factors[1].filter(ar => ar.length);

          // Build string
          const tone = factors.findIndex(d => d.length),
                fifths = (1 - 2 * tone) * (~tone ? factors[tone][0][1] : 0),
                sharps = Math.floor((fifths + 1) / 7);
          let acstring = "", pref5 = () => "", prefNo5 = "";
          if (sharps < -2) {
            pref5 = n => ["", String.fromCodePoint(0xe2c1 + n), String.fromCodePoint(0xe2c0 + n)][(sharps === -3) - sharps % 3];
            prefNo5 = ["", String.fromCodePoint(0xe260), String.fromCodePoint(0xe264)][-sharps % 3];
            acstring = sharps === -3 && (5 in accid) ? String.fromCodePoint(0xe264) : String.fromCodePoint(0xe266).repeat(Math.floor(-sharps / 3))
          } else if (sharps > 2) {
            pref5 = n => sharps % 2 ? String.fromCodePoint(0xe2c3 + n) : String.fromCodePoint(0xe2c4 + n);
            prefNo5 = sharps % 2 ? String.fromCodePoint(0xe265) : String.fromCodePoint(0xe263).repeat(2);
            acstring = String.fromCodePoint(0xe263).repeat(Math.floor((sharps - 1) / 2) - !(5 in accid))
          } else {
            pref5 = n => String.fromCodePoint(0xe2c0 + n + (sharps + 2) % 5);
            prefNo5 = sharps === 0 ? "" : String.fromCodePoint(0xe260 + (sharps + 6) % 5)
          }
          if (5 in accid) {
            const arr = accid[5];
            if (Math.abs(arr) <= 3) {
              const arrowsOffset = 5 * (arr > 0 ? 2 * arr - 1 : -2 - 2 * arr);
              acstring += pref5(arrowsOffset);
            } else {
              const arrowsOffset = 5 * (arr > 0 ? 2 * (arr % 3) - 1 : 2 * (-arr % 3) - 2);
              acstring += (arrowsOffset < 0 ? "" : pref5(arrowsOffset)) + String.fromCodePoint(0xe2d6 + 5 * (arr > 0)).repeat(Math.floor(Math.abs(arr) / 3))
            }
          } else acstring = prefNo5 + acstring;
          if (7 in accid) {
            const sep = accid[7];
            acstring += String.fromCodePoint(0xe2e0 + (sep > 0)).repeat(Math.floor((Math.abs(sep) - 1) / 2)) + 
              String.fromCodePoint(0xe2de + (sep > 0) + 2 * Math.abs((sep + 1) % 2));
          }
          Object.keys(hejiRatios).slice(2).forEach((p, i) => acstring += accid[p] > 0 ?
            String.fromCodePoint((i < 7 ? 0xe2e3 : 0xee41) + 2 * i).repeat(accid[p]) :
            String.fromCodePoint((i < 7 ? 0xe2e2 : 0xee40) + 2 * i).repeat(-accid[p]));
          return {
            accid: { "3": fifths, ...accid },
            string: pythag[(((fifths + 1) % 7 + 7) % 7) - 1] + acstring
          };
        }
      })();

class HexButton {
  #g; #h; #grid; #osc; #volume; #noteClass; #label; isGhost

  constructor (g, h, grid, isGhost = false) {
    this.#g = g;
    this.#h = h;
    this.#grid = grid;
    this.isGhost = isGhost
  }

  static vertices (g, h, grid) {
    const { r, w, h: ht, c } = grid, x = w / 2, y = ht / 2, k = .5 * Math.sqrt(3),
          origin = [
            [ x, y - r ], [ x - r * k, y - r / 2 ], [ x - r * k, y + r / 2 ],
            [ x, y + r ], [ x + r * k, y + r / 2 ], [ x + r * k, y - r / 2 ]
          ];
    return origin.map(([ a, b ]) => {
      const [ rx, ry ] = grid.rotate(
              Math.floor(a + r * k * (h + 2 * g)),
              Math.floor(b + 1.5 * r * h)
            );
      return [ rx - c, ry ]
    })
  }
  static centre (g, h, grid) {
    const { r, w: width, h: height, c } = grid, k = .5 * Math.sqrt(3),
          [ rx, ry ] = grid.rotate(
            Math.floor(width / 2 + r * k * (h + 2 * g)),
            Math.floor(height / 2 + 1.5 * r * h)
          );
    return [ rx - c, ry ]
  }

  vertices () { return HexButton.vertices(this.#g, this.#h, this.#grid) }
  centre () { return HexButton.centre(this.#g, this.#h, this.#grid) }

  neighbours () {
    const g = this.#g, h = this.#h;
    return [
      [ g - 1, h ], [ g, h - 1 ], [ g + 1, h - 1 ],
      [ g + 1, h ], [ g, h + 1 ], [ g - 1, h + 1 ]
    ]
  }

  getCoord () { return [ this.#g, this.#h ] }
  getNoteClass () { return this.#noteClass }

  setNoteClass (noteClass) { this.#noteClass = noteClass }
  setNoteLabel (label) { this.#label = label }

  note () {
    const n = this.#g * this.#grid.gstep + this.#h * this.#grid.hstep, { edo } = this.#grid;
    return [ Math.floor(n / edo), (n % edo + edo) % edo ]
  }

  colour (bgColour) {
    const { noteColours } = app.state(),
          [ colourBase, oharm, uharm ] = this.#noteClass?.match(/(black|white)(?:(\d{1,2})o)?(?:(\d{1,2})u)?/)?.slice(1) ?? [],
          { gridctx } = app.state(), vertices = this.vertices(), { isGhost } = this,
          drawHex = c => {
            gridctx.beginPath();
            gridctx.moveTo(...vertices[5]);
            for (let [ x, y ] of vertices) gridctx.lineTo(x, y);
            gridctx.strokeStyle = isGhost ? c : "#dddddd";
            gridctx.fillStyle = isGhost ? "#00000000" : c;
            gridctx.lineWidth = isGhost ? 6 : 1;
            gridctx.fill();
            gridctx.stroke();
          }
    gridctx.globalCompositeOperation = isGhost ? "lighten" : "source-over";
    if (bgColour) drawHex(bgColour);
    else if (colourBase) {
      const bc = noteColours[isGhost ? colourBase === "white" ? "black" : "white" : colourBase],
            oc = oharm ? colourMix(bc, noteColours[oharm], .1) : null,
            uc = uharm ? colourMix(bc, noteColours[uharm], .1) : null;
      if (oc && uc) {
        bgColour = colourMix(oc, uc, .5);
        drawHex(colourMix(oc, noteColours.white, .1));
        const [cx, cy] = this.centre();
        gridctx.save();
        gridctx.beginPath();
        gridctx.arc(cx, cy, this.#grid.r, 0, Math.PI);
        gridctx.closePath();
        gridctx.clip();
        drawHex(colourMix(uc, noteColours.black, .1));
        gridctx.restore();
      } else drawHex(bgColour = (oc ? colourMix(oc, noteColours.white, .1) : uc ? colourMix(uc, noteColours.black, .1) : bc))
    } else drawHex(bgColour = noteColours.default);
    gridctx.font = (isGhost ? "bold  " : "") + (.5 * this.#grid.r) + "px HEJI2, ArbutusSlab";
    const [ x, y ] = this.centre(),
          { width } = gridctx.measureText(this.#label);
    gridctx.fillStyle = isGhost ? bgColour : contrast(bgColour);
    gridctx.fillText(this.#label ?? this.note()[1], x - width / 2, y)
  }

  start () {
    const { audioctx, masterVolume, noteColours } = app.state(),
          { edo, freqBasis, refNote } = this.#grid, [ octave, steps ] = this.note(),
          osc = this.#osc = audioctx.createOscillator(),
          volume = this.#volume = audioctx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freqBasis * 2 ** (octave + ((refNote + steps) / edo));
    osc.connect(volume);
    volume.connect(masterVolume);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime)
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime + .05)
    osc.start(audioctx.currentTime)
  }

  stop () {
    const { audioctx } = app.state(),
          osc = this.#osc, volume = this.#volume;
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime + .05);
    osc.stop(audioctx.currentTime + .05);
    this.#osc = null;
    this.#volume = null
  }

}

class HexGrid {
  w = 0; h = 0; c; unit = 50; r = this.unit * 2; octLen
  edo = 5; gstep = 2; hstep = 1; orientations = []; theta = 0
  #hexes = new Map(); #edges; #notes; #keys
  active = new Map(); touches = new Map(); scheduled = new Set()
  freqBasis; refNote; orientation
  limit; maxerror

  constructor (opts = {}) {
    Object.assign(this, opts);
    if ("orientation" in opts) this.setOrientation(...opts.orientation)
  }

  #newHex (g, h, isGhost) {
    const row = this.#hexes.get(g) ?? this.#hexes.set(g, new Map()).get(g),
          hex = new HexButton(g, h, this, isGhost);
    row.set(h, hex);
    return hex
  }

  getHex (g, h) { return this.#hexes.get(g)?.get(h) }
  hasHex (g, h) { return this.#hexes.get(g)?.has(h) ?? false }

  * [Symbol.iterator] () { for (let [ , row ] of this.#hexes) for (let [ , hex ] of row) yield hex }

  genOrientations () {
    const { gstep, hstep, edo } = this, res = [];
    for (let y = 0; y <= edo / hstep; y++) {
      const x = (edo - hstep * y) / gstep;
      if (x === Math.floor(x)) res.push ([ x, y ])
    }
    this.orientations = res;
  }
  setOrientation (g, h) {
    this.orientation = [ g, h ];
    const { unit, w } = this, x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5;
    this.theta = Math.atan(y / x)
  }

  updateGrid (force) {
    if (this.#notes && !force) return;
    const { gstep, hstep, edo, c, w, octLen } = this, [ g, h ] = this.orientation;

    // Central line
    this.#hexes = new Map();
    this.#edges = new Set([this.#newHex(0, 0, false)]);
    this.#notes = new Set([0]);
    let left = .5, right = .5, focus = [ [0, 0], [0, 0] ];
    for (let i = 1; i <= g + h; i++) {
      if (left / i <= h / (g + h)) { left++; focus[0][1]++ } else focus[0][0]++;
      if (right / i < h / (g + h)) { right++; focus[1][1]++ } else focus[1][0]++;
      this.#edges.add(this.#newHex(...focus[0], false));
      this.#notes.add(focus[0][0] * gstep + focus[0][1] * hstep);
      if (focus[0].every((v, i) => v === focus[1][i])) continue
      this.#edges.add(this.#newHex(...focus[1], false));
      this.#notes.add(focus[1][0] * gstep + focus[1][1] * hstep)
    }

    // One octave
    this.fillGrid({
      candidate: (g0, h0) => between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(mod(g0 * gstep + h0 * hstep, edo)),
      filter: hexes => group(hexes, ([a, b], [c, d]) => mod((a - c) * gstep + (b - d) * hstep, edo) === 0)
        .map(enhs => enhs.sort((a, b) => Math.abs(this.h / 2 - HexButton.centre(...a, this)[1]) > Math.abs(this.h / 2 - HexButton.centre(...b, this)[1]))[0]),
      isGhost: () => false
    });

    // Two octaves
    this.#notes = new Set();
    this.fillGrid({
      candidate: (g0, h0) => between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(mod(g0 * gstep + h0 * hstep, edo)),
      filter: hexes => group(hexes, ([a, b], [c, d]) => mod((a - c) * gstep + (b - d) * hstep, edo) === 0)
        .filter(([[g0, h0]]) => !this.#notes.has(mod(g0 * gstep + h0 * hstep, edo)))
        .map(enhs => enhs.sort((a, b) => Math.abs(this.h / 2 - HexButton.centre(...a, this)[1]) > Math.abs(this.h / 2 - HexButton.centre(...b, this)[1]))[0]),
      isGhost: () => true
    });

    // Fill to sides
    const home = [ ...this ];
    this.fillGrid({
      candidate: (g0, h0) => {
        const homeEquiv = ~home.findIndex(hex => {
                const [ baseG, baseH ] = hex.getCoord();
                return (baseG - g0) * h === (baseH - h0) * g // require gcd(g, h) === 1
              });
        return homeEquiv && HexButton.vertices(g0, h0, this).some(([ px, py ]) =>
          px > 0 && px < this.w && py > 0 && py < this.h)
      },
      isGhost: (g0, h0) => home.find(hex => {
        const [ baseG, baseH ] = hex.getCoord();
        return (baseG - g0) * h === (baseH - h0) * g 
      }).isGhost
    })
  }

  async fillGrid ({ candidate, filter = x => x, isGhost }) {
    let viewEdges = new Set([ ...this.#edges ]);
    while (viewEdges.size > 0) {
      let newViewEdges = new Map(), removeViewEdges = new Set(), newNotes = new Set();
      for (let hex of viewEdges) {
        let remove = true;
        for (let [g, h] of hex.neighbours()) {
          const thisHex = this.getHex(g, h);
          if (thisHex) { if (viewEdges.has(thisHex)) removeViewEdges.add(thisHex) }
          else if (candidate(g, h)) {
            newViewEdges.get(g)?.add(h) ?? newViewEdges.set(g, new Set([h]));
            newNotes.add(mod(g * this.gstep + h * this.hstep, this.edo));
          } else remove = false;
        }
        removeViewEdges.add(hex)
        if (remove) this.#edges.delete(hex)
      }
      filter([ ...(function * () {
        for (let [g, s] of newViewEdges) for (let h of s) yield [g, h]
      })() ]).forEach(([g, h]) => {
        const nextHex = this.#newHex(g, h, isGhost(g, h));
        this.#edges.add(nextHex);
        viewEdges.add(nextHex)
      });
      removeViewEdges.forEach(hex => viewEdges.delete(hex));
      this.#notes = new Set([ ...this.#notes, ...newNotes ])
    }
  }

  rotate (x, y, rev = false) {
    const cx = this.w / 2, cy = this.h / 2, theta = rev ? -this.theta : this.theta,
          cos = Math.cos(theta), sin = Math.sin(theta);
    return [ cos * (x - cx) + sin * (y - cy) + cx, cos * (y - cy) - sin * (x - cx) + cy ]
  }

  getCoord (x, y) {
    const { r, w: width, h: height, c } = this;
    ([ x, y ] = this.rotate(x * 2 + c, y * 2, true));
    const a = (x - width / 2) / r / Math.sqrt(3) * 2,
          b = (y - height / 2) / r * 2,
          band = Math.floor(Math.floor((b + 1) / 3));
    if (((Math.floor(b % 3)) + 3) % 3 === 1) {
      const clampedA = ((a % 1) + 1) % 1, clampedB = ((b % 1) + 1) % 1,
            topLeft = clampedA + clampedB > 1, bottomLeft = clampedA < clampedB,
            h = 2 * Math.floor((b + 4) / 6), g = Math.floor((a - h) / 2);
      if (band % 2) return Math.floor(a) % 2 ? [ g + 1, h - !topLeft ] : [ g + !bottomLeft, h - !bottomLeft ];
      else return Math.floor(a) % 2 ? [ g + !bottomLeft, h + bottomLeft ] : [ g, h + topLeft ]
    } else return [ Math.floor((a - band + 1) / 2), band ]
  }

  classifyKeys (force) {  // BUG?: will not work when first harmonic is 15, 21, 35 or 45
    if (this.#keys && !force) return;
    const { edo, hmap } = this,
          [p0, prad] = hmap.length ? decomp(hmap[0][0])[0][0] : [], pstep = hmap[0]?.[1];
    this.#keys = new Map();
    let i = edo - 1, prev, k = 0, result = Array(edo).fill(), prevResult,
        intervals = app.intervals.map(([iv, step]) => [decomp(...iv), step]);
    result[0] = [[[], []]];
    while (i > 0 && (i !== prev || i === edo - 1) && hmap.length) {
      prev = i;
      prevResult = structuredClone(result);
      for (let [[n, d], step] of intervals) {
        let s = mod(step + k / prad * pstep, edo),
            ni = n.findIndex(([p]) => p === p0), nrad = n[ni]?.[1],
            di = d.findIndex(([p]) => p === p0), drad = d[di]?.[1];
        if (prevResult[s] === undefined) (result[s] ??= (i--, [])).push(~di ?
          drad > k ? [n.slice(), d.with(di, [p0, drad - k])] :
            [ drad < k ? [[p0, k - drad]].concat(n) : n.slice(), d.toSpliced(di, 1) ] :
          [ ~ni ? n.with(ni, [p0, nrad + k]) : k ? [[p0, k]].concat(n) : n.slice(), d.slice() ]);
        s = mod(step - k / prad * pstep, edo);
        if (k > 0 && prevResult[s] === undefined) (result[s] ??= (i--, [])).push(~ni ?
          nrad > k ? [n.with(ni, [p0, nrad - k]), d.slice()] :
            [ n.toSpliced(ni, 1), nrad < k ? [[p0, k - nrad]].concat(d) : d.slice() ] :
          [ n.slice(), ~di ? d.with(di, [p0, drad + k]) : k ? [[p0, k]].concat(d) : d.slice() ])
      }
      k += prad
    }
    result.forEach(ivs => ivs?.forEach(iv => iv?.forEach(fs => fs.sort(([a], [b]) => a > b))));
    for (let hex of this) {
      const key = hex.note()[1], labels = [];
      if (result[key] === undefined) {
        hex.setNoteClass("default");
        hex.setNoteLabel(key)
      } else for (let i = 0, ivs = result[key]; i < ivs.length; i++) {
        const { accid, string: label } = noteFromFactors(ivs[i]);
        let noteClass = between(6, 10, mod(accid[3], 12)) ? "black" : "white";
        const ot = ivs[i][0].findLast(([p]) => p !== 3);
        if (ot) noteClass += ot[0] + "o";
        const ut = ivs[i][1].findLast(([p]) => p !== 3);
        if (ut) noteClass += ut[0] + "u";
        labels.push({ label, noteClass, interval: ivs[i] })
        if (i) continue;
        hex.setNoteClass(noteClass);
        hex.setNoteLabel(label)
      }
      this.#keys.has(key) ? this.#keys.get(key).addNote(hex) :
        this.#keys.set(key, new HexKey(hex, labels));
      }
  }

  getEnharmonics (key) { return this.#keys.get(key).getLabels() }

  renameKey (key, i) {
    this.#keys.get(key).setLabel(i);
    this.redraw()
  }
  getHexFromSteps (steps) { return this.#keys.get(steps).getNotes().find(hex => !hex.isGhost && hex.note()[0] === 0) }

  async redraw (force) {
    const { gridctx } = app.state(), canvas = $("canvas"), { width, height } = canvas;
    this.updateGrid(force);
    this.classifyKeys(force);
    gridctx.reset();
    gridctx.textBaseline = "middle";
    gridctx.fillStyle = "#000000";
    gridctx.fillRect(0, 0, width, height);
    for (let hex of this) hex.colour();
    $("main").style.backgroundImage = `url('${URL.createObjectURL(new Blob([await new Promise(r => canvas.toBlob(r))]))}')`
  }

  colour () {
    const { gridctx } = app.state(), canvas = $("canvas"), { width, height } = canvas;
    gridctx.clearRect(0, 0, width, height);
    for (let [hex] of this.active) hex.colour(app.noteColours.active);
    for (let hex of this.scheduled) hex.colour(app.noteColours.active);
  }
}

class HexChord {
  #hexes
  constructor (...hexes) { this.#hexes = hexes }
  start () { this.#hexes.forEach(hex => hex.start()) }
  stop () { this.#hexes.forEach(hex => hex.stop()) }
  getHexes () { return this.#hexes }
}

class HexKey {
  #labels; #notes
  constructor (note, labels) {
    this.#notes = new Set([note]);
    this.#labels = labels
  }
  addNote (note) { this.#notes.add(note) }
  getNotes () { return [ ...this.#notes ] }
  getLabels () { return this.#labels.slice() }
  setLabel (i) { this.#notes.forEach(note => {
    const { label, noteClass } = this.#labels[i];
    note.setNoteClass(noteClass);
    note.setNoteLabel(label)
  }) }
}

// Page state
var app = new $.Machine({
    // Navigation
      menuState: [],
      keyboards: {
        "12edo": {
          gstep: 2, hstep: 1, orientations: [[6,0],[5,2],[4,4],[3,6],[2,8],[1,10],[0,12]], orientation: [5, 2], unit: 45,
          refNote: 9, freqBasis: 220, edo: 12, limit: 9, maxerror: 33, hmap: [[3, 7], [5, 4], [7, 10]], instrument: "triangle"
        },
        "19edo": {
          gstep: 3, hstep: 2, orientations: [[5,2],[3,5],[1,8]], orientation: [5, 2], unit: 45,
          refNote: 14, freqBasis: 220, edo: 19, limit: 9, maxerror: 21, hmap: [[3, 11], [5, 6]], instrument: "triangle"
        },
        "22edo": {
          gstep: 4, hstep: 1, orientations: [[5,2],[4,6],[3,10],[2,14],[1,18],[0,22]], orientation: [5, 2], unit: 45,
          refNote: 16, freqBasis: 220, edo: 22, limit: 9, maxerror: 18, hmap: [[3, 13], [5, 7], [7, 18]], instrument: "triangle"
        },
        "31edo": {
          gstep: 5, hstep: 3, orientations: [[5,2],[2,7]], orientation: [5, 2], unit: 45,
          refNote: 23, freqBasis: 220, edo: 31, limit: 9, maxerror: 12, hmap: [[3, 18], [5, 10], [7, 25]], instrument: "triangle"
        },
        "41edo": {
          gstep: 7, hstep: 3, orientations: [[5,2],[2,9]], orientation: [5, 2], unit: 45,
          refNote: 30, freqBasis: 220, edo: 41, limit: 9, maxerror: 9, hmap: [[3, 24], [5, 13], [7, 33]], instrument: "triangle"
        },
        "53edo": {
          gstep: 5, hstep: 4, orientations: [[9,2],[5,7],[1,12]], orientation: [5, 7], unit: 45,
          refNote: 39, freqBasis: 220, edo: 53, limit: 9, maxerror: 7, hmap: [[3, 31], [5, 17], [7, 43]], instrument: "triangle"
        },
        "94edo": {
          gstep: 9, hstep: 7, orientations: [[5,7]], orientation: [5, 7], unit: 45,
          refNote: 69, freqBasis: 220, edo: 94, limit: 9, maxerror: 4, hmap: [[3, 55], [5, 30], [7, 76]], instrument: "triangle"
        },
      },

      // Keyboard
      octaves: null,
      noteColours: {
        default: "#333333", active: "#ffff00",
        white: "#222222", black: "#777777",
        5: "#ff0000", 7: "#0000ff", 11: "#00ff00", 13: "#ff00ff"
      },
      keyboardSelection: null,
      gridctx: null,
      hexGrid: null,
      getGridScope: () => app.menuState[0] === "keyboard-settings" ? app.menuState[1] : app,
      mousedown: false,
      audioctx: null,
      masterVolume: null,

      // Harmony
      temperings: null,
      intervals: null,

      // Track
      tracks: {},
      trackSelection: null
    });

// Events
$.targets({

  load () { app.emit("init") },

  keydown (e) { if (e.key === "Escape") document.activeElement.blur() },

  resize () {
    app.emit("resize");
    app.getGridScope().hexGrid.redraw(true)
  },

  contextmenu (e) { e.preventDefault() },

  "touchstart touchend touchmove" (e) {
    const nav = $("canvas");
    if (e.type === "touchstart" && document.activeElement === nav && !e.composedPath().includes(nav)) $(nav).blur();
    const canvas = $("canvas");
    if (e.target === canvas) 
      for (let { clientX, clientY, identifier } of e.changedTouches) {
        const x = clientX - canvas.offsetLeft, y = clientY - canvas.offsetTop,
              { hexGrid } = app.getGridScope()
        if ((app.getGridScope().hexGrid.touches.has(identifier) || e.type === "touchstart") &&
          (hexGrid.hasHex(...hexGrid.getCoord(x, y)) || e.type === "touchend"))
          app.emit("press", e.type.slice(5), x, y, identifier)
      }
  },

  mousedown (e) {
    const { hexGrid } = app.getGridScope();
    if (e.target === $("canvas") && hexGrid.hasHex(...hexGrid.getCoord(e.layerX / 2, e.layerY / 2))) {
      app.mousedown = true;
      app.emit("press", "start", e.layerX / 2, e.layerY / 2)
    }
  },
  mousemove (e) {
    const { hexGrid } = app.getGridScope(),
          hover = hexGrid.hasHex(...hexGrid.getCoord(e.layerX / 2, e.layerY / 2));
    $("main").classList.toggle("hover", hover);
    if (app.mousedown && hover)
      app.emit("press", "move", e.layerX / 2, e.layerY / 2)
  },
  "mouseup mouseout" (e) {
    if (app.mousedown && e.type !== "mouseout") {
      app.mousedown = false;
      app.emit("press", "end", e.layerX / 2, e.layerY / 2)
    }
  },

  app: {

    init () {
      this.canvas = $("#hex");
      new ResizeObserver(() => {
        this.emit("resize");
        this.getGridScope().hexGrid.redraw()
      }).observe($("main"));
      this.gridctx = this.canvas.getContext("2d");
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = scaleVolume($("#volume > input").valueAsNumber);
      this.octaves = $("#octaves > input").valueAsNumber;
      $("#track-select > select").selectedIndex = 0;
      this.emit("load-presets")
    },

    "clear-storage" () { localStorage.clear() },

    "load-presets" () {
      // Keyboards
      let keyboards = localStorage.getItem("keyboards");
      if (!keyboards) {
        keyboards = this.keyboards;
        localStorage.setItem("keyboards", JSON.stringify(keyboards))
      } else localStorage.setItem("keyboards", JSON.stringify(keyboards = Object.assign(this.keyboards, JSON.parse(keyboards))));
      Object.keys(keyboards).forEach(name => {
        const el = $.load("option", "#keyboard-select > select")[0][0]
        el.innerText = name;
        el.setAttribute("name", name)
      });
      const customKeybOptEl = $.load("option", "#keyboard-select > select")[0][0]
      customKeybOptEl.innerText = "Custom";
      customKeybOptEl.setAttribute("name", "Custom");
      customKeybOptEl.disabled = true;

      let keyboardSelection = localStorage.getItem("keyboardSelection");
      if (!keyboardSelection) {
        keyboardSelection = Object.keys(app.keyboards)[0];
        localStorage.setItem("keyboardSelection", keyboardSelection)
      } else keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value = keyboardSelection;
      
      let keyboard = keyboardSelection === "Custom" ? JSON.parse(localStorage.getItem("keyboard")) : keyboards[keyboardSelection];

      let hmap = new Map(keyboard.hmap.map(([k, v]) => [parseInt(k), v])),
          hs = Array((keyboard.limit + 1) / 2).fill().map((_, i) => [ 2 * i + 1, decomp(2 * i + 1)[0].reduce((s, [p, rad]) => s + hmap.get(p) * rad, 0) % keyboard.edo ]);
      this.intervals = group(hs.reduce((acc, [n, i]) => acc.concat(hs.map(([d, j]) => {
        const oct = Math.floor(Math.log2(n) - Math.log2(d)), c = gcd(n, d);
        return [oct > 0 ? [n / c, (d / c) << oct] : oct < 0 ? [(n / c) << -oct, d / c] : [n / c, d / c], (i - j + keyboard.edo) % keyboard.edo]
      })), []), ([[a, b]], [[c, d]]) => a * d === b * c).map(([v]) => v);

      this.emit("fill-keyboard-settings", keyboard);
      app.getGridScope().hexGrid = new HexGrid(keyboard);

      let noteColours = localStorage.getItem("noteColours");
      if (!noteColours) {
        noteColours = this.noteColours;
        localStorage.setItem("noteColours", JSON.stringify(noteColours))
      } else localStorage.setItem("noteColours", JSON.stringify(this.noteColours = JSON.parse(noteColours)));      

      // Tracks
      let tracks = localStorage.getItem("tracks");
      if (!tracks) {
        this.tracks = tracks = {};
        localStorage.setItem("tracks", "{}");
      } else this.tracks = tracks = JSON.parse(tracks);
      const trackSelEl = $("#track-select select"), selectHrEl = $("#track-select hr");
      Object.keys(this.tracks).forEach(name => {
        const el = $.load("option", "#track-select > select")[0][0];
        el.innerText = name;
        el.setAttribute("name", name);
        trackSelEl.insertBefore(el, selectHrEl)
      })
    },

    // Keyboard
    "fill-keyboard-settings" ({
      unit, edo, gstep, hstep, freqBasis, refNote,
      orientation, orientations, limit, maxerror, hmap }) {
      $("#gstep > input").value = gstep;
      $("#hstep > input").value = hstep;
      $.all("#orientation > select > *").forEach(el => el.remove());
      orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      });
      $("#orientation > select").options.namedItem(orientation.join(",")).selected = true;
      $("#unit > input").value = unit;
      $("#refNote > input").value = refNote;
      $("#freqBasis > input").value = freqBasis;
      $("#edo > input").value = edo;
      $("#scale > output").value = `One step of ${edo}edo = ${(1200 / edo).toFixed(2)}¢`;
      $("#limit > input").value = limit;
      $("#maxerror > input").value = maxerror
    },

    "load-keyboard" () {
      keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value;
      let keyboard = {};
      localStorage.setItem("keyboardSelection", keyboardSelection);
      if (keyboardSelection === "Custom") {
        [ "unit", "edo", "gstep", "hstep", "refNote", "freqBasis", "limit", "maxerror" ]
          .forEach(dataname => keyboard[dataname] = $(`#${dataname} > input`).valueAsNumber);
        keyboard.orientation = $("#orientation > select").value.split(",").map(v => parseInt(v));
        keyboard.hmap = $.all(".harmonic.prime > input.steps").map(el => [parseInt(el.parentElement.dataset.harm), el.valueAsNumber]);
        const hexGrid = this.getGridScope().hexGrid = new HexGrid(keyboard);
        hexGrid.genOrientations();
        keyboard.orientations = hexGrid.orientations;
      
        localStorage.setItem("keyboard", JSON.stringify(keyboard))
      } else {
        $("#keyboard-select > select").namedItem("Custom").disabled = true
        keyboard = this.keyboards[keyboardSelection];
        localStorage.removeItem("keyboard");
        
        const hexGrid = this.getGridScope().hexGrid = new HexGrid(keyboard);
        hexGrid.setOrientation(...keyboard.orientation);
        this.emit("fill-keyboard-settings", hexGrid);
      }
      this.emit("update-mapping");
      this.emit("resize");
      this.getGridScope().hexGrid.redraw(true);
    },

    "change-keyboard-edo" () {
      const edo = $("#edo > input").valueAsNumber;
      $("#scale > output").value = `One step of ${edo}edo = ${(1200 / edo).toFixed(2)}¢`;
      $("#maxerror > input").value = Math.floor(400 / edo);
      this.emit("change-keyboard-lattice");
      this.emit("update-mapping")
    },

    "change-keyboard-lattice" () {
      const { hexGrid } = this.getGridScope(),
            gstep = $("#gstep > input").valueAsNumber,
            hstep = $("#hstep > input").valueAsNumber,
            edo = $("#edo > input").valueAsNumber;
      $.all("#orientation > select > *").forEach(el => el.remove());
      if (gcd(gstep, hstep) !== 1) {
        $("#keyboard-settings-apply").disabled = true;
        return
      }
      $("#keyboard-settings-apply").disabled = false;
      Object.assign(hexGrid, { gstep, hstep, edo });
      hexGrid.genOrientations();
      const orientation = hexGrid.orientations.find(([g, h]) => g + h === 7) || hexGrid.orientations[0];
      if (!orientation) {
        $("#keyboard-settings-apply").disabled = true;
        return
      }
      hexGrid.setOrientation(...orientation);
      hexGrid.orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      })
      $("#orientation > select").namedItem(orientation).selected = true
    },

    // Harmonic mapping
    "update-mapping" () {
      const limit = $("#limit > input").valueAsNumber,
            maxerror = $("#maxerror > input").valueAsNumber,
            edo = $("#edo > input").valueAsNumber,
            { hexGrid } = this.getGridScope(),
            getHex = (o, n) => [ ...hexGrid ].find(hex => hex.note().every((v, i) => v === (i ? n : o)));
      $.all(".harmonic").forEach(el => el.remove());
      let hmap = new Map();

      // Harmonics
      for (let i = 3; i <= limit; i += 2) {
        const just = Math.log2(i) % 1,
              isComp = decomp(i)[0].reduce((s, [p, r]) => s + r * hmap.has(p), 0) > 1,
              steps = isComp ?
                decomp(i)[0].reduce((acc, [p, rad]) => {
                  const [pp, pr] = Array(rad).fill().map((_,i) => [p ** (i + 1), i + 1]).find(([pp]) => hmap.get(pp))
                  return acc + hmap.get(pp) * (rad / pr)
                }, 0) % edo :
                clamp(Math.ceil((just - maxerror / 1200) * edo), Math.floor((just + maxerror / 1200) * edo), hmap.get(i)) ?? Math.round(just * edo),
              error = (steps / edo - just) * 1200;
        if (!isComp) hmap.set(i, steps);
        if (Math.abs(error) >= maxerror || steps + edo * maxerror / 1200 < 1 || steps - edo * maxerror / 1200 > edo - 1) {
          hmap.delete(i);
          continue;
        }
        const labelEl = $.load("harmonic", "#mapping")[0][0],
              inputEl = $("input.steps", labelEl),
              compositeEl = $("span.steps", labelEl),
              errorEl = $("#error", labelEl),
              colourEl = $("input.hcolour", labelEl);
        labelEl.dataset.harm = i;
        $("#nth-harmonic", labelEl).innerText = ordinal(i);
        inputEl.setAttribute("value", steps);
        inputEl.setAttribute("min", Math.max(1, Math.ceil((just - maxerror / 1200) * edo)));
        inputEl.setAttribute("max", Math.min(edo - 1, Math.floor((just + maxerror / 1200) * edo)));
        if (isComp) compositeEl.innerText = steps;
        else {
          labelEl.classList.add("prime");
          if (decomp(i)[0][0][1] > 1) labelEl.classList.add("power");
        }
        errorEl.innerText = error.toFixed(2);
        if (i === 3) {
          colourEl.value = this.noteColours.white;
          labelEl.appendChild(colourEl.cloneNode()).value = this.noteColours.black;
        } else colourEl.value = this.noteColours[i] ??= this.noteColours.default;
        $.queries({
          "input.steps": { change () { app.emit("update-mapping") } },
          "input.hcolour": { change () { app.emit("set-colour", i, this.value, this === $.all("input.hcolour")[1]) } },
          button: (chord => ({
            pointerdown (e) {
              const { hexGrid: grid } = app.getGridScope();
              let enhi = grid.getEnharmonics(steps).findIndex(({ interval }) => comp(interval[0])[0] === i && interval[1].length === 0);
              ~enhi && grid.renameKey(steps, enhi);
              chord = new HexChord([ ...grid ][0], getHex(0, steps));
              this.setPointerCapture(e.pointerId); chord.start();
              chord.getHexes().forEach(hex => grid.scheduled.add(hex));
              grid.colour();
            },
            pointerup (e) {
              const { hexGrid: grid } = app.getGridScope();
              chord.getHexes().forEach(hex => grid.scheduled.delete(hex));
              grid.colour();
              this.releasePointerCapture(e.pointerId); chord.stop()
            }
          }))()
        }, labelEl)
      }
      Object.assign(hexGrid, { limit, maxerror, edo, hmap: [...hmap] });

      // Tonality diamond
      const diamondEl = $("#diamond");
      $.all(":scope > *", diamondEl).forEach(el => el.remove());
      const temperings = this.temperings = $.all(".harmonic").map(el => [ parseInt(el.dataset.harm), $("input", el).valueAsNumber ])
              .sort(([p], [q]) => Math.log2(p) % 1 > Math.log2(q) % 1),
            h = temperings.length;
      diamondEl.style.setProperty("--size", 2 * h + 1);
      for (let i = 0; i <= h; i++) {
        const cell = $.load("diamond-cell", "#diamond")[0][0],
              [ interval, note, width, button ] = $.all(":scope > *", cell);
        cell.style.gridArea = `${h + 1}/${2 * i + 1}/span 1/span 2`;
        cell.dataset.interval = "1/1";
        interval.innerHTML = "<sup>1</sup>/<sub>1</sub>";
        note.innerText = "C";
        width.innerText = 0;
        button.dataset.steps = 0
      }
      $.queries({ "button": (hex => ({
        pointerdown (e) {
          $.all('.diamond-cell[data-interval="1/1"]').forEach(el => el.classList.add("activeEnharmonic"));
          this.setPointerCapture(e.pointerId);
          const { hexGrid: grid } = app.getGridScope();
          hex = [ ...grid ][0];
          hex.start();
          grid.scheduled.add(hex);
          grid.colour();
        },
        pointerup (e) {
          $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
          this.releasePointerCapture(e.pointerId);
          hex.stop();
          const { hexGrid: grid } = app.getGridScope();
          grid.scheduled.delete(hex);
          grid.colour();
        }
      }))() }, diamondEl);
      const ivs = [[[1,1],0]];
      for (let i = h; i > 0; i--) for (let j = 0; j < i; j++) {
        const upperCell = $.load("diamond-cell", "#diamond",)[0][0],
              lowerCell = $.load("diamond-cell", "#diamond",)[0][0],
              [ upperInterval, upperNote, upperWidth ] = $.all(":scope > *", upperCell),
              [ lowerInterval, lowerNote, lowerWidth ] = $.all(":scope > *", lowerCell),
              num = h - i + j, den = j - 1,
              octave = Math.floor(Math.log2(temperings[num][0] / (temperings[den]?.[0] ?? 1))),
              div = gcd(temperings[num][0], (temperings[den]?.[0] ?? 1)),
              upNum = temperings[num][0] * (octave < 0 ? 2 ** -octave : 1) / div,
              upDen = (temperings[den]?.[0] ?? 1) * (octave < 0 ? 1 : 2 ** octave) / div,
              loNum = (temperings[den]?.[0] ?? 1) * (octave < -1 ? 1 : 2 ** (octave + 1)) / div,
              loDen = temperings[num][0] * (octave < -1 ? 2 ** (-octave - 1) : 1) / div,
              upSteps = (temperings[num][1] - (temperings[den]?.[1] ?? 0) + edo) % edo,
              loSteps = (edo - upSteps) % edo;
        upperCell.style.gridArea = `${i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        lowerCell.style.gridArea = `${2 * h + 2 - i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        upperCell.dataset.interval = `${upNum}/${upDen}`;
        lowerCell.dataset.interval = `${loNum}/${loDen}`;
        if (!~ivs.findIndex(([n, d]) => n === upNum && d === upDen)) ivs.push([[upNum, upDen], upSteps]);
        if (!~ivs.findIndex(([n, d]) => n === loNum && d === loDen)) ivs.push([[loNum, loDen], loSteps]);
        upperInterval.innerHTML = `<sup>${upNum}</sup>/<sub>${upDen}</sub>`;
        lowerInterval.innerHTML = `<sup>${loNum}</sup>/<sub>${loDen}</sub>`;
        upperNote.innerText = noteFromFactors(decomp(upNum, upDen)).string;
        lowerNote.innerText = noteFromFactors(decomp(loNum, loDen)).string;
        upperWidth.innerText = upSteps;
        lowerWidth.innerText = loSteps;
        [ [ upperCell, upSteps ], [ lowerCell, loSteps ] ].forEach(([ cellEl, steps ], half) => $.queries({ "button": (chord => ({
            pointerdown (e) {
              const { hexGrid: grid } = app.getGridScope(),
                    enhs = grid.getEnharmonics(steps).map(({ interval }) => interval),
                    enhi = enhs.findIndex(iv =>
                      comp(iv[0])[0] === (temperings[half ? den : num]?.[0] ?? 1) &&
                      comp(iv[1])[0] === (temperings[half ? num : den]?.[0] ?? 1));
              $.all(`.diamond-cell:is(${enhs.map(iv => {  // TODO use steps instead
                const n = comp(iv[0]), d = comp(iv[1]),
                      oct = Math.floor(Math.log2(n) - Math.log2(d)),
                      num = oct < 0 ? n << -oct : n, den = oct > 0 ? d << oct : d;
                return `[data-interval="${num}/${den}"]`
              })})`)
                .forEach(el => el.classList.add("activeEnharmonic"));
              ~enhi && grid.renameKey(steps, enhi);
              chord = new HexChord([ ...grid ][0], app.getGridScope().hexGrid.getHexFromSteps(steps));
              this.setPointerCapture(e.pointerId);
              chord.start();
              chord.getHexes().forEach(hex => grid.scheduled.add(hex));
              grid.colour();
            },
            pointerup (e) {
              $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
              this.releasePointerCapture(e.pointerId);
              chord.stop();
              const { hexGrid: grid } = app.getGridScope();
              chord.getHexes().forEach(hex => grid.scheduled.delete(hex));
              grid.colour();
            }
          }))() }, cellEl))
      }
      this.intervals = group(group(ivs, ([[a, b]], [[c, d]]) => a * d === b * c).map(([v]) => v), ([a], [b]) => a.some(k => non2(k) === 1) === b.some(k => non2(k) === 1))
        .sort((ivs, jvs) => ivs.length > jvs.length).map(ivs => ivs.sort(() => 2 * Math.random() > 1)).flat()
      hexGrid.redraw(true)
    },

    "set-colour" (harm, colour, isBlackKeys) {
      if (harm === 3) this.noteColours[isBlackKeys ? "black" : "white"] = colour;
      else this.noteColours[harm] = colour;
      localStorage.setItem("noteColours", JSON.stringify(this.noteColours));
      this.getGridScope().hexGrid.redraw()
    },

    // Track editor
    "track-name-update" (name) {
      const { tracks, trackSelection } = this, trackSelEl = $("#track-select > select");
      if (name === "New" || name in tracks && trackSelEl.value !== name) {
        $("#track-name-field").classList.add("invalid");
        return
      }
      $("#track-file").classList.add("saved");
      delete this.tracks[trackSelection];
      this.tracks[name] = $("#track-edit").value;
      this.trackSelection = name;
      $("#track-name-text").innerText = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name").classList.remove("editingTrackName");
      $(`#track-select option[name='${trackSelection}']`)?.remove();
      const el = $.load("option", "#track-select > select")[0][0];
      el.innerText = name;
      el.setAttribute("name", name);
      trackSelEl.insertBefore(el, $("#track-select hr"));
      el.selected = true;
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
    },

    "track-editor" (name) {
      const { tracks } = this;
      if (!name) {
        const nth = Object.keys(tracks)
                .map(tn => tn.match(/^Untitled( [1-9]\d*)?$/)?.slice(1).map(v => v ? parseInt(v) : 0))
                .flat().sort().findLastIndex((k, i) => k === i) + 1;
        name = "Untitled" + (nth ? " " + nth : "");
        $("#track-edit").value = "";
        $("#track-file").classList.remove("saved")
      } else {
        $("#track-edit").value = tracks[name];
        $("#track-file").classList.add("saved")
      }
      this.trackSelection = name;
      $("#track-name-field").value = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name-text").innerText = name;
      $("#track-name").classList.remove("editingTrackName");
    },

    "track-save" () {
      $("#track-file").classList.add("saved");
      $("#track-savestate").classList.add("saving");
      clearInterval(this.menuState[1].saveDebounce);
      this.menuState[1].saveDebounce = setTimeout(() => {
        localStorage.setItem("tracks", JSON.stringify(this.tracks));
        $("#track-savestate").classList.remove("saving")
      }, 500)
      const trackSelection = $("#track-name-field").value;
      let el;
      if (!(trackSelection in this.tracks)) {
        el = $.load("option", "#track-select > select")[0][0];
        el.innerText = trackSelection;
        el.setAttribute("name", trackSelection);
        $("#track-select select").insertBefore(el, $("#track-select hr"));
        el.selected = true
      } else el = $("#track-select > select").namedItem(trackSelection);
      this.trackSelection = $("#track-name-field").value;
      this.tracks[this.trackSelection] = $("#track-edit").value;
      el.innerText = trackSelection;
      el.setAttribute("name", trackSelection)
    },

    "track-delete" (response) {
      $("#delete-dialog").close(response);
      if (response === "Cancel") return;
      const { tracks, trackSelection } = this;
      delete this.tracks[trackSelection];
      this.trackSelection = null;
      $(`#track-select option[name='${trackSelection}']`).remove();
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
      this.emit("menu-cancel")
    },

    // Menu
    "menu-select" (which, ...data) {
      this.emit("menu-cancel");
      this.menuState = [which];
      $("body").classList.add("menuActive");
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $("#" + which).classList.add("activeMenu");
      let cancelEl, applyEl;
      switch (which) {
        case "keyboard-settings":
          $("#breadcrumb-text").innerText = "Keyboard ⚙️";
          cancelEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(cancelEl, { innerText: "Cancel", id: "keyboard-settings-cancel" });
          applyEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(applyEl, { innerText: "Apply", id: "keyboard-settings-apply" });
          $.queries({
            "#keyboard-settings-cancel": { click () { app.emit("menu-cancel") } },
            "#keyboard-settings-apply": { click () {
              app.hexGrid = app.menuState[1].hexGrid;
              app.emit("load-keyboard");
              app.emit("menu-cancel")
            } }
          });
          this.menuState[1] = { hexGrid: new HexGrid(this.hexGrid) };
          this.emit("fill-keyboard-settings", this.hexGrid);
          this.emit("update-mapping");
          break;
        case "track-editor":
          $("#breadcrumb-text").innerText = "Track ✎";
          $("#track-controls").classList.add("activeControls");
          $("#track-select > select").namedItem(data[0] ?? "New").selected = true;
          closeEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(closeEl, { innerText: "Close", id: "track-editor-close" });
          $.queries({ "#track-editor-close": {
            click () { app.emit("menu-cancel") }
          } });
          this.menuState[1] = { saveDebounce: null };
          this.emit("track-editor", ...data)
      }
    },
    "menu-cancel" () {
      $("body").classList.remove("menuActive")
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $.all("#menu-actions > *").forEach(el => el.remove());
      switch(this.menuState[0]) {
        case "track-editor":
          $("#track-controls").classList.remove("activeControls");
          $("#track-select > select").selectedIndex = 0
      }
      this.menuState = [];
      this.emit("resize");
      this.getGridScope().hexGrid.redraw(true)
    },

    "volume-change" (value) { this.masterVolume.gain.value = scaleVolume(value) },

    resize () {
      const { hexGrid } = this.getGridScope(),
            { canvas, octaves } = this, { unit, orientation: [g, h], theta } = hexGrid,
            x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5,
            { width, height } = $("main").getBoundingClientRect(),
            r = hexGrid.r = Math.min(unit * 2, width / (Math.hypot(x, y) * octaves + 2) * 2);
      hexGrid.w = canvas.width = Math.ceil(width) * 2,
      hexGrid.h = canvas.height = Math.ceil(height) * 2;
      hexGrid.c = (octaves % 2) * Math.hypot(x, y) * r / 2;
      hexGrid.octLen = Math.hypot(x, y) * r;
      canvas.style.setProperty("width", Math.ceil(width));
      canvas.style.setProperty("height", Math.ceil(height))
    },

    press (type, x, y, id) {
      const { hexGrid } = this.getGridScope(),
            { active, touches } = hexGrid,
            coord = hexGrid.getCoord(x, y), [g, h] = coord;
      let hex, ids;
      switch (type) {
        case "start":
          hex = hexGrid.getHex(...coord);
          if (!active.has(hex)) hex.start();
          active.set(hex, (active.get(hex) ?? new Set()).add(id));
          touches.set(id, hex);
          hexGrid.colour();
          break;
        case "move":
          hex = touches.get(id);
          ids = active.get(hex);
          if (hex.getCoord().some((v, i) => v !== coord[i])) {
            ids.delete(id);
            if (ids.size === 0) {
              hex.stop();
              active.delete(hex)
            }
            hex = hexGrid.getHex(...coord);
            if (!active.has(hex)) hex.start();
            active.set(hex, (active.get(hex) ?? new Set()).add(id));
            touches.set(id, hex);
            hexGrid.colour()
          }
          break;
        case "end":
          hex = touches.get(id);
          ids = active.get(hex);
          ids.delete(id);
          if (ids.size === 0) {
            hex.stop();
            active.delete(hex)
          }
          touches.delete(id)
          hexGrid.colour()
      }
    },

    panic () {
      this.audioctx.close();
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
    }
  }
});

$.queries({
  nav: { touchstart (e) { if ($.all("#refresh, #panic, #volume > input").every(el => e.target !== el)) this.focus() } },
  form: { submit (e) { e.preventDefault() } },
  "#volume > input": { change () { app.emit("volume-change", this.valueAsNumber) } },
  "#octaves > input": { change () {
    app.octaves = this.valueAsNumber;
    app.emit("resize");
    app.getGridScope().hexGrid.redraw(true)
  } },
  "#refresh": { click () { app.getGridScope().hexGrid.redraw() } },
  "#panic": { click () { app.emit("panic") } },
  "#keyboard-settings-button": { click () {
    if (app.menuState[0] === "keyboard-settings") app.emit("menu-cancel"); 
    else app.emit("menu-select", "keyboard-settings")
  } },
  "#keyboard-settings > form": { change (e) { $("#keyboard-select > select").value = "Custom" } },
  "#keyboard-select > select": { change () { app.emit("load-keyboard") } },
  "#edo > input": { change () {
    app.emit("change-keyboard-edo");
    app.emit("resize");
    app.getGridScope().hexGrid.redraw(true);
    this.focus()
  } },
  ":is(#gstep, #hstep) > input": { change () {
    app.emit("change-keyboard-lattice");
    const selEl = $("#orientation > select");
    if (selEl.children.length) {
      app.emit("resize");
      app.getGridScope().hexGrid.redraw(true);
      selEl.showPicker();
    }
  } },
  "#orientation > select": { change () {
    const { hexGrid } = app.getGridScope();
    hexGrid.setOrientation(...JSON.parse(`[${this.value}]`));
    app.emit("resize");
    hexGrid.redraw(true);
    this.focus()
  } },
  "#unit > input": { change () {
    const { hexGrid } = app.getGridScope();
    hexGrid.unit = this.valueAsNumber;
    app.emit("resize");
    hexGrid.redraw(true)
  } },
  ":is(#limit, #maxerror) > input": { change () { app.emit("update-mapping") } },
  "#track-select > select": { change () {
    if (this.value === "None") app.emit("menu-cancel");
    else app.emit("menu-select", "track-editor", ...(this.value === "New" ? [] : [ this.value ]))
  } },
  "#track-name-text": { click () {
    $("#track-name").classList.add("editingTrackName");
    $("#track-name-field").focus()
  } },
  "#track-name-field": { "keyup blur" (e) {
    if (e.type === "blur" || e.key === "Enter") app.emit("track-name-update", this.value = this.value.trim())
  } },
  "#track-delete": { click () {
    $("#delete-track-name").innerText = app.trackSelection;
    $("#delete-dialog").showModal()
  } },
  "#delete-dialog button": { click () { app.emit("track-delete", this.dataset.action) } },
  "#track-edit": { keyup () { if (this.value !== app.tracks[app.trackSelection]) app.emit("track-save") } },
  "#toggle-accidentals": { click () { $("#insert-accidental").classList.toggle("activeSelect") } },
  "#insert-accidental > *": { click () {
    const { value } = $("#track-edit"), editorEl = $("#track-edit"), selStart = editorEl.selectionStart;
    $("#track-edit").value = value.slice(0, selStart) + this.innerText + value.slice(editorEl.selectionEnd)
    if ($("#track-edit").value !== app.tracks[app.trackSelection]) app.emit("track-save")
    editorEl.setSelectionRange(selStart + 1, selStart + 1);
    editorEl.focus()
  } }
})
  </script>
  <noscript><h6>Only viewable with JavaScript enabled.</h6></noscript>
</body>
</html>