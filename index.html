<!doctype html>
<html>
<head>
  <title>Temperamental â‚ Microtonal music explorer</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='music, xenharmony, xenrhythm'>
  <meta name='description' content='Web app for composing, playing, and noodling on microtonal music.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
@font-face {
  font-family: HEJI2;
  src: url('fonts/HEJI2Text.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
  unicode-range: U+E260-E266, U+E2C0-E2FA;
  size-adjust: 150%;
  ascent-override: 0%;
  descent-override: 0% }
@font-face {
  font-family: Netto;
  src: url('fonts/NettoIcons.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
  ascent-override: 0%;
  descent-override: 0% }
@font-face {
  font-family: ArbutusSlab;
  src: url('fonts/ArbutusSlab-Regular.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap }

@media (min-aspect-ratio: 1) {
  body.menuActive { grid: "nav nav" auto "menu main" 1fr / min-content 1fr }
  menu { max-width: 50dvw }
  #track-editor > form > textarea {
    width: 20em;
    min-width: 10em }
  .interval-display, #mapping { max-width: calc(50dvw - 3.5em - 4px) } }
@media (max-aspect-ratio: 1) {
  body.menuActive { grid: "nav" auto "menu" min-content "main" auto / 100dvw }
  menu { max-height: calc(50dvh - 4.9em) }
  #track-editor > form > textarea {
    width: 100% !important;
    resize: vertical }
  .interval-display, #mapping { max-width: calc(100dvw - 3.5em - 4px) } }

html, body {
  height: 100dvh }
body, button, select, input, textarea { font: min(16px, 2.7dvw) HEJI2, ArbutusSlab, Netto }
body {
  margin: 0;
  background-color: #222;
  color: #ddd;
  display: grid;
  grid: "nav" auto "main" 1fr / 100dvw;
  overflow: hidden }
  nav {
    background-color: #222;
    grid-area: nav;
    display: flex;
    flex-flow: column;
    user-select: none }
    nav > * {
      padding: .5em;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
    #controls {
      display: grid;
      grid-template-columns: auto auto 1fr repeat(3, auto);
      grid-gap: 0 .5em }
      #controls > * { flex: max-content 0 }
      #controls > :nth-last-child(n+2),
      #volume > * { vertical-align: middle }
      #volume > input { max-width: 20dvw }
      #info {
        width: 100%;
        min-width: max-content;
        text-align: center }
        #edo-info::after { content: "EDO" }
        #limit-info::after { content: "-limit" }
      #fullscreen.active::before { content: "ğŸ—•" }
      #fullscreen:not(.active)::before { content: "ğŸ—–" }
    #controls:has(.activeControls) { grid-template-columns: auto auto 1fr repeat(4, auto) }
    #track-controls { display: none }
      #track-controls > * { margin-right: .5em }
      #track-controls.activeControls { display: flex }
        #track-play:not(.trackPlaying)::before { content: "Play âµ" }
        #track-play.trackPlaying::before { content: "Pause â¸" }
    nav:focus-within:not(:has(:is(#refresh, #panic, #fullscreen, #volume > input):focus)) > #dropdown,
    body.menuActive #dropdown { display: flex }
    #dropdown {
      display: none;
      background-color: #000 }
      #dropdown > :nth-last-child(n+2) { margin-right: 2em }
        #dropdown > * > * { vertical-align: middle }
      #track-select { flex: 1 }
  menu {
    background-color: #222;
    padding: 0;
    margin: 0;
    min-height: 0;
    display: none }
  body.menuActive > menu { display: block }
    menu > li { padding: .5em }
    menu > li:not(#breadcrumbs) {
      overflow-y: scroll;
      height: calc(100% - 3.6em);
      display: none }
    menu > li.activeMenu { display: list-item !important }
    #breadcrumbs {
      background-color: #ddd;
      color: #222;
      display: flex;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
      #breadcrumb-text { font-size: .8em }
      #breadcrumb-text::before { content: "// " }
      #breadcrumb-text > :nth-last-child(n+2)::after { content: " â€º " }
        #menu-actions > :nth-last-child(n+2) { margin-right: .5em }
    form {
      display: flex;
      flex-flow: row wrap;
      gap: 0 .6em }
      #track-editor > form > * { width: 100% }
      fieldset {
        display: flex;
        flex-flow: column;
        flex: auto }
        fieldset > * { padding: .3em }
          :is(#scale, #mapping) > * {
            display: block;
            margin-left: 1em }
            :is(.harmonic, .interval-cell) > button { cursor: pointer }
          #mapping {
            display: grid;
            gap: .3em;
            width: fit-content }
            .harmonic {
              grid-template-columns: subgrid;
              display: grid !important;
              grid-column: span 9;
              gap: .3em;
              align-items: center }
              .harmonic > :not(input) { text-align: end }
              .harmonic:not(.basis) > input, .harmonic.basis > span.steps,
              .harmonic.prime.power:not(.basis) > input.hcolour  { display: none }
              .hcolour {
                max-height: 6dvw;
                height: 100% }
              #error::after { content: "Â¢" }
          .choice {
            display: flex;
            flex-flow: row;
            gap: .5em }
          .choice input[type="radio"] { display: none }
          .choice > label {
            display: block;
            cursor: pointer }
          .choice > label:active {
            background-color: #ddd;
            color: #222 }
          .choice > label:has(input[type="radio"]:checked) { border-bottom: 1px solid }
          #interval-view {
            display: grid;
            grid: auto / auto auto 1fr;
            width: 100% }
            #interval-view > div { text-align: right }
          .interval-display { display: none }
          .choice:has(label#diamond-choice > input[type="radio"]:checked) ~ #diamond-wrapper,
          .choice:has(label#table-choice > input[type="radio"]:checked) ~ #ivtable-wrapper { display: block }
          .interval-display, #mapping { overflow-x: scroll }
            .interval-cell.activeEnharmonic {
              border-bottom: 1px solid;
              margin-bottom: -1px }
          #diamond {
            display: grid;
            grid-template-columns: 1fr repeat(var(--size), auto);
            grid-template-rows: repeat(var(--size), 2em);
            justify-items: end;
            width: max-content }
          #interval-table {
            display: grid;
            grid-template-columns: repeat(calc(var(--harms) + 1), auto);
            grid-template-rows: repeat(calc(var(--edo) + 1), minmax(0, min-content));
            gap: .5em;
            width: max-content }
            .interval-th {
              position: relative;
              display: grid;
              place-items: center }
              .table-border {
                position: absolute;
                pointer-events: none }
              .column-head > span::after { content: "-limit" }
              .column-head > .table-border {
                border-left: 1px solid #ddd8;
                width: calc(100% + .5em);
                align-self: start;
                height: var(--table-height) }
              .row-head > .table-border {
                border-top: 1px solid #ddd8;
                height: calc(100% + .5em);
                justify-self: start;
                width: var(--table-width);
                z-index: 2 }
            .interval-td {
              display: flex;
              flex-flow: column;
              gap: .5em;
              place-self: end / center;
              align-items: end }
            .interval { width: max-content }
              #table-unison {
                text-align: center;
                margin: -.25em -1px -.25em 0;
                background-color: #222;
                width: calc(100% - .25em);
                padding: .25em;
                z-index: 1 }
        #commas { display: flex }
          #loading-commas {
            display: none;
            order: 9999 }
          #loading-commas.activeLoading { display: block }
        #track-file {
          display: flex;
          flex-flow: row;
          margin-bottom: .5em }
          #track-file > :nth-last-child(n+2) { margin-right: .5em }
          #track-name { flex: 1 }
          #track-name > * {
            display: none;
            vertical-align: middle }
          #track-name-text { cursor: text }
          #track-name-text:empty::before {
            color: #666;
            content: "..." }
          #track-name:not(.editingTrackName) > #track-name-text,
          #track-name.editingTrackName > input { display: inline }
          #track-name-field.invalid { outline: 1px solid red }
          #track-file:not(.saved) > :is(#track-savestate, #track-delete) { display: none }
          #track-savestate.saving::before {
            content: "...";
            color: orange }
          #track-savestate:not(.saving)::before {
            content: "âœ“";
            color: lawngreen }
        #track-edit {
          max-width: calc(100dvw - 1.5em);
          height: 10em }
        #insert-accidental {
          display: none;
          margin-top: .5em;
          grid-template-columns: repeat(auto-fill, 3em);
          text-align: center;
          line-height: 3em;
          gap: .5em;
          justify-content: space-evenly }
        #insert-accidental.activeSelect {
          display: grid;
          height: 6.5em;
          overflow: scroll }
          #insert-accidental > * {
            display: inline-block;
            background-color: #fff2;
            border-radius: .5em;
            cursor: pointer }
  main {
    touch-action: none;
    background-color: #000;
    overflow: hidden }
    main.hover { cursor: pointer }
    canvas {
      transform: scale(.5);
      transform-origin: 0 0;
      /* mix-blend-mode: lighten; */
      background-size: cover;
      background-position-y: center;
      pointer-events: none }
  dialog { padding: 1em 0 }
    #dialog-prompt { padding: 0 1em }
    dialog > form { justify-content: space-evenly }
  </style>
</head>
<body>
  <nav tabindex="0">
    <div id="dropdown">
      <div id="keyboard-select">
        <span>Keyboard</span>
        <select></select>
        <button id="keyboard-settings-button" type="button">â›­</button>
      </div>
      <div id="track-select">
        <span>Track</span>
        <select>
          <option name="None">None</option>
          <hr>
          <option name="New">New</option>
        </select>
      </div>
      <button class="info" type="button">â„¹</button>
    </div>
    <div id="controls">
      <div id="volume">
        <span>Volume</span>
        <input type="range" min="0" max="100" step="1">
      </div>
      <div id="octaves">
        <span>Octaves</span>
        <input type="number" value="2" min="1" max="5" steps="1" size="2">
      </div>
      <div id="info">
        <span id="edo-info"></span>
        <span id="limit-info"></span>
      </div>
      <div id="track-controls">
        <button id="track-loop" type="button">Loop</button>
        <button id="track-play" type="button"></button>
      </div>
      <button id="refresh" type="button">Refresh</button>
      <button id="panic" type="button">Panic</button>
      <button id="fullscreen" type="button"></button>
    </div>
  </nav>
  <menu>
    <li id="breadcrumbs">
      <span id="breadcrumb-text"></span>
      <div id="menu-actions"></div>
    </li>
    <li id="keyboard-settings">
      <form>
        <fieldset>
          <legend>Shape</legend>
          <label id="gstep">Horizontal steps: <input type="number" min="1" step="1" size="4"></label>
          <label id="hstep">Diagonal steps: <input type="number" min="1" step="1" size="4"></label>
          <label id="orientation">Orientation:
            <select>
              <option value="">Choose</option>
            </select>
          </label>
          <label id="unit">Key size: <input type="number" min="5" step="1" size="5"> px</label>
        </fieldset>
        <fieldset>
          <legend>Note</legend>
          <label id="refNote">Tuning root note: <input type="number" min="0" step="1" size="4"></label>
          <label id="freqBasis">Tuning root frequency: <input type="number" min="10" max="40000" size="6"> Hz</label>
          <div id="scale">Scale:
            <label id="edo">Divisions of octave: <input type="number" min="1" step="1" max="270" size="4"></label>
            <output></output>
          </div>
        </fieldset>
        <fieldset>
          <legend>Harmonic mapping</legend>
          <label id="limit">Harmonic limit: <input type="number" value="9" min="3" step="2" size="3"></label>
          <label id="maxError">Maximum error: <input type="number" value="30" min="0" max="100" size="4"> Â¢</label>
          <div id="mapping"></div>
          <div id="interval-view" class="choice">
            <label id="diamond-choice"><input type="radio" name="interval-view" checked>Tonality diamond</label>
            <label id="table-choice"><input type="radio" name="interval-view">Interval table</label>
            <div>
              <span>Temper&shy;ament</span>
              <button id="generate-temperaments" type="button">ğŸ’¡</button>
            </div>
          </div>
          <div id="diamond-wrapper" class="interval-display"><div id="diamond"></div></div>
          <div id="ivtable-wrapper" class="interval-display"><div id="interval-table"></div></div>
        </fieldset>
        <fieldset>
          <legend>Waveform</legend>
          <label id="instrument">Output:
            <select>
              <option value="osc">Local</option>
              <option value="midi">MIDI</option>
            </select>
          </label>
          <label id="instrument-option">
            <span>Oscillator</span>
            <select>
              <option value="custom">Custom</option>
            </select>
            <button type="button">Choose</button>
          </label>
        </fieldset>
      </form>
    </li>
    <li id="temperaments">
      <form>
        <fieldset>
          <legend>Temperament</legend>
          <div id="commas">
            <div id="loading-commas">âŒ›</div>
          </div>
        </fieldset>
        <fieldset>
          <legend>Chords</legend>
        </fieldset>
      </form>
    </li>
    <li id="track-editor">
      <form>
        <div id="track-file">
          <div id="track-name">
            <span id="track-name-text"></span>
            <input id="track-name-field" type="text">
          </div>
          <span id="track-savestate"></span>
          <button id="toggle-accidentals" type="button">î‰¡</button>
          <button class="info" type="button">â„¹</button>
          <button id="track-delete" type="button">âœ—</button>
        </div>
        <textarea id="track-edit"></textarea>
        <div id="insert-accidental">
          <div>î‰ </div><div>î‰¡</div><div>î‰¢</div><div>î‰£</div><div>î‰¤</div><div>î‰¥</div><div>î‰¦</div>
          <div>î‹€</div><div>î‹</div><div>î‹‚</div><div>î‹ƒ</div><div>î‹„</div><div>î‹…</div><div>î‹†</div><div>î‹‡</div><div>î‹ˆ</div><div>î‹‰</div><div>î‹Š</div><div>î‹‹</div><div>î‹Œ</div><div>î‹</div><div>î‹</div><div>î‹</div><div>î‹</div><div>î‹‘</div><div>î‹’</div><div>î‹“</div><div>î‹”</div><div>î‹•</div><div>î‹–</div><div>î‹—</div><div>î‹˜</div><div>î‹™</div><div>î‹š</div><div>î‹›</div><div>î‹œ</div><div>î‹</div><div>î‹</div><div>î‹Ÿ</div><div>î‹ </div><div>î‹¡</div><div>î‹¢</div><div>î‹£</div><div>î‹¤</div><div>î‹¥</div><div>î‹¦</div><div>î‹§</div><div>î‹¨</div><div>î‹©</div><div>î‹ª</div><div>î‹«</div><div>î‹¬</div><div>î‹­</div>
        </div>
      </form>
    </li>
  </menu>
  <main>
    <canvas id="hex"></canvas>
  </main>
  <dialog id="delete-dialog">
    <div id="dialog-prompt">Delete track "<span id="delete-track-name"></span>"?</div>
    <form method="dialog">
      <button type="button" data-action="Cancel">Cancel</button>
      <button type="button" data-action="Delete">Delete</button>
    </form>
  </dialog>
  <template id="breadcrumb-level">
    <span></span>
  </template>
  <template id="menu-action">
    <button type="button"></button>
  </template>
  <template id="option">
    <option></option>
  </template>
  <template id="harmonic">
    <label class="harmonic">
      <span id="nth-harmonic"></span> harmonic: <input class="steps" type="number" step="1" size="4"><span class="steps"></span> steps, <span id="error"></span> error
      <button type="button">â–¶</button>
      <input class="hcolour" type="color">
    </label>
  </template>
  <template id="interval-cell">
    <div class="interval-cell">
      <span></span> (<span></span>, <span></span> steps) <button type="button">â–¶</button>
    </div>
  </template>
  <template id="interval-th">
    <div class="interval-th">
      <div class="table-border"></div>
      <span></span>
   </div>
  </template>
  <template id="interval-td">
    <div class="interval-td"> </div>
  </template>
  <template id="comma">
    <div class="comma">
      <span class="ratio"></span> = 1 (<span class="factorisation"></span>), size <span class="size"></span>
    </div>
  </template>
  <script src="js/machine.js"></script>
  <script>



//Utils

const
  group = (ar, cmp = (a, b) => a === b) => ar.reduce((a, v) => {
    const i = a.findIndex(vs => cmp(vs[0], v));  // quadratic in cmp
    return ~i ? a.with(i, a[i].concat([v])) : a.concat([[v]])
  }, []),
  comp = (...iv) => iv.map(ar => ar.reduce((n, [p, rad]) => n * p ** rad, 1));



// Utilities

class Common {
  static #allPrimes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 ]
  static #allPrimesBig = this.#allPrimes.map(BigInt)
  
  static versionCmp = (a, b) => {
    if (![a, b].every(s => s.match(/^\d+(?:\.\d+)*$/))) throw new Error("Version error: malformed version string");
    return [a, b].sort()[0] === a ? a === b ? 0 : -1 : 1
  }
  static between = (min, max, val) => val <= max && val >= min
  static clamp = (min, max, val) => (max >= min && Number(val) === val) ? Math.max(min, Math.min(max, val)) : undefined
  static lerp = (a, b, t) => a * (1 - t) + b * t
  static non2 = h => h / (h & (~--h))
  static gcd = (a, b) => !b ? a : this.gcd(b, a % b)
  static group = (ar, groupBy = x => x, mapBy = x => x) => ar.reduce((a, v) => {
    const k = groupBy(v);
    a[k] = (a[k] ?? []).concat([mapBy(v)]);
    return a
  }, {})
  static decomp = (...iv) => iv.map(r => { // use 2s?
    let ivh = this.non2(r), raw = [], res = new Map(), i = 1;
    while (ivh !== 1) {
      const p = this.#allPrimes[i];
      if (this.gcd(ivh, p) === 1) i++;
      else { raw.push(p); ivh /= p }
    }
    for (let [ k, v ] of Object.entries(this.group(raw))) res.set(parseInt(k), v.length)
    return res
  })
  static decompBig = (...iv) => iv.map(r => { // use 2s?
    let ivh = this.non2(r), raw = [], res = new Map(), i = 1;
    while (ivh !== 1n) {
      const p = this.#allPrimesBig[i];
      if (this.gcd(ivh, p) === 1n) i++;
      else { raw.push(p); ivh /= p }
    }
    for (let [ k, v ] of Object.entries(this.group(raw))) res.set(parseInt(k), v.length)
    return res
  })

  static scaleVolume = value => value && 10 ** (2 * (value / 100 - 1))
  static ordinal = (() => {
    const rule = new Intl.PluralRules("en-AU", { type: "ordinal" }),
          suf = new Map([ ["one", "st"], ["two", "nd"], ["few", "rd"], ["other", "th"] ]);
    return n => `${n}${suf.get(rule.select(n))}`
  })()

  static noteFromFactors = (() => {  // Any way to generalise? Use u/e26c and u/e26d ?
    const pythag = "FCGDAEB".split("").reduce((acc, key, i) => ({ ...acc, [i - 1]: key }), {}),
          hejiRatios = {
            5: [[[3, 4]], [[5, 1]]],
            7: [[], [[3, 2], [7, 1]]],
            11: [[[3, 1], [11, 1]], []],
            13: [[[3, 3]], [[13, 1]]],
            17: [[[3, 7]], [[17, 1]]],
            19: [[[3, 3], [19, 1]], []],
            23: [[[23, 1]], [[3, 6]]],
            29: [[[3, 2], [29, 1]], []],
            31: [[], [[31, 1]]],
            37: [[[37, 1]], [[3, 2]]],
            41: [[[41, 1]], [[3, 4]]],
            43: [[[3, 1], [43, 1]], []],
            47: [[47, 1], [[3, 6]]]
          };
    return factors => {
      let accid = {};
      factors = structuredClone(factors);

      // Factorise out commas
      structuredClone(factors).forEach((d, i) => {
        d.forEach(([p, rad]) => {
          if (p === 3) return;
          const tone = hejiRatios[p].findIndex(side => ~side.findIndex(([q]) => p === q));
          accid[p] = (1 - 2 * (i ^ tone)) * rad;
          hejiRatios[p].forEach((side, j) => side.forEach(([q, qrad]) => {
            const targetSide = i ^ j ^ !tone, k = factors[targetSide].findIndex(([r]) => q === r);
            ~k ? (factors[targetSide][k][1] += qrad * rad) : factors[targetSide].push([q, qrad * rad])
          }))
        })
      });

      // Normalise to Pythagorean key
      factors[1].forEach(([p, rad], i, dc1) => {
        const j = factors[0].findIndex(([q]) => p === q);
        if (!~j) return;
        const qrad = factors[0][j][1];
        if (rad > qrad) factors[1][i][1] -= qrad;
        else factors[1][i] = [];
        if (rad < qrad) factors[0][j][1] -= rad;
        else factors[0].splice(j, 1);
      });
      factors[1] = factors[1].filter(ar => ar.length);

      // Build string
      const tone = factors.findIndex(d => d.length),
            fifths = (1 - 2 * tone) * (~tone ? factors[tone][0][1] : 0),
            sharps = Math.floor((fifths + 1) / 7);
      let acstring = "", pref5 = () => "", prefNo5 = "";
      if (sharps < -2) {
        pref5 = n => ["", String.fromCodePoint(0xe2c1 + n), String.fromCodePoint(0xe2c0 + n)][(sharps === -3) - sharps % 3];
        prefNo5 = ["", String.fromCodePoint(0xe260), String.fromCodePoint(0xe264)][-sharps % 3];
        acstring = sharps === -3 && (5 in accid) ? String.fromCodePoint(0xe264) : String.fromCodePoint(0xe266).repeat(Math.floor(-sharps / 3))
      } else if (sharps > 2) {
        pref5 = n => sharps % 2 ? String.fromCodePoint(0xe2c3 + n) : String.fromCodePoint(0xe2c4 + n);
        prefNo5 = sharps % 2 ? String.fromCodePoint(0xe265) : String.fromCodePoint(0xe263).repeat(2);
        acstring = String.fromCodePoint(0xe263).repeat(Math.floor((sharps - 1) / 2) - !(5 in accid))
      } else {
        pref5 = n => String.fromCodePoint(0xe2c0 + n + (sharps + 2) % 5);
        prefNo5 = sharps === 0 ? "" : String.fromCodePoint(0xe260 + (sharps + 6) % 5)
      }
      if (5 in accid) {
        const arr = accid[5];
        if (Math.abs(arr) <= 3) {
          const arrowsOffset = 5 * (arr > 0 ? 2 * arr - 1 : -2 - 2 * arr);
          acstring += pref5(arrowsOffset);
        } else {
          const arrowsOffset = 5 * (arr > 0 ? 2 * (arr % 3) - 1 : 2 * (-arr % 3) - 2);
          acstring += (arrowsOffset < 0 ? "" : pref5(arrowsOffset)) + String.fromCodePoint(0xe2d6 + 5 * (arr > 0)).repeat(Math.floor(Math.abs(arr) / 3))
        }
      } else acstring = prefNo5 + acstring;
      if (7 in accid) {
        const sep = accid[7];
        acstring += String.fromCodePoint(0xe2e0 + (sep > 0)).repeat(Math.floor((Math.abs(sep) - 1) / 2)) + 
          String.fromCodePoint(0xe2de + (sep > 0) + 2 * Math.abs((sep + 1) % 2));
      }
      Object.keys(hejiRatios).slice(2).forEach((p, i) => acstring += accid[p] > 0 ?
        String.fromCodePoint((i < 7 ? 0xe2e3 : 0xee41) + 2 * i).repeat(accid[p]) :
        String.fromCodePoint((i < 7 ? 0xe2e2 : 0xee40) + 2 * i).repeat(-accid[p]));
      return {
        accid: { "3": fifths, ...accid },
        string: pythag[(((fifths + 1) % 7 + 7) % 7) - 1] + acstring
      };
    }
  })()
}



// Harmonic mapping

class HarmonicMapping {

  // Static
  static #isPrime (pdec) {
    let sum = 0;
    for (let [, rad] of pdec) sum += rad;
    return sum === 1
  }
  static #transp = mat => Array(mat[0].length).fill()
    .reduce((row, _, i) => row.concat([mat.reduce((cols, row) =>
      cols.concat([row[i]]), [])]), [])

  static #invDet (mat, decs, ps) { // TODO: use leading value
    const
      rows = mat.length, cols = mat[0].length,
      aug = mat.map((row, i) => row.concat(Array(rows).fill(0).with(i, 1)));
    if (mat.length === 0) return null;
    let det = 1, lcm = 1;
    for (let i = 0; i < rows; i++) {
      if (aug[i][i] === 0) {
        let m = 0;
        for (m = i + 1; m < rows; m++) if (aug[m][i] !== 0) {
          ([ aug[m], aug[i], decs[m], decs[i] ] = [ aug[i], aug[m], decs[i], decs[m] ]);
          for (let j = 0; j < rows; j++)
            ([ aug[j][cols + m], aug[j][cols + i] ] = [ aug[j][cols + i], aug[j][cols + m] ]);
          det = -det;
          break
        }
        if (m === rows) return {}
      }
      const val0 = aug[i][i];
      lcm = val0 / Common.gcd(lcm, val0);
      for (let j = 0; j < rows; j++) if (i !== j) {
        const val1 = aug[j][i], c = Common.gcd(val0, val1);
        if (i < ps.length) det *= val0 / c;
        for (let k = 0; k < rows + cols; k++)
          aug[j][k] = (val0 * aug[j][k] - val1 * aug[i][k]) / c;
      }
    }
    mat = this.#transp(aug);
    det = mat.slice(0, ps.length).reduce((acc, row, i) => acc * row[i], 1) / det
    const degen = aug.findIndex(row => !row.slice(0, cols).some(x => x));
    if (~degen) aug.splice(degen);
    return {
      det, lcm,
      mods: aug.slice(0, ps.length).map((row, i) => [ ps[i], lcm / row[i] ]),
      inv: mat.slice(cols, cols + ps.length).map((row, i) => [ decs[i][0], row ]),
      verify: mat.slice(aug.length, cols).map((vec, i) => [ ps[aug.length + i], vec ])
    }
  }

  static * #subsets (args, { minlength = 1, maxlength = args.length } = {}) {
    for (let n = minlength; n <= maxlength; n++) {
      let max = -1, counter = [];
      while (max + n <= args.length) {
        if (~max) yield counter.map(k => args[k]);
        const i = counter.findLastIndex((j, k) => j < max + k);
        if (~i) counter[i]++;
        else counter = Array(n).fill().map((_, j) => j).with(-1, n + max++);
      }
    }
  }

  // Instance
  #keyboard; #scale
  rawHarmonicList; harmonicList = new Map()
  nonHarmonics = new Set() // TODO: Cached blacklist
  indexPrimes = []; primes = []; params = []; index = []; verify = () => true; stepsBasis
  #properIntervalSet = new IntervalSet(this); intervalSet = new IntervalSet(this)
  ready = false
  mask // TODO: for temperings

  constructor ({ keyboard, scale, hmap }) { // Map([ odd, number ])
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Mapping error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (!(Scale.prototype.isPrototypeOf(scale))) throw new Error("Mapping error: must provide Scale object");
    this.#scale = scale;
    const { edo } = keyboard, { maxError } = scale;
    if (!Map.prototype.isPrototypeOf(hmap) || [ ...hmap ].some(v => v.some(u => typeof u !== "number") ||
      v.some(u => u % 1) || v[0] < 3 || v[0] > app.maxHarmonic || v[0] % 2 !== 1 || v[1] < 0 || v[1] > edo)) throw new Error("Mapping error: bad interval-step mapping");
    const harr = [ ...hmap ];

    const
      decs = Common.decomp(...harr.map(([h]) => h)).map((pdec, i) => [ harr[i][0], pdec ]),
      { true: primeDecs = [], false: compositeDecs = [] } = Common.group(
        decs, ([, a]) => HarmonicMapping.#isPrime(a)),
      { true: simpleDecs = [], false: residueDecs = [] } = Common.group(
        compositeDecs.map(([ h, pdec ]) => [ h, [...pdec].filter(([p]) => !~primeDecs.findIndex(([q]) => q === p)) ]),
        ([ , pp ]) => pp.length === 0, ([p]) => compositeDecs.find(([q]) => q === p)),
      ps = [ ...residueDecs.reduce((acc, [, pdec]) => {
        for (let [p] of pdec) acc.add(p);
        return acc
      }, new Set()).values() ].sort((a, b) => a > b),
      { true: residuePrimeDecs = [], false: simplePrimeDecs = [] } = Common.group(
        primeDecs, ([p]) => ps.includes(p)),
      residue = residuePrimeDecs.concat(residueDecs);
      
    this.indexPrimes = ps;
    this.primes = simplePrimeDecs.map(([h]) => h);

    simplePrimeDecs.forEach(([h]) => this.harmonicList.set(h, new Harmonic(this, h,
      (...params) => params[ simplePrimeDecs.findIndex(([p]) => p === h) ]), true));
    simpleDecs.forEach(([h, hdec]) => {
      const
        just = Math.log2(h) % 1,
        steps = [ ...hdec ].reduce((acc, [p, rad]) => acc + hmap.get(p) * rad, 0) % edo,
        error = (steps / edo - just) * 1200;
      if (Math.abs(error) >= maxError || steps + edo * maxError / 1200 < 1 ||
        steps - edo * maxError / 1200 > edo - 1) hmap.delete(i);
      else this.harmonicList.set(h, new Harmonic(this, h, {}, true))
    });

    if (residue.length) {
      let system, best = 0, dims = -1;
      const cols = ps.length;
      for (let hs of HarmonicMapping.#subsets(residue)) { // TODO: memoise?
        const mat = [], rows = hs.length;
        for (let [, pdec] of hs) mat.push(ps.map(p => pdec.get(p) ?? 0));
        if (rows < cols) mat.splice(Infinity, Infinity, ...Array(cols - rows).fill().map(() => mat.at(-1).slice()));
        if (rows > cols) mat.forEach((row, i) => row.splice(Infinity, Infinity, ...(i < cols ? Array(rows - cols).fill(0) :
          Array(rows - cols).fill(0).with(i - cols, -1))));
        const { inv, det } = HarmonicMapping.#invDet(mat, hs, ps);
        if (det === undefined) continue;
        if ((best !== 0 && Math.abs(det) < Math.abs(best)) || (best === 0 && (det !== 0 || inv.length > dims)))
          ([system, best, dims] = [hs, det, inv.length]);
        if (Math.abs(det) === 1) break;
      }
      const
        hs = system.reduce((acc, [h], i) => { // TODO: nicer ordering
          const j = acc.findIndex(([p]) => p === h);
          ([ acc[i], acc[j] ] = [ acc[j], acc[i] ]);
          return acc
        }, residue),
        rows = hs.length, mat = [];
      for (let [, pdec] of hs) mat.push(ps.map(p => pdec.get(p) ?? 0));
      if (rows > cols) mat.forEach((row, i) => row.splice(Infinity, Infinity, ...(i < cols ? Array(rows - cols).fill(0) :
        Array(rows - cols).fill(0).with(i - cols, -1))));

      // TODO: Can I use det to exclude harmonics before running the counting function?
      const { mods, inv, det, lcm, verify } = HarmonicMapping.#invDet(mat, hs, ps);

      this.index = system.map(([h]) => h);
      this.params = residue.filter(([d]) => !~system.findIndex(([h]) => h === d));

      // if underdetermined, the params must be provided
      // if overdetermined, these components must be verified
      this.verify = (...primeVec) => {
        const
          dps = primeVec.slice(0, residue.length),
          vps = primeVec.slice(residue.length);
        return verify.every(([p, vec], i) => dps.reduce((a, x, j) => a + x * vec[j] * (mods[j]?.[1] ?? 1), 0) === vps[i])
      };

      inv.forEach(([h, vec]) => this.harmonicList.set(h, new Harmonic(this, h,
        (...params) => {
          const rawNum = hs.reduce((a, _, i) => a + (params[i] ?? 0) * vec[i] * (mods[i]?.[1] ?? 1), 0);
          return rawNum % lcm ? null : rawNum / lcm // Null means failure
        }), true));
      residue.filter(([d]) => !~inv.findIndex(([h]) => h === d))
        .forEach(([h, dec]) => {
          if (~residueDecs.findIndex(([p]) => p === h)) {
            const
              just = Math.log2(h) % 1,
              primeVec = this.indexPrimes.map(p => dec.get(p) ?? 0),
              steps = this.index.reduce(
                (count, h) => count + hmap.get(h) * this.harmonicList.get(h).countingFn(...primeVec),
                this.primes.reduce((count, p) => count + hmap.get(p) * (dec.get(p) ?? 0), 0)) % edo,
              error = (steps / edo - just) * 1200;
            if (Math.abs(error) >= maxError || steps + edo * maxError / 1200 < 1 ||
              steps - edo * maxError / 1200 > edo - 1) {
              hmap.delete(i);
              return
            }
          }
          this.harmonicList.set(h, new Harmonic(this, h, {}, true))
      });
    }
    this.rawHarmonicList = hmap;

    // Generate all intervals
    const withUnison = [1].concat(decs.map(([h]) => h));
    for (let n of withUnison) for (let d of withUnison) {
      const
        params = Array(this.params.length).fill(0),
        iv = new Interval({ keyboard: this.#keyboard, mapping: this, n, d, params, isProper: true });
      this.#properIntervalSet.add(iv);
      this.intervalSet.add(iv)
    }
    this.setSteps(new Map(hmap));
    this.ready = true
  }

  decomp (n, d) { //Null is failure
    const pdec = Common.decomp(n)[0], dec = [];
    if (d) {
      for (let [p, rad] of Common.decomp(d)[0]) if (pdec.has(p)) {
        const nrad = pdec.get(p);
        if (nrad === rad) pdec.delete(p);
        else pdec.set(p, nrad - rad)
      } else pdec.set(p, -rad)
    }
    const { params, index, indexPrimes, primes, harmonicList, verify } = this;
    for (let p of primes) {
      if (!pdec.has(p)) continue;
      else dec.push([ p, pdec.get(p) ]);
      pdec.delete(p)
    }
    const primeVec = indexPrimes.map(p => pdec.get(p) ?? 0);
    for (let [p] of pdec) if (!indexPrimes.includes(p)) return null;
    if (!verify(...primeVec)) return null;
    return index.reduce((fn, h) => (...params) => {
      const acc = fn(...params);
      if (acc === null) return null;
      const res = harmonicList.get(h).countingFn(...primeVec, ...params);
      return res === null ? null : res === 0 ? acc : acc.concat([[ h, res ]])
    }, () => dec)
  }

  getProperIntervals () { return [ ...this.#properIntervalSet ] }
  addInterval (interval) { intervalSet.add(interval) }

  setSteps (stepsMap) {  // Map([ harmonic, steps ])
    const { index } = this, { edo } = this.#keyboard, stepsBasis = new Map(stepsMap);
    if (index.some(h => {
      const s = stepsMap.get(h);
      return s === undefined || s < 0 || s % 1
    })) throw new Error("Could not set steps for mapping");
    for (let [h, steps] of stepsMap) stepsBasis.set(h, steps + edo * Math.floor(Math.log2(h)));
    this.stepsBasis = stepsBasis
  }

}

class Harmonic {
  #mapping; h; isBasis; countingFn = null; decomp; primeDecomp
  constructor (mapping, h, countingFn, isInitial = false) {
    const existing = mapping.harmonicList.get(h);
    if (existing) return existing;
    this.#mapping = mapping;
    this.h = h;
    this.primeDecomp = [ ...Common.decomp(h)[0] ];
    if (h === 1) { // Unison
      this.isBasis = false;
      this.decomp = () => []
    } else {
      const
        { harmonicList, nonHarmonics, index, primes, ready } = mapping,
        doErr = () => { throw new Error("Harmonic not in mapping") };
      if (ready) {
        decomp = mapping.decomp(h);
        if (nonHarmonics.has(h) || decomp === null) doErr();
        this.isBasis = false;
        this.decomp = decomp
      } else {
        if (this.isBasis = primes.concat(index).includes(h)) this.countingFn = countingFn;
        else this.decomp = mapping.decomp(h)()
      }
    }

  }
}

class Interval {
  #keyboard; #mapping; n; d; params; octave; fraction; decomp; noteSpelling; isProper
  octaveAdjust; splitDecomp
  constructor ({ keyboard, mapping, n, d, params = [], isProper = false }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Interval error: must provide Keyboard object");
    if (!(HarmonicMapping.prototype.isPrototypeOf(mapping))) throw new Error("Interval error: must provide HarmonicMapping object");
    const c = Common.gcd(n, d);
    n = n / c;
    d = d / c;
    if (mapping.intervalSet.hasRatio(n, d)) return mapping.intervalSet.getRatio(n, d); // TODO withOctave
    this.#keyboard = keyboard;
    this.#mapping = mapping;
    this.n = Common.non2(n);
    this.d = Common.non2(d);
    const octave = this.octave = Math.floor(Math.log2(n) - Math.log2(d));
    this.octaveAdjust = octave;
    this.params = params;
    this.isProper = isProper;
    this.fraction = [ octave < 0 ? n << -octave : n, octave > 0 ? d << octave : d ];
    this.decomp = mapping.decomp(n, d)(...params);

    const pdec = Common.decomp(n).concat([ new Map() ]);
    if (d) {
      for (let [p, rad] of Common.decomp(d)[0]) if (pdec[0].has(p)) {
        const nrad = pdec[0].get(p);
        if (nrad <= rad) pdec[0].delete(p);
        if (nrad > rad) pdec[0].set(p, nrad - rad);
        else if (nrad < rad) pdec[1].set(p, rad - nrad);
      } else pdec[1].set(p, rad)
    }
    this.splitDecomp = pdec.map(m => [ ...m ].sort(([a], [b]) => a > b));
    this.noteSpelling = Common.noteFromFactors(this.splitDecomp)
  }
  withOctave (n) {
    this.octaveAdjust = n;
    // TODO: set fraction?
    return this
  }
  steps () {
    const { stepsBasis } = this.#mapping, { edo } = this.#keyboard;
    return this.decomp.reduce((acc, [p, rad]) => acc + stepsBasis.get(p) * rad, 0) - this.octaveAdjust * edo
  }
}

class IntervalSet {
  #mapping; #rawMap // Map([ denominator, Map([ numerator, interval ]) ])
  constructor (mapping, intervalList = []) {
    this.#mapping = mapping;
    this.#rawMap = new Map();
    for (let interval of intervalList) this.add(interval)
  }
  add (interval) {
    const
      { harmonicList } = this.#mapping, { n, d } = interval,
      dMap = this.#rawMap.get(d) ?? this.#rawMap.set(d, new Map()).get(d);
    if (!dMap.has(n)) dMap.set(n, interval)
  }
  has (interval) {
    const { n, d } = interval;
    return Boolean(this.#rawMap.get(d)?.has(n))
  }
  hasRatio (n, d) {
    const c = Common.gcd(n, d);
    return Boolean(this.#rawMap.get(Common.non2(d / c))?.has(Common.non2(n / c)))
  }
  get (interval) {
    const { n, d } = interval;
    return this.#rawMap.get(d)?.get(n)
  }
  getRatio (n, d) {
    const c = Common.gcd(n, d), iv = this.#rawMap.get(Common.non2(d / c))?.get(Common.non2(n / c));
    if (iv === undefined) return iv;
    return iv.withOctave(-Math.log2(d * iv.n / n / iv.d))
  }
  * [ Symbol.iterator ] () { for (let [g, s] of this.#rawMap) for (let [h, iv] of s) yield iv }
}



// Keyboard grid

class HexGrid { // TODO: set w, h, theta within HexGrid
  static mod = (n, m) => ((n % m) + m) % m

  #keyboard
  w = 0; h = 0; c; unit; r; octLen
  gstep; hstep; orientations; theta = 0
  orientation
  #hexes = new Map(); #edges; #notes
  #active = new Map() // Map([hex, Set(id)])
  #bgImgCache

  constructor ({ keyboard, gstep, hstep, unit, orientation }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("HexGrid error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (typeof gstep !== "number" || gstep < 1 || gstep > app.maxEdo || gstep % 1 ||
      typeof hstep !== "number" || hstep < 1 || hstep > app.maxEdo || hstep % 1) throw new Error("Keyboard error: bad grid steps");
    if (typeof unit !== "number" || unit < 5 || unit > 1e4) throw new Error("Keyboard error: bad button size");
    if (!("length" in orientation) || orientation.length !== 2 || orientation.some(v => v < 0 || v > app.maxEdo || v % 1) ||
      orientation[0] * gstep + orientation[1] * hstep !== keyboard.edo) throw new Error("Keyboard error: bad orientation");
    this.gstep = gstep;
    this.hstep = hstep;
    this.genOrientations();
    this.setOrientation(...orientation);
    this.unit = unit;
    this.r = this.unit * 2
  }

  #newHex (g, h, isGhost) {
    const row = this.#hexes.get(g) ?? this.#hexes.set(g, new Map()).get(g),
          hex = new HexButton({ keyboard: this.#keyboard, hexGrid: this, g, h, isGhost });
    row.set(h, hex);
    return hex
  }

  getHex (g, h) { return this.#hexes.get(g)?.get(h) }
  hasHex (g, h) { return this.#hexes.get(g)?.has(h) ?? false }

  * [Symbol.iterator] () { for (let [ , row ] of this.#hexes) for (let [ , hex ] of row) yield hex }

  addToActive (hex, id) {
    const active = this.#active;
    active.set(hex, (active.get(hex) ?? new Set()).add(id))
  }
  removeFromActive (hex, id) {
    const active = this.#active, ids = active.get(hex);
    if (!ids) return;
    ids.delete(id);
    if (ids.size === 0) active.delete(hex)
  }

  genOrientations () {
    const { gstep, hstep } = this, { edo } = this.#keyboard, res = [];
    for (let y = 0; y <= edo / hstep; y++) {
      const x = (edo - hstep * y) / gstep;
      if (x === Math.floor(x)) res.push ([ x, y ])
    }
    this.orientations = res;
  }
  setOrientation (g, h) {
    this.orientation = [ g, h ];
    const { unit, w } = this, x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5;
    this.theta = Math.atan(y / x)
  }
  setLattice ({ gstep, hstep }) {
    Object.assign(this, { gstep, hstep });
    this.genOrientations();
    const
      { orientations } = this,
      orientation = orientations.find(([g, h]) => g + h === 7) || orientations[0];
    if (!orientation) return false;
    this.setOrientation(...orientation)
    return true
  }

  updateGrid (force) {
    if (this.#notes && !force) return;
    const
      { gstep, hstep, c, w, octLen, orientation: [ g, h ] } = this,
      { edo } = this.#keyboard;

    // Central line
    this.#hexes = new Map();
    this.#edges = new Set([this.#newHex(0, 0, false)]);
    this.#notes = new Set([0]);
    let left = .5, right = .5, focus = [ [0, 0], [0, 0] ];
    for (let i = 1; i <= g + h; i++) {
      if (left / i <= h / (g + h)) { left++; focus[0][1]++ } else focus[0][0]++;
      if (right / i < h / (g + h)) { right++; focus[1][1]++ } else focus[1][0]++;
      this.#edges.add(this.#newHex(...focus[0], false));
      this.#notes.add(focus[0][0] * gstep + focus[0][1] * hstep);
      if (focus[0].every((v, i) => v === focus[1][i])) continue
      this.#edges.add(this.#newHex(...focus[1], false));
      this.#notes.add(focus[1][0] * gstep + focus[1][1] * hstep)
    }

    // One octave
    const rank = (g, h) => HexGrid.mod(g * gstep + h * hstep, edo),
          dev = coord => Math.abs(this.h / 2 - HexButton.centre(...coord, this)[1]);
    this.fillGrid({
      candidate: (g0, h0) => Common.between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(rank(g0, h0)),
      filter: hexes => group(hexes, ([a, b], [c, d]) => rank(a - c, b - d) === 0)
        .map(enhs => enhs.sort((a, b) => dev(a) > dev(b))[0]),
      isGhost: () => false
    });

    // Two octaves
    this.#notes = new Set();
    this.fillGrid({
      candidate: (g0, h0) => Common.between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(rank(g0, h0)),
      filter: hexes => group(hexes, ([a, b], [c, d]) => rank(a - c, b - d) === 0)
        .filter(([[g0, h0]]) => !this.#notes.has(rank(g0, h0)))
        .map(enhs => enhs.sort((a, b) => dev(a) > dev(b))[0]),
      isGhost: () => true
    });

    // Fill to sides
    const home = [ ...this ];
    this.fillGrid({
      candidate: (g0, h0) => {
        const homeEquiv = ~home.findIndex(hex => {
                const [ baseG, baseH ] = hex.getCoord();
                return (baseG - g0) * h === (baseH - h0) * g // require gcd(g, h) === 1
              });
        return homeEquiv && HexButton.vertices(g0, h0, this).some(([ px, py ]) =>
          px > 0 && px < this.w && py > 0 && py < this.h)
      },
      isGhost: (g0, h0) => home.find(hex => {
        const [ baseG, baseH ] = hex.getCoord();
        return (baseG - g0) * h === (baseH - h0) * g
      }).isGhost
    });

    // Notes
    for (let hex of this) if (!hex.isGhost) {
      const
        [ octave, rank ] = hex.note(),
        note = this.#keyboard.scale.addNote({ octave, rank });
      if (octave === 0) note.getKey().setHome(hex)
    }
  }

  async fillGrid ({ candidate, filter = x => x, isGhost }) {
    let viewEdges = new Set([ ...this.#edges ]);
    while (viewEdges.size > 0) {
      let newViewEdges = new Map(), removeViewEdges = new Set(), newNotes = new Set();
      for (let hex of viewEdges) {
        let remove = true;
        for (let [g, h] of hex.neighbours()) {
          const thisHex = this.getHex(g, h);
          if (thisHex) { if (viewEdges.has(thisHex)) removeViewEdges.add(thisHex) }
          else if (candidate(g, h)) {
            newViewEdges.get(g)?.add(h) ?? newViewEdges.set(g, new Set([h]));
            newNotes.add(HexGrid.mod(g * this.gstep + h * this.hstep, this.#keyboard.edo));
          } else remove = false;
        }
        removeViewEdges.add(hex)
        if (remove) this.#edges.delete(hex)
      }
      filter([ ...(function * () {
        for (let [g, s] of newViewEdges) for (let h of s) yield [g, h]
      })() ]).forEach(([g, h]) => {
        const nextHex = this.#newHex(g, h, isGhost(g, h));
        this.#edges.add(nextHex);
        viewEdges.add(nextHex)
      });
      removeViewEdges.forEach(hex => viewEdges.delete(hex));
      this.#notes = new Set([ ...this.#notes, ...newNotes ])
    }
  }

  rotate (x, y, rev = false) {
    const cx = this.w / 2, cy = this.h / 2, theta = rev ? -this.theta : this.theta,
          cos = Math.cos(theta), sin = Math.sin(theta);
    return [ cos * (x - cx) + sin * (y - cy) + cx, cos * (y - cy) - sin * (x - cx) + cy ]
  }

  getCoord (x, y) {
    const { r, w: width, h: height, c } = this;
    ([ x, y ] = this.rotate(x * 2 + c, y * 2, true));
    const a = (x - width / 2) / r / Math.sqrt(3) * 2,
          b = (y - height / 2) / r * 2,
          band = Math.floor(Math.floor((b + 1) / 3));
    if (((Math.floor(b % 3)) + 3) % 3 === 1) {
      const clampedA = ((a % 1) + 1) % 1, clampedB = ((b % 1) + 1) % 1,
            topLeft = clampedA + clampedB > 1, bottomLeft = clampedA < clampedB,
            h = 2 * Math.floor((b + 4) / 6), g = Math.floor((a - h) / 2);
      if (band % 2) return Math.floor(a) % 2 ? [ g + 1, h - !topLeft ] : [ g + !bottomLeft, h - !bottomLeft ];
      else return Math.floor(a) % 2 ? [ g + !bottomLeft, h + bottomLeft ] : [ g, h + topLeft ]
    } else return [ Math.floor((a - band + 1) / 2), band ]
  }

  // TODO urgent: needs BigInt Interval
  classifyKeys (force) {
    if (this.#notes && !force) return;
    const 
      { scale, edo } = this.#keyboard, { mapping } = scale,
      { primes, indexPrimes, index, intervalSet, harmonicList, rawHarmonicList } = mapping,
      bases = primes.map(p => [ p, p ])
        .concat(indexPrimes.map(p => [ p, index.find(h => harmonicList.get(h).primeDecomp.some(([q]) => q === p)) ]))
        .sort(([a], [b]) => a > b).map(([ , h ]) => intervalSet.getRatio(h, 1));
    let i = edo - 1, full, prev, k = 0, result = Array(edo).fill(), prevResult,
        ivset = new IntervalSet(mapping, mapping.getProperIntervals()), prevIvset;
    result[0] = [[[], []]];
    for (let basis of bases) {
      const [ pn, pd ] = basis.fraction.map(Common.non2), pstep = basis.steps();
      prevIvset = new IntervalSet(mapping, ivset);
      full = i;
      prev = null;
      while (i > 0 && (i !== prev || i === full) && rawHarmonicList.size) {
        full = null;
        prev = i;
        prevResult = structuredClone(result);
        for (let iv of prevIvset) {
          const [ n, d ] = iv.fraction.map(Common.non2), step = iv.steps();
          let s = HexGrid.mod(step + k * pstep, edo);
          if (prevResult[s] === undefined && mapping.decomp(n * pn ** k, d * pd ** k)()) {
            const newIv = new Interval({ keyboard: this.#keyboard, mapping, n: n * pn ** k, d: d * pd ** k });
            (result[s] ??= (i--, [])).push(newIv.splitDecomp);
            ivset.add(newIv)
          }
          s = HexGrid.mod(step - k * pstep, edo);
          if (k > 0 && prevResult[s] === undefined && mapping.decomp(n * pd ** k, d * pn ** k)()) {
            const newIv = new Interval({ keyboard: this.#keyboard, mapping, n: n * pd ** k, d: d * pn ** k });
            (result[s] ??= (i--, [])).push(newIv.splitDecomp);
            ivset.add(newIv)
          }
        }
        k++
      }
      if (i <= 0) break;
      k = 1
    }
    for (let iv of ivset) mapping.intervalSet.add(iv);
    for (let hex of this) {
      const
        [ octave, rank ] = hex.note(), labels = [],
        scaleKey = scale.getKey(rank),
        note = scaleKey.addNote(octave);
      hex.setNote(note);
      if (result[rank]) for (let i = 0, ivs = result[rank]; i < ivs.length; i++) {
        const { accid, string: label } = Common.noteFromFactors(ivs[i]);
        let keyClass = Common.between(6, 10, HexGrid.mod(accid[3], 12)) ? "black" : "white";
        const ot = ivs[i][0].findLast(([p]) => p !== 3);
        if (ot) keyClass += ot[0] + "o";
        const ut = ivs[i][1].findLast(([p]) => p !== 3);
        if (ut) keyClass += ut[0] + "u";
        labels.push({ label, keyClass, interval: ivs[i] })
      }
      if (!scaleKey.getLabels().length) scaleKey.setLabels(labels)
    }
  }

  redraw (force) {
    const { gridctx, canvas } = app.state(), { width, height } = canvas;
    this.updateGrid(force);
    this.classifyKeys(force);
    gridctx.fillStyle = "#000000";
    gridctx.fillRect(0, 0, width, height);
    for (let hex of this) hex.colour();
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(new Blob([blob]));
      canvas.style.backgroundImage = `url('${url}'), url('${this.#bgImgCache}')`;
      this.#bgImgCache = url
    })
  }

  colour () {
    const { gridctx, canvas } = app.state(), { width, height } = canvas;
    gridctx.clearRect(0, 0, width, height);
    for (let [hex] of this.#active) hex.colour({ bgColour: Keyboard.noteColours.active })
  }
}

class HexButton {
  static #colourMix = (hc1, hc2, t) => {
    if (![hc1, hc2].every(hc => hc.match(/#\p{Hex_Digit}{6}/ug))) return null;
    const [r1, g1, b1] = hc1.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
    const [r2, g2, b2] = hc2.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
    return "#" + [[r1, r2], [g1, g2], [b1, b2]].reduce((a, [l, r]) => a + Math.round(Common.lerp(l, r, t)).toString(16).padStart(2, "0"), "")
  }
  static #contrast = hc => {
    if (!hc.match(/#\p{Hex_Digit}{6}/ug)) return null;
    const [r, g, b] = hc.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
    return r * .299 + g * .587 + b * .114 >= 128 ? "#222222" : "#dddddd"
  }

  static vertices (g, h, grid) {
    const { r, w, h: ht, c } = grid, x = w / 2, y = ht / 2, k = .5 * Math.sqrt(3),
          origin = [
            [ x, y - r ], [ x - r * k, y - r / 2 ], [ x - r * k, y + r / 2 ],
            [ x, y + r ], [ x + r * k, y + r / 2 ], [ x + r * k, y - r / 2 ]
          ];
    return origin.map(([ a, b ]) => {
      const [ rx, ry ] = grid.rotate(
              Math.floor(a + r * k * (h + 2 * g)),
              Math.floor(b + 1.5 * r * h)
            );
      return [ rx - c, ry ]
    })
  }
  static centre (g, h, grid) {
    const { r, w: width, h: height, c } = grid, k = .5 * Math.sqrt(3),
          [ rx, ry ] = grid.rotate(
            Math.floor(width / 2 + r * k * (h + 2 * g)),
            Math.floor(height / 2 + 1.5 * r * h)
          );
    return [ rx - c, ry ]
  }

  #keyboard; #hexGrid; #g; #h; #note; isGhost
  constructor ({ keyboard, hexGrid, g, h, isGhost = false }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("HexButton error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (!(HexGrid.prototype.isPrototypeOf(hexGrid))) throw new Error("HexButton error: must provide HexGrid object");
    this.#hexGrid = hexGrid;
    this.#g = g;
    this.#h = h;
    this.isGhost = isGhost
  }
  vertices () { return HexButton.vertices(this.#g, this.#h, this.#hexGrid) }
  centre () { return HexButton.centre(this.#g, this.#h, this.#hexGrid) }

  neighbours () {
    const g = this.#g, h = this.#h;
    return [
      [ g - 1, h ], [ g, h - 1 ], [ g + 1, h - 1 ],
      [ g + 1, h ], [ g, h + 1 ], [ g - 1, h + 1 ]
    ]
  }

  getCoord () { return [ this.#g, this.#h ] }

  note () { // TODO: rename
    const n = this.#g * this.#hexGrid.gstep + this.#h * this.#hexGrid.hstep, { edo } = this.#keyboard;
    return [ Math.floor(n / edo), (n % edo + edo) % edo ]
  }
  setNote (note) { this.#note = note }

  colour ({ bgColour, ctx } = {}) {
    ctx ??= app.state().gridctx;
    const
      { noteColours } = Keyboard,
      [ colourBase, oharm, uharm ] = this.#note.getKey().getLabel().keyClass
        ?.match(/(black|white)(?:(\d{1,2})o)?(?:(\d{1,2})u)?/)?.slice(1) ?? [],
      vertices = this.vertices(), { isGhost } = this,
      drawHex = c => {
        ctx.beginPath();
        ctx.moveTo(...vertices[5]);
        for (let [ x, y ] of vertices) ctx.lineTo(x, y);
        ctx.strokeStyle = isGhost ? c : "#dddddd";
        ctx.fillStyle = isGhost ? "#00000000" : c;
        ctx.lineWidth = isGhost ? 6 : 1;
        ctx.fill();
        ctx.stroke();
      }
    ctx.globalCompositeOperation = isGhost ? "lighten" : "source-over";
    if (bgColour) drawHex(bgColour);
    else if (colourBase) {
      const
        bc = noteColours[isGhost ? colourBase === "white" ? "black" : "white" : colourBase],
        oc = oharm ? HexButton.#colourMix(bc, noteColours[oharm] ?? noteColours.default, .1) : null,
        uc = uharm ? HexButton.#colourMix(bc, noteColours[uharm] ?? noteColours.default, .1) : null;
      if (oc && uc) {
        bgColour = HexButton.#colourMix(oc, uc, .5);
        drawHex(HexButton.#colourMix(oc, noteColours.white, .1));
        const [cx, cy] = this.centre();
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, this.#hexGrid.r, 0, Math.PI);
        ctx.closePath();
        ctx.clip();
        drawHex(HexButton.#colourMix(uc, noteColours.black, .1));
        ctx.restore();
      } else drawHex(bgColour = (oc ? HexButton.#colourMix(oc, noteColours.white, .1) : uc ?
        HexButton.#colourMix(uc, noteColours.black, .1) : bc))
    } else drawHex(bgColour = noteColours.default);
    ctx.font = (isGhost ? "bold  " : "") + (.5 * this.#hexGrid.r) + "px HEJI2, ArbutusSlab";
    const [ x, y ] = this.centre(),
          { label } = this.#note.getKey().getLabel(),
          { width } = ctx.measureText(label);
    ctx.fillStyle = isGhost ? bgColour : HexButton.#contrast(bgColour);
    ctx.fillText(label ?? this.note()[1], x - width / 2, y)
  }

  turnOn (id) { this.#hexGrid.addToActive(this, id) }
  turnOff (id) { this.#hexGrid.removeFromActive(this, id) }

}



// Keyboard

class Keyboard {

  // Static
  static presets = {
    "12edo": {
      gstep: 2, hstep: 1, orientation: [5, 2], unit: 45, refNote: 9, freqBasis: 220,
      edo: 12, limit: 9, maxError: 33, hmap: [[3, 7], [5, 4], [7, 10], [9, 2]], instrument: "triangle"
    },
    "19edo": {
      gstep: 3, hstep: 2, orientation: [5, 2], unit: 45, refNote: 14, freqBasis: 220,
      edo: 19, limit: 9, maxError: 22, hmap: [[3, 11], [5, 6], [7, 15], [9, 3]], instrument: "triangle"
    },
    "22edo": {
      gstep: 4, hstep: 1, orientation: [5, 2], unit: 45, refNote: 16, freqBasis: 220,
      edo: 22, limit: 11, maxError: 18, hmap: [[3, 13], [5, 7], [7, 18], [9, 4], [11, 10]], instrument: "triangle"
    },
    "31edo": {
      gstep: 5, hstep: 3, orientation: [5, 2], unit: 45, refNote: 23, freqBasis: 220,
      edo: 31, limit: 11, maxError: 12, hmap: [[3, 18], [5, 10], [7, 25], [9, 5], [11, 14]], instrument: "triangle"
    },
    "41edo": {
      gstep: 7, hstep: 3, orientation: [5, 2], unit: 45, refNote: 30, freqBasis: 220,
      edo: 41, limit: 15, maxError: 9, hmap: [[3, 24], [5, 13], [7, 33], [9, 7], [11, 19], [13, 29], [15, 37]], instrument: "triangle"
    },
    "53edo": {
      gstep: 5, hstep: 4, orientation: [5, 7], unit: 45, refNote: 39, freqBasis: 220,
      edo: 53, limit: 15, maxError: 8, hmap: [[3, 31], [5, 17], [7, 43], [9, 9], [11, 24], [13, 37], [15, 48]], instrument: "triangle"
    },
    "94edo": {
      gstep: 9, hstep: 7, orientation: [5, 7], unit: 45, refNote: 69, freqBasis: 220,
      edo: 94, limit: 17, maxError: 4, hmap: [[3, 55], [5, 30], [7, 76], [9, 16], [11, 43], [13, 66], [15, 85], [17, 8]], instrument: "triangle"
    },
  }

  static noteColours = {
    default: "#333333", active: "#ffff00",
    white: "#222222", black: "#777777",
    5: "#ff0000", 7: "#0000ff", 11: "#00ff00", 13: "#ff00ff"
  }

  static selectEl; static edoInfoEl; static limitInfoEl
  static gstepEl; static hstepEl; static orientationSelectEl; static unitEl
  static refNoteEl; static freqBasisEl; static edoEl; static limitEl; static maxErrorEl
  static scaleOutputEl
  static attach ({
    selectEl, edoInfoEl, limitInfoEl,
    gstepEl, hstepEl, orientationSelectEl, unitEl, refNoteEl, freqBasisEl,
    edoEl, limitEl, maxErrorEl, scaleOutputEl
  }) { Object.assign(this, {
    selectEl, edoInfoEl, limitInfoEl,
    gstepEl, hstepEl, orientationSelectEl, unitEl, refNoteEl, freqBasisEl,
    edoEl, limitEl, maxErrorEl, scaleOutputEl
  }) }

  static load ({ keyboards }) {
    let storedKeyboards = localStorage.getItem("keyboards");
    storedKeyboards ?
      Object.assign(keyboards ??= {}, JSON.parse(storedKeyboards)) :
      localStorage.setItem("keyboards", JSON.stringify(keyboards = Keyboard.presets));
    Object.keys(keyboards).forEach(name => {
      const el = $.load("option", "", Keyboard.selectEl)[0][0]
      el.innerText = name;
      el.setAttribute("name", name)
    });
    const customKeybOptEl = $.load("option", "", Keyboard.selectEl)[0][0]
    customKeybOptEl.innerText = "Custom";
    customKeybOptEl.setAttribute("name", "Custom");
    customKeybOptEl.disabled = true;

    let storedKeyboardSelection = localStorage.getItem("keyboardSelection"), keyboardSelection;
    storedKeyboardSelection ?
      (keyboardSelection = Keyboard.selectEl.value = storedKeyboardSelection) :
      localStorage.setItem("keyboardSelection", keyboardSelection = Object.keys(keyboards)[0]);

    let keyboard = keyboardSelection === "Custom" ? JSON.parse(localStorage.getItem("keyboard")) : keyboards[keyboardSelection];
    Keyboard.edoInfoEl.innerText = keyboard.edo;
    Keyboard.limitInfoEl.innerText = keyboard.limit;

    let noteColours = localStorage.getItem("noteColours");
    if (noteColours) Keyboard.noteColours = JSON.parse(noteColours);
    else localStorage.setItem("noteColours", JSON.stringify(Keyboard.noteColours));

    return { keyboard: new Keyboard({ name: keyboardSelection, ...keyboard }), keyboards }
  }

  static setColour (harm, colour, isBlackKeys) {
    if (harm === 3) Keyboard.noteColours[isBlackKeys ? "black" : "white"] = colour;
    else Keyboard.noteColours[harm] = colour;
    localStorage.setItem("noteColours", JSON.stringify(Keyboard.noteColours));
    this.getScope().keyboard.hexGrid.redraw()
  }

  static ready = false
  static getScope () { return app.menuState.at(-2) === "keyboard-settings" ? app.menuState[1] : app }

  // Instance
  name; edo; hexGrid; scale; instrument = "triangle"
  touches = new Map(); mousedown = false
  constructor ({
    name, edo,
    gstep, hstep, unit, orientation,
    limit, refNote, freqBasis, maxError,
      hmap,
    // instrument
  }) {
    // TODO: validation helper?
    if (typeof name !== "string" || name === "" || name.length > app.maxKeyboardNameLength) throw new Error("Keyboard error: bad name");
    if (typeof edo !== "number" || edo < 0 || edo > app.maxEdo || edo % 1) throw new Error("Keyboard error: bad EDO");
    this.name = name;
    this.edo = edo;
    this.hexGrid = new HexGrid({ keyboard: this, gstep, hstep, unit, orientation });
    this.scale = new Scale({ keyboard: this, limit, refNote, freqBasis, maxError })
  }

  load () {
    const { selectEl, edoInfoEl, limitInfoEl } = Keyboard, keyboardSelection = selectEl.value, keyboard = {};
    localStorage.setItem("keyboardSelection", keyboardSelection);
    if (keyboardSelection === "Custom") {
      Object.assign(keyboard, {
        name: "Custom",
        orientation: Keyboard.orientationSelectEl.value.split(",").map(v => parseInt(v)),
        hmap: $.all(".harmonic.prime > input.steps")
          .map(el => [parseInt(el.parentElement.dataset.harm), el.valueAsNumber])
      });
      [ "gstep", "hstep", "unit", "refNote", "freqBasis", "edo", "limit", "maxError" ]
        .forEach(dataname => keyboard[dataname] = Keyboard[dataname + "El"].valueAsNumber);
      Keyboard.getScope().keyboard = new Keyboard(keyboard);
      localStorage.setItem("keyboard", JSON.stringify(keyboard))
    } else {
      selectEl.namedItem("Custom").disabled = true;
      Object.assign(keyboard, app.keyboards[keyboardSelection], { name: keyboardSelection });
      localStorage.removeItem("keyboard");
      (Keyboard.getScope().keyboard = new Keyboard(keyboard)).fillSettings()
    }
    edoInfoEl.innerText = keyboard.edo;
    limitInfoEl.innerText = keyboard.limit;
    app.emit("generate-keyboard");
    return { keyboardSelection }
  }

  save () {
    const
      { name, edo, hexGrid, scale } = this,
      { gstep, hstep, unit, orientation } = hexGrid,
      { limit, refNote, freqBasis, maxError, mapping } = scale,
      { hmap } = mapping,
      storeObj = {
        edo, gstep, hstep, unit, orientation,
        limit, refNote, freqBasis, maxError, hmap
      },
      keyboardsObj = JSON.parse(localStorage.getItem("keyboards"));
    localStorage.setItem("keyboards", JSON.stringify(Object.assign(keyboardsObj, { [name]: storeObj })))
  }

  fillSettings () {
    const
      { gstepEl, hstepEl, orientationSelectEl, unitEl, refNoteEl, freqBasisEl,
        edoEl, limitEl, maxErrorEl, scaleOutputEl } = Keyboard,
      { edo, hexGrid, scale } = this,
      { gstep, hstep, unit, orientation, orientations } = hexGrid,
      { limit, refNote, freqBasis, maxError } = scale;
    gstepEl.value = gstep;
    hstepEl.value = hstep;
    $.all(":scope > *", orientationSelectEl).forEach(el => el.remove());
    orientations.forEach(coord => {
      const el = $.load("option", "", orientationSelectEl)[0][0];
      el.innerText = coord;
      el.setAttribute("name", coord)
    });
    orientationSelectEl.options.namedItem(orientation.join(",")).selected = true;
    unitEl.value = unit;
    refNoteEl.value = refNote;
    freqBasisEl.value = freqBasis;
    edoEl.value = edo;
    limitEl.value = limit;
    maxErrorEl.value = maxError
    scaleOutputEl.value = `One step of ${edo}EDO = ${(1200 / edo).toFixed(2)}Â¢`;
  }

  update () {
    const
      { orientationSelectEl, gstepEl, hstepEl, edoEl } = Keyboard,
      { keyboard } = Keyboard.getScope(), { hexGrid } = keyboard,
      gstep = gstepEl.valueAsNumber,
      hstep = hstepEl.valueAsNumber,
      edo = edoEl.valueAsNumber,
      applyButton = $("#keyboard-settings-apply");
    $.all(":scope > *", orientationSelectEl).forEach(el => el.remove());
    if (Common.gcd(gstep, hstep) !== 1) return applyButton.disabled = true;
    this.edo = edo;
    applyButton.disabled = false;
    if (!hexGrid.setLattice({ gstep, hstep })) return applyButton.disabled = true;
    hexGrid.orientations.forEach(coord => {
      const el = $.load("option", "", orientationSelectEl)[0][0];
      el.innerText = coord;
      el.setAttribute("name", coord)
    })
    orientationSelectEl.namedItem(hexGrid.orientation).selected = true
  }

  play (g, h, id) {
    const { hexGrid, scale, touches } = this;
    let hex = hexGrid.getHex(g, h),
        [ octave, rank ] = hex.note(),
        note = scale.getNote({ octave, rank });
    hex.turnOn(id);
    hexGrid.colour();
    note.turnOn(id);
    touches.set(id, { hex, note });
  }

  stop (id) {
    const { hexGrid, scale, touches } = this;
    let { hex, note } = touches.get(id);
    hex.turnOff(id)
    hexGrid.colour()
    note.turnOff(id);
    touches.delete(id);
  }

  refresh () {
    this.touches = new Map();
    this.scale.refresh();
    this.hexGrid.redraw(true)
  }

}

// Musical aspect of keyboard
class Scale {
  #keyboard; limit
  mapping; refNote; freqBasis; maxError
  #keys = new Map() // Map([ rank, key ])
  #active = new Map() // Map([ note, Set(id) ])
  constructor ({ keyboard, limit, hmap, refNote, freqBasis, maxError }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Scale error: must provide Keyboard object");
    this.#keyboard = keyboard;
    const { edo } = keyboard;
    if (typeof limit !== "number" || limit < 3 || limit > app.maxHarmonic || limit % 2 !== 1) throw new Error("Scale error: bad harmonic limit");
    if (typeof refNote !== "number" || refNote < 0 || refNote >= edo || refNote % 1) throw new Error("Scale error: bad reference note");
    if (typeof freqBasis !== "number" || freqBasis < 10 || freqBasis > 4e4) throw new Error("Scale error: bad reference frequency");
    if (typeof maxError !== "number" || freqBasis < 0 || freqBasis > 1200) throw new Error("Scale error: bad max pitch variation");
    this.limit = limit;
    this.maxError = maxError;
    this.refNote = refNote;
    this.mapping = new HarmonicMapping({ keyboard, scale: this, hmap: this.#genRawHMap({ edo, limit, maxError }) });
    this.freqBasis = freqBasis;

    for (let i = 0; i < edo; i++) this.#keys.set(i, new Key({ keyboard, scale: this, rank: i }))
  }

  #genRawHMap ({ edo, limit, maxError }) {
    let hmap = new Map();
    for (let i = 3; i <= limit; i += 2) {
      const
        just = Math.log2(i) % 1,
        maybeSteps = Math.round(just * edo),
        error = (maybeSteps / edo - just) * 1200;
      if (Math.abs(error) < maxError && maybeSteps + edo * maxError / 1200 >= 1 &&
        maybeSteps - edo * maxError / 1200 < edo) hmap.set(i, maybeSteps)
    }
    return hmap
  }

  getKey (rank) { return this.#keys.get(rank) }
  addNote ({ rank, octave }) { return this.#keys.get(rank).addNote(octave) }
  getNote ({ rank, octave }) { return this.#keys.get(rank)?.getNote(octave) }
  play (note, id) {
    const active = this.#active, ids = active.get(note);
    if (ids) ids.add(id);
    else {
      active.set(note, new Set([id]))
      note.start();
    } 
  }
  stop (note, id) {
    const active = this.#active, ids = active.get(note);
    if (!ids) return;
    ids.delete(id);
    if (ids.size === 0) {
      note.stop();
      active.delete(note)
    }
  }
  refresh () { this.#active = new Map() }
}

class Key {
  #keyboard; #scale; #notes = new Map(); #labels = []; #labelIndex = 0; #home; rank
  constructor ({ keyboard, scale, rank }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("Key error: must provide Keyboard object");
    this.#keyboard = keyboard;
    if (!(Scale.prototype.isPrototypeOf(scale))) throw new Error("Key error: must provide Scale object");
    this.#scale = scale;
    this.rank = rank
  }
  addNote (octave) {
    const note = new Note({ keyboard: this.#keyboard, scale: this.#scale, rank: this.rank, octave });
    this.#notes.set(octave, note);
    return note
  }
  getNote (octave) { return this.#notes.get(octave) }
  getNotes () { return [ ...this.#notes ] }
  getLabels () { return this.#labels.slice() }
  getLabel () { return this.#labels[this.#labelIndex] ?? { label: this.rank } }
  setLabels (labels) { this.#labels = labels }
  setLabel (i) { this.#notes.forEach(note => {
    if (!Common.between(0, this.#labels.length - 1, i)) return false;
    this.#labelIndex = i;
    const { label, keyClass } = this.#labels[i]
  }) }
  setHome (hex) { this.#home = hex }
  getHome () { return this.#home }
}

class Note {
  #keyboard; #scale; #osc; #volume; rank; octave
  constructor ({ keyboard, scale, rank, octave }) {
    if (!(Keyboard.prototype.isPrototypeOf(keyboard))) throw new Error("HexGrid error: must provide Keyboard object");
    if (!Scale.prototype.isPrototypeOf(scale)) throw new Error("Note error: must provide Scale object");
    const existing = scale.getNote({ rank, octave })
    if (existing) return existing;
    this.#keyboard = keyboard;
    this.#scale = scale;
    this.rank = rank;
    this.octave = octave
  }
  getKey () { return this.#scale.getKey(this.rank) }
  start () {
    const
      { audioctx, masterVolume } = app.state(),
      { rank, octave } = this, { freqBasis, refNote } = this.#scale, { edo } = this.#keyboard,
      osc = this.#osc = audioctx.createOscillator(),
      volume = this.#volume = audioctx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freqBasis * 2 ** (octave + ((refNote + rank) / edo));
    osc.connect(volume);
    volume.connect(masterVolume);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime)
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime + .05)
    osc.start(audioctx.currentTime)
  }
  stop () {
    const
      { audioctx } = app.state(),
      osc = this.#osc, volume = this.#volume;
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime + .05);
    osc.stop(audioctx.currentTime + .05);
    this.#osc = null;
    this.#volume = null
  }

  turnOn (id) { this.#scale.play(this, id) }
  turnOff (id) { this.#scale.stop(this, id) }
}

class Chord {
  #keyboard; #coordss
  constructor (keyboard, ...coordss) {
    this.#keyboard = keyboard;
    this.#coordss = coordss
  }
  start (id) { this.#coordss.forEach(([g, h], i) => this.#keyboard.play(g, h, id + "-" + i)) }
  stop (id) { this.#coordss.forEach((_, i) => this.#keyboard.stop(id + "-" + i)) }
}



// Track

class Track {}



// Menu state

class MenuState {}



// Page state

// TODO: add freeze property feature to machine.js
var app = new $.Machine({
    // Version
      version: "0.0.1",

    // Navigation
      menuState: [],

      // Keyboard
      maxEdo: 270,
      maxKeyboardNameLength: 255,
      octaves: null,
      keyboard: null,
      keyboards: null,
      keyboardSelection: null,
      canvas: null,
      gridctx: null,
      audioctx: null,
      masterVolume: null,

      // Harmony
      maxHarmonic: 51,
      temperings: null,

      // Track
      tracks: {},
      trackSelection: null
    });



// Events

$.targets({

  load () { app.emit("init") },

  keydown (e) { if (e.key === "Escape") document.activeElement.blur() },

  resize () {
    if (!Keyboard.ready) return;
    app.emit("resize", true);
    Keyboard.getScope().keyboard.hexGrid.redraw(true)
  },

  contextmenu (e) { e.preventDefault() },

  "touchstart touchend touchmove" (e) {
    if (!Keyboard.ready) return;
    const nav = $("nav");
    if (e.type === "touchstart" && document.activeElement === nav && !e.composedPath().includes(nav)) $(nav).blur();
    const canvas = $("canvas");
    if (e.target === $("main")) for (let { clientX, clientY, identifier } of e.changedTouches) {
      const
        x = clientX - canvas.offsetLeft, y = clientY - canvas.offsetTop,
        { keyboard } = Keyboard.getScope(), { hexGrid } = keyboard;
      if (keyboard && (keyboard.touches.has("touch-" + identifier) || e.type === "touchstart") &&
        (hexGrid.hasHex(...hexGrid.getCoord(x, y)) || e.type === "touchend"))
        app.emit("press", x, y, "touch", e.type.slice(5), identifier)
    }
  },

  mousedown (e) {
    if (!Keyboard.ready) return;
    const { keyboard } = Keyboard.getScope(), { hexGrid } = keyboard;
    if (e.target === $("main") && hexGrid.hasHex(...hexGrid.getCoord(e.layerX, e.layerY))) {
      keyboard.mousedown = true;
      app.emit("press", e.layerX, e.layerY, "mouse", "start")
    }
  },
  mousemove (e) {
    if (!Keyboard.ready) return;
    const { hexGrid, mousedown } = Keyboard.getScope().keyboard,
          hover = hexGrid.hasHex(...hexGrid.getCoord(e.layerX, e.layerY));
    $("main").classList.toggle("hover", hover);
    if (mousedown && hover) app.emit("press", e.layerX, e.layerY, "mouse", "move")
  },
  "mouseup mouseout" (e) {
    if (!Keyboard.ready) return;
    const { keyboard } = Keyboard.getScope();
    if (keyboard.mousedown && e.type !== "mouseout") {
      keyboard.mousedown = false;
      app.emit("press", e.layerX, e.layerY, "mouse", "end")
    }
  },

  document: { fonts: { loadingdone () {
    if (!Keyboard.ready) return;
    app.emit("resize", true);
    Keyboard.getScope().keyboard.hexGrid.redraw(true)
  } } },

  app: {

    init () {
      const { version } = this;
      if (Common.versionCmp(version, localStorage.getItem("version") ?? "0") > 0) {
        localStorage.clear();
        localStorage.setItem("version", version)
      }
      this.canvas = $("#hex");
      this.gridctx = this.canvas.getContext("2d");
      new ResizeObserver(() => {
        this.emit("resize", true);
        Keyboard.getScope().keyboard.hexGrid.redraw(true)
      }).observe($("main"));
      const ivTable = $("#interval-table");
      new ResizeObserver(() => {
        const { width, height } = ivTable.getBoundingClientRect();
        ivTable.style.setProperty("--table-width", Math.round(width) + "px");
        ivTable.style.setProperty("--table-height", Math.round(height) + "px")
      }).observe(ivTable);
      const
        audioctx = this.audioctx = new AudioContext(),
        masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = Common.scaleVolume($("#volume > input").valueAsNumber);
      this.octaves = $("#octaves > input").valueAsNumber;
      $("#track-select > select").selectedIndex = 0;

      Keyboard.attach({
        // Keyboard selection
        selectEl: $("#keyboard-select > select"),
        edoInfoEl: $("#edo-info"),
        limitInfoEl: $("#limit-info"),

        // Keyboard settings
        gstepEl: $("#gstep > input"),
        hstepEl: $("#hstep > input"),
        orientationSelectEl: $("#orientation > select"),
        unitEl: $("#unit > input"),
        refNoteEl: $("#refNote > input"),
        freqBasisEl: $("#freqBasis > input"),
        edoEl: $("#edo > input"),
        limitEl: $("#limit > input"),
        maxErrorEl: $("#maxError > input"),
        scaleOutputEl: $("#scale > output")
      });
      Keyboard.limitEl.max = this.maxHarmonic;
      this.emit("load-presets")
    },

    "clear-storage" () { localStorage.clear() },

    "load-presets" () {
      const { keyboard, keyboards } = Keyboard.load({ keyboards: this.keyboards, keyboardSelection: this.keyboardSelection });
      Object.assign(this, { keyboard, keyboards, keyboardSelection: keyboard.name });

      keyboard.fillSettings();
      this.keyboard = keyboard;
      Keyboard.ready = true;

      // Tracks
      let tracks = localStorage.getItem("tracks");
      if (!tracks) {
        this.tracks = tracks = {};
        localStorage.setItem("tracks", "{}");
      } else this.tracks = tracks = JSON.parse(tracks);
      const trackSelEl = $("#track-select select"), selectHrEl = $("#track-select hr");
      Object.keys(this.tracks).forEach(name => {
        const el = $.load("option", "#track-select > select")[0][0];
        el.innerText = name;
        el.setAttribute("name", name);
        trackSelEl.insertBefore(el, selectHrEl)
      })

    },

    resize (reset) {
      const
        { hexGrid } = Keyboard.getScope().keyboard,
        { canvas, octaves } = this, { unit, orientation: [g, h], theta } = hexGrid,
        x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5,
        { width, height } = $("main").getBoundingClientRect(),
        r = hexGrid.r = Math.min(unit * 2, width / (Math.hypot(x, y) * octaves + 2) * 2);
      if (reset) {
        hexGrid.w = canvas.width = Math.ceil(width) * 2,
        hexGrid.h = canvas.height = Math.ceil(height) * 2;
        this.gridctx.textBaseline = "middle"
      }
      hexGrid.c = (octaves % 2) * Math.hypot(x, y) * r / 2;
      hexGrid.octLen = Math.hypot(x, y) * r;
      canvas.style.setProperty("width", Math.ceil(width));
      canvas.style.setProperty("height", Math.ceil(height));
    },

    press (x, y, type, action, id) {
      id = type + "-" + id;
      const
        { keyboard } = Keyboard.getScope(),
        coord = keyboard.hexGrid.getCoord(x, y), [g, h] = coord;
      let hex, note;
      switch (action) {
        case "start": keyboard.play(g, h, id); break;
        case "move":
          if (keyboard.touches.get(id).hex.getCoord().some((v, i) => v !== coord[i])) {
            keyboard.stop(id);
            keyboard.play(g, h, id)
          }
          break;
        case "end": keyboard.stop(id)
      }
    },

    panic () {
      this.audioctx.close();
      const
        audioctx = this.audioctx = new AudioContext(),
        masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
    },

    fullscreen (state) { state ? $("body").requestFullscreen() : document.exitFullscreen() },



    // Keyboard

    "generate-keyboard" () {
      const
        { limitEl, maxErrorEl, edoEl, refNoteEl, freqBasisEl } = Keyboard,
        limit = limitEl.valueAsNumber,
        maxError = maxErrorEl.valueAsNumber,
        edo = edoEl.valueAsNumber,
        refNote = refNoteEl.valueAsNumber,
        freqBasis = freqBasisEl.valueAsNumber,
        { keyboard } = Keyboard.getScope();
      $.all(".harmonic").forEach(el => el.remove());
      
      const
        scale = new Scale({ keyboard, limit, maxError, refNote, freqBasis }),
        { rawHarmonicList, harmonicList, primes, indexPrimes, index, intervalSet } = scale.mapping;

      for (let [ harmonic, steps ] of rawHarmonicList) {
        const
          dec = Common.decomp(harmonic)[0],
          primeHarmonic = [ ...dec ][0][0],
          isPrime = primes.concat(indexPrimes).includes(harmonic),
          harmObj = harmonicList.get(harmonic),
          just = Math.log2(harmonic) % 1,
          labelEl = $.load("harmonic", "#mapping")[0][0],
          [ , inputEl, compositeEl, errorEl, , colourEl ] = [ ...labelEl.children ];
        labelEl.dataset.harm = harmonic;
        $("#nth-harmonic", labelEl).innerText = Common.ordinal(harmonic);
        inputEl.setAttribute("value", steps);
        inputEl.setAttribute("min", Math.max(1, Math.ceil((just - maxError / 1200) * edo)));
        inputEl.setAttribute("max", Math.min(edo - 1, Math.floor((just + maxError / 1200) * edo)));
        // TODO eg hcolour when 15 in but 3, 5 out
        if (harmObj.isBasis) labelEl.classList.add("basis");
        if (isPrime) labelEl.classList.add("prime");
        else {
          compositeEl.innerText = steps;
          if (dec.size === 1 && [ ...dec ][0][1] > 1) labelEl.classList.add("prime", "power"); // Not correct
        }
        errorEl.innerText = ((steps / edo - just) * 1200).toFixed(2);
        if (harmObj.isBasis && primeHarmonic === 3) { // Not correct!
          colourEl.value = Keyboard.noteColours.white;
          labelEl.appendChild(colourEl.cloneNode()).value = Keyboard.noteColours.black;
        } else if (isPrime) colourEl.value = Keyboard.noteColours[harmonic] ??= Keyboard.noteColours.default;
        $.queries({
          "input.steps": { change () { app.emit("generate-keyboard") } },
          "input.hcolour": { change () { Keyboard.setColour(primeHarmonic, this.value, this === $.all("input.hcolour", labelEl)[1]) } },
          button: (chord => ({
            pointerdown (e) {
              this.setPointerCapture(e.pointerId);
              const
                { keyboard } = Keyboard.getScope(),
                key = keyboard.scale.getKey(steps),
                enhi = key.getLabels().findIndex(({ interval: iv }) => comp(iv[0])[0] === harmonic && iv[1].length === 0);
              ~enhi && key.setLabel(enhi);
              keyboard.hexGrid.redraw();
              chord = new Chord(keyboard, [0, 0], keyboard.scale.getKey(steps).getHome().getCoord());
              chord.start("pointer-" + e.pointerId)
            },
            pointerup (e) {
              chord.stop("pointer-" + e.pointerId);
              this.releasePointerCapture(e.pointerId)
            }
          }))()
        }, labelEl)
      }
      Object.assign(keyboard, { edo, scale, name: "Custom" }); // HexGrid?

      // Tonality diamond
      const diamondEl = $("#diamond");
      $.all(":scope > *", diamondEl).forEach(el => el.remove());
      const
        temperings = this.temperings = $.all(".harmonic").map(el => [ parseInt(el.dataset.harm), $("input", el).valueAsNumber ])
          .sort(([p], [q]) => Math.log2(p) % 1 > Math.log2(q) % 1),
        h = temperings.length;
      diamondEl.style.setProperty("--size", 2 * h + 1);
      for (let i = 0; i <= h; i++) {
        const
          cell = $.load("interval-cell", "#diamond")[0][0],
          [ interval, note, width, button ] = $.all(":scope > *", cell);
        cell.style.gridArea = `${h + 1}/${2 * i + 1}/span 1/span 2`;
        interval.innerHTML = "<sup>1</sup>/<sub>1</sub>";
        note.innerText = "C";
        width.innerText = button.dataset.steps = 0
        button.dataset.interval = "1/1"
      }
      for (let i = h; i > 0; i--) for (let j = 0; j < i; j++) {
        const
          upperCell = $.load("interval-cell", "#diamond",)[0][0],
          lowerCell = $.load("interval-cell", "#diamond",)[0][0],
          [ upperInterval, upperNote, upperWidth, upperButton ] = $.all(":scope > *", upperCell),
          [ lowerInterval, lowerNote, lowerWidth, lowerButton ] = $.all(":scope > *", lowerCell),
          upperIv = intervalSet.getRatio(temperings[h - i + j][0], temperings[j - 1]?.[0] ?? 1),
          lowerIv = intervalSet.getRatio(temperings[j - 1]?.[0] ?? 1, temperings[h - i + j][0]);
        upperIv.withOctave(upperIv.octave);
        lowerIv.withOctave(lowerIv.octave);
        upperCell.style.gridArea = `${i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        lowerCell.style.gridArea = `${2 * h + 2 - i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        upperInterval.innerHTML = `<sup>${upperIv.fraction[0]}</sup>/<sub>${upperIv.fraction[1]}</sub>`;
        lowerInterval.innerHTML = `<sup>${lowerIv.fraction[0]}</sup>/<sub>${lowerIv.fraction[1]}</sub>`;
        upperNote.innerText = upperIv.noteSpelling.string;
        lowerNote.innerText = lowerIv.noteSpelling.string;
        upperButton.dataset.interval = upperIv.fraction.join("/");
        lowerButton.dataset.interval = lowerIv.fraction.join("/");
        upperWidth.innerText = upperButton.dataset.steps = upperIv.steps();
        lowerWidth.innerText = lowerButton.dataset.steps = lowerIv.steps()
      }
      app.emit("resize", true);
      keyboard.hexGrid.redraw(true);

      // Interval table
      const ivTable = $("#interval-table"), ps = primes.concat(indexPrimes).sort((a, b) => a > b);
      $.all(":scope > *", ivTable).forEach(el => el.remove());
      ivTable.style.setProperty("--harms", ps.length);
      ivTable.style.setProperty("--edo", edo);
      $.load("interval-th", "", ivTable)[0][0].innerHTML = "Steps";
      ps.forEach((p, k) => {
        const el = $.load("interval-th", "", ivTable)[0][0];
        el.classList.add("column-head");
        el.style.gridColumnStart = k + 2;
        $("span", el).innerText = p
      })
      for (k = 0; k < edo; k++) {
        const el = $.load("interval-th", "", ivTable)[0][0];
        el.classList.add("row-head");
        el.style.gridRowStart = k + 2;
        $("span", el).innerText = k
      }
      for (let steps = 0; steps < edo; steps++) scale.getKey(steps).getLabels()
        .forEach(({ interval: iv, label, keyClass }) => {
          const
            [ n, d ] = iv.map(side => side.reduce(([big, log], [p, rad]) =>
              [big * BigInt(p) ** BigInt(rad), log + Math.log2(p) * rad], [1n, 0]))
              .reduce(([bn, ln], [bd, ld]) => {
                const oct = BigInt(Math.floor(ln - ld));
                return [oct < 0 ? bn << -oct : bn, oct > 0 ? bd << oct : bd]
              }),
            curh = keyClass.match(/\d{1,2}/g)
              ?.map(s => parseInt(s)).sort((a, b) => a < b)[0] ?? (steps ? 3 : 1);
          let td = $(`.interval-td[data-cell="${steps},${curh}"]`);
          if (!td) {
            td = $.load("interval-td", "", ivTable)[0][0];
            td.style.gridArea = steps === 0 ?
              `2/2/span 1/span ${ps.size}` :
              `${steps + 2}/${ps.findIndex(p => p % curh === 0) + 2}`;
            td.dataset.cell = `${steps},${curh}`
          }
          const
            cell = $.load("interval-cell", "", td)[0][0],
            [ interval, note, width, button ] = $.all(":scope > *", cell);
          if (steps === 0) cell.id = "table-unison";
          interval.innerHTML = `<sup>${n}</sup>/<sub>${d}</sub>`;
          note.innerText = label;
          width.innerText = button.dataset.steps = steps
          button.dataset.interval = `${n}/${d}`;
        });

      // Play interval buttons
      $.queries({
        '.interval-display button[data-steps="0"]': (hex => ({
          pointerdown (e) {
            this.setPointerCapture(e.pointerId);
            if (this.closest("#diamond"))
              $.all('.interval-display button[data-steps="0"]').forEach(el => el.parentElement.classList.add("activeEnharmonic"));
              Keyboard.getScope().keyboard.play(0, 0, "pointer-" + e.pointerId)
          },
          pointerup (e) {
            $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
            Keyboard.getScope().keyboard.stop("pointer-" + e.pointerId);
            this.releasePointerCapture(e.pointerId)
          }
        }))(),
        '.interval-display button:not([data-steps="0"])': (chord => ({
          pointerdown (e) {
            this.setPointerCapture(e.pointerId);
            const
              { keyboard } = Keyboard.getScope(),
              steps = parseInt(this.dataset.steps),
              [n, d] = this.dataset.interval.split("/").map(v => Common.non2(parseInt(v))),
              key = keyboard.scale.getKey(steps),
              enhi = key.getLabels().findIndex(({ interval: iv }) => comp(iv[0])[0] === n && comp(iv[1])[0] === d);
            $.all(`button[data-steps="${steps}"]`, this.closest(".interval-display"))
              .forEach(el => el.parentElement.classList.add("activeEnharmonic"));
            ~enhi && key.setLabel(enhi);
            keyboard.hexGrid.redraw();
            chord = new Chord(keyboard, [0, 0], keyboard.scale.getKey(steps).getHome().getCoord());
            chord.start("pointer-" + e.pointerId)
          },
          pointerup (e) {
            $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
            chord.stop("pointer-" + e.pointerId);
            this.releasePointerCapture(e.pointerId)
          }
        }))()
      })
    },



    // Temperaments

    "generate-temperaments" () {

    },



    // Track editor

    "track-name-update" (name) {
      const { tracks, trackSelection } = this, trackSelEl = $("#track-select > select");
      if (name === "New" || name in tracks && trackSelEl.value !== name) {
        $("#track-name-field").classList.add("invalid");
        return
      }
      $("#track-file").classList.add("saved");
      delete this.tracks[trackSelection];
      this.tracks[name] = $("#track-edit").value;
      this.trackSelection = name;
      $("#track-name-text").innerText = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name").classList.remove("editingTrackName");
      $(`#track-select option[name='${trackSelection}']`)?.remove();
      const el = $.load("option", "#track-select > select")[0][0];
      el.innerText = name;
      el.setAttribute("name", name);
      trackSelEl.insertBefore(el, $("#track-select hr"));
      el.selected = true;
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
    },

    "track-editor" (name) {
      const { tracks } = this;
      if (!name) {
        const
          nth = Object.keys(tracks)
            .map(tn => tn.match(/^Untitled( [1-9]\d*)?$/)?.slice(1).map(v => v ? parseInt(v) : 0))
            .flat().sort().findLastIndex((k, i) => k === i) + 1;
        name = "Untitled" + (nth ? " " + nth : "");
        $("#track-edit").value = "";
        $("#track-file").classList.remove("saved")
      } else {
        $("#track-edit").value = tracks[name];
        $("#track-file").classList.add("saved")
      }
      this.trackSelection = name;
      $("#track-name-field").value = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name-text").innerText = name;
      $("#track-name").classList.remove("editingTrackName");
    },

    "track-save" () {
      $("#track-file").classList.add("saved");
      $("#track-savestate").classList.add("saving");
      clearInterval(this.menuState[1].saveDebounce);
      this.menuState[1].saveDebounce = setTimeout(() => {
        localStorage.setItem("tracks", JSON.stringify(this.tracks));
        $("#track-savestate").classList.remove("saving")
      }, 500)
      const trackSelection = $("#track-name-field").value;
      let el;
      if (!(trackSelection in this.tracks)) {
        el = $.load("option", "#track-select > select")[0][0];
        el.innerText = trackSelection;
        el.setAttribute("name", trackSelection);
        $("#track-select select").insertBefore(el, $("#track-select hr"));
        el.selected = true
      } else el = $("#track-select > select").namedItem(trackSelection);
      this.trackSelection = $("#track-name-field").value;
      this.tracks[this.trackSelection] = $("#track-edit").value;
      el.innerText = trackSelection;
      el.setAttribute("name", trackSelection)
    },

    "track-delete" (response) {
      $("#delete-dialog").close(response);
      if (response === "Cancel") return;
      const { tracks, trackSelection } = this;
      delete this.tracks[trackSelection];
      this.trackSelection = null;
      $(`#track-select option[name='${trackSelection}']`).remove();
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
      this.emit("menu-cancel")
    },



    // Menu

    "menu-select" (which, ...data) {
      const
        breadcrumbText = {
          "keyboard-settings": "Keyboard â›­",
          "temperaments": "Temperament ğŸ’¡",
          "track-editor": "Track âœ"
        };
      this.emit("menu-cancel");
      this.menuState = which.concat([null]);
      const menuLeaf = which.at(-1);
      $("body").classList.add("menuActive");
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $("#" + menuLeaf).classList.add("activeMenu");
      $.all("#breadcrumb-text > *").forEach(el => el.remove());
      which.forEach((level, i) => {
        const levelEl = $.load("breadcrumb-level", "#breadcrumb-text")[0][0];
        levelEl.innerText = breadcrumbText[level];
        if (i < which.length - 1) levelEl.dataset.menu = which.toSpliced(i + 1)
      });
      $.queries({ "#breadcrumbs > :nth-last-child(n+2)": { click () {
        app.emit("menu-select", this.dataset.menu.split(","))
      } } });
      let cancelEl, applyEl;
      switch (menuLeaf) {
        case "keyboard-settings":
          cancelEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(cancelEl, { innerText: "Cancel", id: "keyboard-settings-cancel" });
          applyEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(applyEl, { innerText: "Apply", id: "keyboard-settings-apply" });
          $.queries({
            "#keyboard-settings-cancel": { click () { app.emit("menu-cancel") } },
            "#keyboard-settings-apply": { click () {
              app.keyboard = app.menuState[1].keyboard;
              app.keyboardSelection = app.keyboard.load().keyboardSelection;
              app.emit("menu-cancel")
            } }
          });
          this.menuState[1] = { keyboard: this.keyboard };
          this.keyboard.fillSettings();
          this.emit("generate-keyboard");
          break;
        case "temperaments":
          this.emit("generate-temperaments")
          break;
        case "track-editor":
          $("#track-controls").classList.add("activeControls");
          $("#track-select > select").namedItem(data[0] ?? "New").selected = true;
          closeEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(closeEl, { innerText: "Close", id: "track-editor-close" });
          $.queries({ "#track-editor-close": {
            click () { app.emit("menu-cancel") }
          } });
          this.menuState[1] = { saveDebounce: null };
          this.emit("track-editor", ...data)
      }
    },
    "menu-cancel" () {
      $("body").classList.remove("menuActive")
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $.all("#menu-actions > *").forEach(el => el.remove());
      switch(this.menuState[0]) {
        case "track-editor":
          $("#track-controls").classList.remove("activeControls");
          $("#track-select > select").selectedIndex = 0
      }
      this.menuState = [];
      this.emit("resize", true);
      Keyboard.getScope().keyboard.hexGrid.redraw(true)
    },

    "volume-change" (value) { this.masterVolume.gain.value = Common.scaleVolume(value) }

  }
});



// Elements

$.queries({

  nav: { touchstart (e) { if ($.all("#refresh, #panic, #fullscreen, #volume > input").every(el => e.target !== el)) this.focus() } },
  form: { submit (e) { e.preventDefault() } },
  "#volume > input": { change () { app.emit("volume-change", this.valueAsNumber) } },
  "#octaves > input": { change () {
    app.octaves = this.valueAsNumber;
    app.emit("resize", true);
    Keyboard.getScope().keyboard.hexGrid.redraw(true)
  } },
  "#refresh": { click () {
    app.emit("resize", true);
    const { keyboard } = Keyboard.getScope();
    keyboard.refresh()
  } },
  "#panic": { click () { app.emit("panic") } },
  "#fullscreen": { click () { app.emit("fullscreen", this.classList.toggle("active")) } },

  "#keyboard-settings-button": { click () {
    if (app.menuState[0] === "keyboard-settings") app.emit("menu-cancel"); 
    else app.emit("menu-select", [ "keyboard-settings" ])
  } },
  "#keyboard-settings > form": { change (e) { Keyboard.selectEl.value = "Custom" } },
  "#keyboard-select > select": { change () { app.keyboardSelection = app.keyboard.load().keyboardSelection } },
  "#edo > input": { change () {
    const
      { refNoteEl, maxErrorEl, scaleOutputEl } = Keyboard,
      edo = this.valueAsNumber;
    refNoteEl.value = Math.round(Math.log2(5 / 3) * edo); // C-A = 5/3
    scaleOutputEl.value = `One step of ${edo}edo = ${(1200 / edo).toFixed(2)}Â¢`;
    maxErrorEl.value = Math.floor(400 / edo);
    Keyboard.getScope().keyboard.update();
    app.emit("generate-keyboard");
    this.focus()
  } },
  ":is(#gstep, #hstep) > input": { change () {
    const { keyboard } = Keyboard.getScope(), { orientationSelectEl } = Keyboard;
    keyboard.update();
    if (orientationSelectEl.children.length) {
      app.emit("resize", true);
      keyboard.hexGrid.redraw(true);
      orientationSelectEl.showPicker();
    }
  } },
  "#orientation > select": { change () {
    const { hexGrid } = Keyboard.getScope().keyboard;
    hexGrid.setOrientation(...JSON.parse(`[${this.value}]`));
    app.emit("resize", true);
    hexGrid.redraw(true);
    this.focus()
  } },
  "#unit > input": { change () {
    const { hexGrid } = Keyboard.getScope().keyboard;
    hexGrid.unit = this.valueAsNumber;
    app.emit("resize", true);
    hexGrid.redraw(true)
  } },
  ":is(#limit, #maxError) > input": { change () { app.emit("generate-keyboard") } },
  "#generate-temperaments": { click () { app.emit("menu-select", [ "keyboard-settings", "temperaments" ]) } }, 

  "#track-select > select": { change () {
    if (this.value === "None") app.emit("menu-cancel");
    else app.emit("menu-select", [ "track-editor" ], ...(this.value === "New" ? [] : [ this.value ]))
  } },
  "#track-name-text": { click () {
    $("#track-name").classList.add("editingTrackName");
    $("#track-name-field").focus()
  } },
  "#track-name-field": { "keyup blur" (e) {
    if (e.type === "blur" || e.key === "Enter") app.emit("track-name-update", this.value = this.value.trim())
  } },
  "#track-delete": { click () {
    $("#delete-track-name").innerText = app.trackSelection;
    $("#delete-dialog").showModal()
  } },
  "#delete-dialog button": { click () { app.emit("track-delete", this.dataset.action) } },
  "#track-edit": { keyup () { if (this.value !== app.tracks[app.trackSelection]) app.emit("track-save") } },
  "#toggle-accidentals": { click () { $("#insert-accidental").classList.toggle("activeSelect") } },
  "#insert-accidental > *": { click () {
    const { value } = $("#track-edit"), editorEl = $("#track-edit"), selStart = editorEl.selectionStart;
    $("#track-edit").value = value.slice(0, selStart) + this.innerText + value.slice(editorEl.selectionEnd)
    if ($("#track-edit").value !== app.tracks[app.trackSelection]) app.emit("track-save")
    editorEl.setSelectionRange(selStart + 1, selStart + 1);
    editorEl.focus()
  } }

})
  </script>
  <noscript>Only viewable with JavaScript enabled.</noscript>
</body>
</html>