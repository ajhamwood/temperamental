<!doctype html>
<html>
<head>
  <title>Temperamental ⁂ Microtonal music explorer</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='music, xenharmony, xenrhythm'>
  <meta name='description' content='Web app for composing, playing, and noodling on microtonal music.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>

@media (min-aspect-ratio: 1) {
  body.menuActive { grid: "nav nav" auto "menu main" 1fr / min-content 1fr } }
@media (max-aspect-ratio: 1) {
  body.menuActive { grid: "nav" auto "menu" min-content "main" auto }
  menu { max-height: calc(50dvh - 4.9em) } }

html, body {height: 100dvh }
body {
  margin: 0;
  background-color: #222;
  color: #ddd;
  display: grid;
  grid: "nav" auto "main" 1fr;
  overflow: hidden;
  touch-action: none }
  nav {
    grid-area: nav;
    display: flex;
    flex-flow: column }
    nav > * {
      padding: .5em;
      flex-flow: row;
      justify-content: space-between }
    #controls { display: flex }
      #controls > :first-child { flex: 1 }
        #track-controls > * { margin-right: .5em }
      #volume > * { vertical-align: middle }
      #track-controls { display: none }
      #track-controls.activeControls { display: flex }
        #track-play:not(.trackPlaying)::before { content: "Play ▶" }
        #track-play.trackPlaying::before { content: "Pause ⏸" }
    nav:focus-within:not(:has(:is(#panic, #volume > input):focus)) > #dropdown,
    body.menuActive #dropdown { display: flex }
    #dropdown {
      display: none;
      background-color: #000 }
      #dropdown > :nth-last-child(n+2) { margin-right: 2em }
        #dropdown > * > * { vertical-align: middle }
      #track-select { flex: 1 }
  menu {
    padding: 0;
    margin: 0;
    min-height: 0;
    display: none }
  body.menuActive > menu { display: block }
    menu > li { padding: .5em }
    menu > li:not(#breadcrumbs) {
      overflow-y: scroll;
      height: calc(100% - 3.4em);
      display: none }
    menu > li.activeMenu { display: list-item !important }
    #breadcrumbs {
      background-color: #ddd;
      color: #222;
      display: flex;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
      #breadcrumb-text { font-size: small }
      #breadcrumb-text::before { content: "// " }
    form {
      display: flex;
      flex-flow: row wrap }
    form { align-items: start }
    form > * {
      width: max-content;
      height: max-content }
      #track-editor > form > * { width: 100% }
      #track-editor > form > :nth-last-child(n+2) { margin-bottom: .5em }
      fieldset {
        display: flex;
        flex-flow: column }
        fieldset > * { margin: .3em }
        input[type="number"] { width: 3.5em }
        #track-file {
          display: flex;
          flex-flow: row }
          #track-file > :nth-last-child(n+2) { margin-right: .5em }
          #track-name { flex: 1 }
          #track-name > * {
            display: none;
            vertical-align: middle }
          #track-name-text { cursor: text }
          #track-name-text:empty::before {
            color: #666;
            content: "..." }
          #track-name:not(.editingTrackName) > #track-name-text,
          #track-name.editingTrackName > input { display: inline }
          #track-name-field.invalid { outline: 1px solid red }
          #track-file:not(.saved) > :is(#track-savestate, #track-delete) { display: none }
          #track-savestate.saving::before {
            content: "...";
            color: orange }
          #track-savestate:not(.saving)::before {
            content: "✓";
            color: lawngreen }
        #track-editor textarea {
          min-width: 30em;
          height: 10em;
          resize: vertical }
  main {
    background-color: #000;
    overflow: hidden }
    canvas {
      width: 100%;
      height: 100% }
  </style>
</head>
<body>
  <nav tabindex="0">
    <div id="dropdown">
      <div id="keyboard-select">
        <span>Keyboard</span>
        <select></select>
        <button id="keyboard-settings-button" type="button">⚙️</button>
      </div>
      <div id="track-select">
        <span>Track</span>
        <select>
          <option name="None">None</option>
          <hr>
          <option name="New">New</option>
        </select>
      </div>
      <button class="info" type="button">ⓘ</button>
    </div>
    <div id="controls">
      <div id="volume">
        <span>Volume</span>
        <input type="range" min="0" max="100" step="1">
      </div>
      <div id="track-controls">
        <button id="track-loop" type="button">Loop</button>
        <button id="track-play" type="button"></button>
      </div>
      <button id="panic" type="button">Panic</div>
    </div>
  </nav>
  <menu>
    <li id="breadcrumbs">
      <span id="breadcrumb-text"></span>
      <div id="menu-actions"></div>
    </li>
    <li id="keyboard-settings">
      <form>
        <fieldset>
          <legend>Shape</legend>
          <label id="gstep">Horizontal steps: <input type="number" min="0" step="1"></label>
          <label id="hstep">Diagonal steps: <input type="number" min="0" step="1"></label>
          <label id="orientation">Orientation:
            <select>
              <option value="">Choose</option>
            </select>
          </label>
          <label id="unit">Key size: <input type="number" min="5" step="1"> px</label>
        </fieldset>
        <fieldset>
          <legend>Note</legend>
          <label id="refNote">Tuning root note: <input type="number" min="0" step="1"></label>
          <label id="freqBasis">Tuning root frequency: <input type="number" min="10" max="40000"> Hz</label>
          <div>Scale:
            <label id="edo">Divisions of octave: <input type="number" min="1" step="1"></label>
            <button type="button">Advanced</button>
          </div>
        </fieldset>
        <fieldset>
          <legend>Waveform</legend>
          <label id="instrument">Output:
            <select>
              <option value="osc">Local</option>
              <option value="midi">MIDI</option>
            </select>
          </label>
          <label id="instrument-option">
            <span>Oscillator</span>
            <select>
              <option value="custom">Custom</option>
            </select>
            <button type="button">Choose</button>
          </label>
        </fieldset>
      </form>
    </li>
    <li id="track-editor">
      <form>
        <div id="track-file">
          <div id="track-name">
            <span id="track-name-text"></span>
            <input id="track-name-field" type="text">
          </div>
          <span id="track-savestate"></span>
          <button class="info" type="button">ⓘ</button>
          <button id="track-delete" type="button">✖</button>
        </div>
        <textarea id="track-edit"></textarea>
      </form>
    </li>
  </menu>
  <main>
    <canvas id="hex"></canvas>
  </main>
  <dialog id="delete-dialog">
    <div>Delete track "<span id="delete-track-name"></span>"?</div>
    <form method="dialog">
      <button type="button" data-action="Cancel">Cancel</button>
      <button type="button" data-action="Delete">Delete</button>
    </form>
  </dialog>
  <template id="menu-action">
    <button type="button"></button>
  </template>
  <template id="option">
    <option></option>
  </template>
  <script src="js/machine.js"></script>
  <script>

//Utils

const clamp = (min, max, val) => Math.max(min, Math.min(max, val)),
      lerp = (a, b, t) => a * (1 - t) + b * t,
      between = (min, max, val) => val <= max && val >= min,
      mod = (n, m) => ((n % m) + m) % m,
      gcd = (a, b) => !b ? a : gcd(b, a % b);

class HexButton {
  #g; #h; #grid; #osc; #volume; #noteClass

  constructor (g, h, noteClass, grid) {
    this.#g = g;
    this.#h = h;
    this.#grid = grid;
    this.#noteClass = noteClass
  }

  static vertices (g, h, grid) {
    const r = grid.r, x = grid.w / 2, y = grid.h / 2,
          k = .5 * Math.sqrt(3),
          origin = [
            [ x, y - r ], [ x - r * k, y - r / 2 ], [ x - r * k, y + r / 2 ],
            [ x, y + r ], [ x + r * k, y + r / 2 ], [ x + r * k, y - r / 2 ]
          ];
    return origin.map(([ a, b ]) => grid.rotate(
      Math.floor(a + r * k * (h + 2 * g)),
      Math.floor(b + 1.5 * r * h)
    ))
  }
  static centre (g, h, grid) {
    const { r, w: width, h: height } = grid, k = .5 * Math.sqrt(3);
    return grid.rotate(
      Math.floor(width / 2 + r * k * (h + 2 * g)),
      Math.floor(height / 2 + 1.5 * r * h)
    )
  }

  vertices () { return HexButton.vertices(this.#g, this.#h, this.#grid) }
  centre () { return HexButton.centre(this.#g, this.#h, this.#grid) }

  neighbours () {
    const g = this.#g, h = this.#h;
    return [
      [ g - 1, h ], [ g, h - 1 ], [ g + 1, h - 1 ],
      [ g + 1, h ], [ g, h + 1 ], [ g - 1, h + 1 ]
    ]
  }

  getCoord () { return [ this.#g, this.#h ] }

  setNoteClass (name) { this.#noteClass = name }
  getColour () { return this.#grid.noteClassColours[this.#noteClass] ?? "#222" }

  note () {
    const n = this.#g * this.#grid.gstep + this.#h * this.#grid.hstep, { edo } = this.#grid;
    return [ Math.floor(n / edo), (n % edo + edo) % edo ]
  }

  start () {
    const { audioctx, masterVolume } = app.state(),
          { edo, freqBasis, refNote } = this.#grid, [ octave, steps ] = this.note(),
          osc = this.#osc = audioctx.createOscillator(),
          volume = this.#volume = audioctx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freqBasis * 2 ** (octave + ((refNote + steps) / edo));
    osc.connect(volume);
    volume.connect(masterVolume);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime)
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime + .05)
    osc.start(audioctx.currentTime)
  }

  stop () {
    const { audioctx } = app.state(), osc = this.#osc, volume = this.#volume;
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime + .05);
    osc.stop(audioctx.currentTime + .05);
    this.#osc = null;
    this.#volume = null
  }

}

class HexGrid {
  w = 0; h = 0; unit = 50; r = this.unit * 2
  edo = 5; gstep = 2; hstep = 1; orientations = []; theta = 0
  #hexes = new Map(); #edges = new Set(); #notes = new Set()
  noteClassColours = { middle: "#333" }
  freqBasis; refNote; orientation

  constructor (opts = {}) {
    Object.assign(this, opts);
    if ("orientation" in opts) this.setOrientation(...opts.orientation)
    // this.#edges.add(this.#newHex(0, 0))
  }

  #newHex (g, h, noteClass) {
    const row = this.#hexes.get(g) ?? this.#hexes.set(g, new Map()).get(g),
          hex = new HexButton(g, h, noteClass, this);
    row.set(h, hex);
    return hex
  }

  getHex (g, h) { return this.#hexes.get(g)?.get(h) }
  hasHex (g, h) { return this.#hexes.get(g)?.has(h) ?? false }

  * [Symbol.iterator] () { for (let [ , row ] of this.#hexes) for (let [ , hex ] of row) yield hex }

  genOrientations () {
    const { gstep, hstep, edo } = this, res = [];
    for (let y = 0; y <= edo / hstep; y++) {
      const x = (edo - hstep * y) / gstep;
      if (x === Math.floor(x)) res.push ([ x, y ])
    }
    this.orientations = res;
  }
  setOrientation (g, h) {
    this.orientation = [ g, h ];
    const { unit, w } = this, x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5;
    this.theta = Math.atan(y / x)
  }

  updateGrid () {
    const { gstep, hstep, edo, w } = this, [ g, h ] = this.orientation,
          octLen = Math.hypot((2 * g + h) * Math.sqrt(3) / 2, h * 1.5);

    // Central line
    this.#edges.add(this.#newHex(0, 0, "middle"));
    this.#notes.add(0);
    let left = .5, right = .5, focus = [ [0, 0], [0, 0] ];
    for (let i = 1; i <= g + h; i++) {
      if (left / i <= h / (g + h)) { left++; focus[0][1]++ } else focus[0][0]++;
      if (right / i < h / (g + h)) { right++; focus[1][1]++ } else focus[1][0]++;
      this.#edges.add(this.#newHex(...focus[0], "middle"));
      this.#notes.add(focus[0][0] * gstep + focus[0][1] * hstep);
      if (focus[0].every((v, i) => v === focus[1][i])) continue
      this.#edges.add(this.#newHex(...focus[1], "middle"));
      this.#notes.add(focus[1][0] * gstep + focus[1][1] * hstep)
    }

    // One octave
    this.fillGrid((g, h, { newNotes }) => HexButton.centre(g, h, this)[0] - this.w / 2 >= 0 &&
      !~[ ...newNotes ].findIndex(note => mod(g * gstep + h * hstep - note, edo) === 0));

    // Fill to sides
    const home = [ ...this ];
    this.fillGrid((g0, h0) => {
      const near = ~home.findIndex(hex => {
              const [ baseG, baseH ] = hex.getCoord();
              return (baseG - g0) * h === (baseH - h0) * g  // require gcd(g, h) === 1
            });
      return near && HexButton.vertices(g0, h0, this).some(([ px, py ]) =>
        px > 0 && px < this.w && py > 0 && py < this.h)
    })
  }

  fillGrid (isInside) {
    let viewEdges = new Set([ ...this.#edges ]);
    while (viewEdges.size > 0) {
      let newEdges = new Set([ ...this.#edges ]),
          newViewEdges = new Set([ ...viewEdges ]),
          newNotes = new Set([ ...this.#notes ]);
      for (let hex of viewEdges) {  // Can I get all candidate new hexes first?
        let remove = true;
        for (let [g, h] of hex.neighbours()) {
          const thisHex = this.getHex(g, h);
          if (thisHex) { if (viewEdges.has(thisHex)) newViewEdges.delete(thisHex) }
          else {
            if (isInside(g, h, { newEdges, newViewEdges, newNotes })) {
              const nextHex = this.#newHex(g, h);
              newViewEdges.add(nextHex);
              newEdges.add(nextHex);
              newNotes.add(g * this.gstep + h * this.hstep)
            } else remove = false;
          }
        }
        newViewEdges.delete(hex)
        if (remove) newEdges.delete(hex)
      }
      viewEdges = newViewEdges;
      this.#edges = newEdges;
      this.#notes = newNotes
    }
  }

  rotate (x, y, rev = false) {
    const cx = this.w / 2, cy = this.h / 2, theta = rev ? -this.theta : this.theta,
          cos = Math.cos(theta), sin = Math.sin(theta);
    return [ cos * (x - cx) + sin * (y - cy) + cx, cos * (y - cy) - sin * (x - cx) + cy ]
  }

  getCoord (x, y) {
    ([ x, y ] = this.rotate(x * 2, y * 2, true));
    const { r, w: width, h: height } = this,
          a = (x - width / 2) / r / Math.sqrt(3) * 2,
          b = (y - height / 2) / r * 2,
          band = Math.floor(Math.floor((b + 1) / 3));
    if (((Math.floor(b % 3)) + 3) % 3 === 1) {
      const clampedA = ((a % 1) + 1) % 1, clampedB = ((b % 1) + 1) % 1,
            topLeft = clampedA + clampedB > 1, bottomLeft = clampedA < clampedB,
            h = 2 * Math.floor((b + 4) / 6), g = Math.floor((a - h) / 2);
      if (band % 2) return Math.floor(a) % 2 ? [ g + 1, h - !topLeft ] : [ g + !bottomLeft, h - !bottomLeft ];
      else return Math.floor(a) % 2 ? [ g + !bottomLeft, h + bottomLeft ] : [ g, h + topLeft ]
    } else return [ Math.floor((a - band + 1) / 2), band ]
  }
}

// Page state
var app = new $.Machine({
    // Navigation
      menuState: [],
      keyboards: {
        "12edo": {
          gstep: 2, hstep: 1, orientations: [[6,0],[5,2],[4,4],[3,6],[2,8],[1,10],[0,12]], orientation: [5, 2], unit: 45,
          refNote: 9, freqBasis: 220, edo: 12, instrument: "triangle"
        },
        "19edo": {
          gstep: 3, hstep: 2, orientations: [[5,2],[3,5],[1,8]], orientation: [5, 2], unit: 45,
          refNote: 14, freqBasis: 220, edo: 19, instrument: "triangle"
        },
        "22edo": {
          gstep: 4, hstep: 1, orientations: [[5,2],[4,6],[3,10],[2,14],[1,18],[0,22]], orientation: [5, 2], unit: 45,
          refNote: 16, freqBasis: 220, edo: 22, instrument: "triangle"
        },
        "31edo": {
          gstep: 5, hstep: 3, orientations: [[5,2],[2,7]], orientation: [5, 2], unit: 45,
          refNote: 23, freqBasis: 220, edo: 31, instrument: "triangle"
        },
        "41edo": {
          gstep: 7, hstep: 3, orientations: [[5,2],[2,9]], orientation: [5, 2], unit: 45,
          refNote: 30, freqBasis: 220, edo: 41, instrument: "triangle"
        },
        "53edo": {
          gstep: 5, hstep: 4, orientations: [[9,2],[5,7],[1,12]], orientation: [5, 7], unit: 45,
          refNote: 39, freqBasis: 220, edo: 53, instrument: "triangle"
        },
        "94edo": {
          gstep: 9, hstep: 7, orientations: [[5,7]], orientation: [5, 7], unit: 45,
          refNote: 69, freqBasis: 220, edo: 94, instrument: "triangle"
        },
      },

    // Keyboard
      keyboardSelection: null,
      keyboard: null,
      gridctx: null,
      hexGrid: null,
      activeHexes: new Map(),
      gridTouches: new Map(),
      mousedown: false,
      audioctx: null,
      masterVolume: null,

      // Track
      tracks: {},
      trackSelection: null
    });

// Events
$.targets({

  load () { app.emit("init") },

  keydown (e) { if (e.key === "Escape") document.activeElement.blur() },

  resize () {
    app.emit("resize");
    app.emit("redraw")
  },

  contextmenu (e) { e.preventDefault() },

  "touchstart touchend touchmove" (e) {
    const nav = $("canvas");
    if (e.type === "touchstart" && document.activeElement === nav && !e.composedPath().includes(nav)) $(nav).blur();
    const canvas = $("canvas");
    if (e.target === canvas) 
      for (let { clientX, clientY, identifier } of e.changedTouches) {
        const x = clientX - canvas.offsetLeft, y = clientY - canvas.offsetTop;
        if ((app.gridTouches.has(identifier) || e.type === "touchstart") &&
          (app.hexGrid.hasHex(...app.hexGrid.getCoord(x, y)) || e.type === "touchend"))
          app.emit("press", e.type.slice(5), x, y, identifier)
      }
  },

  mousedown (e) {
    if (e.target === $("canvas") && app.hexGrid.hasHex(...app.hexGrid.getCoord(e.layerX, e.layerY))) {
      app.mousedown = true;
      app.emit("press", "start", e.layerX, e.layerY)
    }
  },
  mousemove (e) {
    if (app.mousedown && app.hexGrid.hasHex(...app.hexGrid.getCoord(e.layerX, e.layerY)))
      app.emit("press", "move", e.layerX, e.layerY)
  },
  "mouseup mouseout" (e) {
    if (app.mousedown && e.type !== "mouseout") {
      app.mousedown = false;
      app.emit("press", "end", e.layerX, e.layerY)
    }
  },

  app: {

    init () {
      this.canvas = $("#hex");
      new ResizeObserver(() => {
        this.emit("resize")
        this.emit("redraw")
      }).observe($("main"));
      this.gridctx = this.canvas.getContext("2d");
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
      $("#track-select > select").selectedIndex = 0;
      this.emit("load-presets");
      this.emit("load-keyboard")
    },

    "clear-storage" () { localStorage.clear() },

    "load-presets" () {
      // Keyboards
      let keyboards = localStorage.getItem("keyboards");
      if (!keyboards) {
        keyboards = this.keyboards;
        localStorage.setItem("keyboards", JSON.stringify(keyboards))
      } else localStorage.setItem("keyboards", JSON.stringify(keyboards = Object.assign(this.keyboards, JSON.parse(keyboards))));
      Object.keys(keyboards).forEach(name => {
        const el = $.load("option", "#keyboard-select > select")[0][0]
        el.innerText = name;
        el.setAttribute("name", name)
      });
      const customKeybOptEl = $.load("option", "#keyboard-select > select")[0][0]
      customKeybOptEl.innerText = "Custom";
      customKeybOptEl.setAttribute("name", "Custom");

      let keyboardSelection = localStorage.getItem("keyboardSelection");
      if (!keyboardSelection) {
        keyboardSelection = Object.keys(app.keyboards)[0];
        localStorage.setItem("keyboardSelection", keyboardSelection)
      } else keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value = keyboardSelection;
      
      this.keyboard = keyboardSelection === "Custom" ? JSON.parse(localStorage.getItem("keyboard")) : keyboards[keyboardSelection];
      this.emit("fill-keyboard-settings", this.keyboard);

      // Tracks
      let tracks = localStorage.getItem("tracks");
      if (!tracks) {
        this.tracks = tracks = {};
        localStorage.setItem("keyboards", "{}");
      } else this.tracks = tracks = JSON.parse(tracks);
      const trackSelEl = $("#track-select select"), selectHrEl = $("#track-select hr");
      Object.keys(this.tracks).forEach(name => {
        const el = $.load("option", "#track-select > select")[0][0];
        el.innerText = name;
        el.setAttribute("name", name);
        trackSelEl.insertBefore(el, selectHrEl)
      })
    },

    "clear-tracks" () { localStorage.removeItem("tracks") },

    // Keyboard
    "fill-keyboard-settings" ({ unit, edo, gstep, hstep, freqBasis, refNote, orientation, orientations }) {
      $("#gstep > input").value = gstep;
      $("#hstep > input").value = hstep;
      $.all("#orientation > select > *").forEach(el => el.remove());
      orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      });
      $("#orientation > select").options.namedItem(orientation.join(",")).selected = true;
      $("#unit > input").value = unit;
      $("#refNote > input").value = refNote;
      $("#freqBasis > input").value = freqBasis;
      $("#edo > input").value = edo
    },

    "load-keyboard" () {
      let keyboard, unit, edo, gstep, hstep, orientations, orientation, refNote, freqBasis;
      const keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value;
      localStorage.setItem("keyboardSelection", keyboardSelection);
      if (keyboardSelection === "Custom") {
        this.keyboard = {
          unit: $("#unit > input").valueAsNumber,
          edo: $("#edo > input").valueAsNumber,
          gstep: $("#gstep > input").valueAsNumber,
          hstep: $("#hstep > input").valueAsNumber,
          freqBasis: $("#freqBasis > input").valueAsNumber,
          refNote: $("#refNote > input").valueAsNumber,
          orientation: $("#orientation > select").value.split(",").map(v => parseInt(v))
        };
        const hexGrid = this.hexGrid = new HexGrid(this.keyboard);
        hexGrid.genOrientations();
        this.keyboard.orientations = hexGrid.orientations;
      
        localStorage.setItem("keyboard", JSON.stringify(this.keyboard));
      } else {
        keyboard = this.keyboards[keyboardSelection];
        localStorage.removeItem("keyboard");
        this.emit("fill-keyboard-settings", keyboard);

        const hexGrid = this.hexGrid = new HexGrid(keyboard);
        hexGrid.setOrientation(...keyboard.orientation);
      }
      this.emit("resize")
      this.emit("redraw")
    },

    "orientation-change" (g, h) {
      this.hexGrid.setOrientation(g, h);
      this.emit("redraw")
    },

    "change-keyboard-lattice" () {
      $("#keyboard-select > select").value = "Custom";
      this.keyboard = null;
      const { hexGrid } = this.menuState[1],
            gstep = $("#gstep > input").valueAsNumber,
            hstep = $("#hstep > input").valueAsNumber,
            edo = $("#edo > input").valueAsNumber;
      $.all("#orientation > select > *").forEach(el => el.remove());
      if (gcd(gstep, hstep) !== 1) {
        $("#keyboard-settings-apply").disabled = true;
        return
      }
      $("#keyboard-settings-apply").disabled = false;
      hexGrid.gstep = gstep;
      hexGrid.hstep = hstep;
      hexGrid.edo = edo;
      hexGrid.genOrientations();
      const orientation = hexGrid.orientations.find(([g, h]) => g + h === 7) || hexGrid.orientations[0];
      if (!orientation) {
        $("#keyboard-settings-apply").disabled = true;
        return
      }
      hexGrid.setOrientation(...orientation);
      hexGrid.orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      })
    },

    // Track editor
    "track-name-update" (name) {
      const { tracks, trackSelection } = this, trackSelEl = $("#track-select > select");
      if (name === "New" || name in tracks && trackSelEl.value !== name) {
        $("#track-name-field").classList.add("invalid");
        return
      }
      $("#track-file").classList.add("saved");
      delete this.tracks[trackSelection];
      this.tracks[name] = $("#track-edit").value;
      this.trackSelection = name;
      $("#track-name-text").innerText = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name").classList.remove("editingTrackName");
      $(`#track-select option[name='${trackSelection}']`)?.remove();
      const el = $.load("option", "#track-select > select")[0][0];
      el.innerText = name;
      el.setAttribute("name", name);
      trackSelEl.insertBefore(el, $("#track-select hr"));
      el.selected = true;
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
    },

    "track-editor" (name) {
      const { tracks } = this;
      if (!name) {
        const nth = Object.keys(tracks)
                .map(tn => tn.match(/^Untitled( [1-9]\d*)?$/)?.slice(1).map(v => v ? parseInt(v) : 0))
                .flat().sort().findLastIndex((k, i) => k === i) + 1;
        name = "Untitled" + (nth ? " " + nth : "");
        $("#track-edit").value = "";
        $("#track-file").classList.remove("saved")
      } else {
        $("#track-edit").value = tracks[name];
        $("#track-file").classList.add("saved")
      }
      this.trackSelection = name;
      $("#track-name-field").value = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name-text").innerText = name;
      $("#track-name").classList.remove("editingTrackName");
    },

    "track-save" () {
      $("#track-file").classList.add("saved");
      $("#track-savestate").classList.add("saving");
      clearInterval(this.menuState[1].saveDebounce);
      this.menuState[1].saveDebounce = setTimeout(() => {
        localStorage.setItem("tracks", JSON.stringify(this.tracks));
        $("#track-savestate").classList.remove("saving")
      }, 500)
      const trackSelection = $("#track-name-field").value;
      let el;
      if (!(trackSelection in this.tracks)) {
        el = $.load("option", "#track-select > select")[0][0];
        el.innerText = trackSelection;
        el.setAttribute("name", trackSelection);
        $("#track-select select").insertBefore(el, $("#track-select hr"));
        el.selected = true
      } else el = $("#track-select > select").namedItem(trackSelection);
      this.trackSelection = $("#track-name-field").value;
      this.tracks[this.trackSelection] = $("#track-edit").value;
      el.innerText = trackSelection;
      el.setAttribute("name", trackSelection)
    },

    "track-delete" (response) {
      $("#delete-dialog").close(response);
      if (response === "Cancel") return;
      const { tracks, trackSelection } = this;
      delete this.tracks[trackSelection];
      this.trackSelection = null;
      $(`#track-select option[name='${trackSelection}']`).remove();
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
      this.emit("menu-cancel")
    },

    // Menu
    "menu-select" (which, ...data) {
      this.emit("menu-cancel");
      this.menuState = [which];
      $("body").classList.add("menuActive");
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $("#" + which).classList.add("activeMenu");
      let cancelEl, applyEl;
      switch (which) {
        case "keyboard-settings":
          $("#breadcrumb-text").innerText = "Keyboard ⚙️";
          cancelEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(cancelEl, { innerText: "Cancel", id: "keyboard-settings-cancel" });
          applyEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(applyEl, { innerText: "Apply", id: "keyboard-settings-apply" });
          $.queries({
            "#keyboard-settings-cancel": { click () { app.emit("menu-cancel") } },
            "#keyboard-settings-apply": { click () {
              app.hexGrid = app.menuState[1].hexGrid;
              app.emit("load-keyboard");
              app.emit("menu-cancel")
            } }
          });
          this.menuState[1] = { hexGrid: new HexGrid(this.hexGrid) };
          this.emit("fill-keyboard-settings", this.hexGrid);
          break;
        case "track-editor":
          $("#breadcrumb-text").innerText = "Track ✎";
          $("#track-controls").classList.add("activeControls");
          $("#track-select > select").namedItem(data[0] ?? "New").selected = true;
          closeEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(closeEl, { innerText: "Close", id: "track-editor-close" });
          $.queries({ "#track-editor-close": {
            click () { app.emit("menu-cancel") }
          } });
          this.menuState[1] = { saveDebounce: null };
          this.emit("track-editor", ...data)
      }
    },
    "menu-cancel" () {
      $("body").classList.remove("menuActive")
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $.all("#menu-actions > *").forEach(el => el.remove());
      switch(this.menuState[0]) {
        case "track-editor":
          $("#track-controls").classList.remove("activeControls");
          $("#track-select > select").selectedIndex = 0
      }
      this.menuState = []
    },

    "volume-change" (value) { this.masterVolume.gain.value = value / 100 },

    resize () {
      const { canvas, hexGrid } = this, { unit, orientation: [g, h] } = hexGrid,
            x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5,
            { width, height } = canvas.getBoundingClientRect();
      hexGrid.w = canvas.width = width * 2;
      hexGrid.h = canvas.height = height * 2;
      hexGrid.r = Math.min(unit * 2, width / (Math.hypot(x, y) + 2))
    },

    redraw () {
      const { hexGrid, gridctx } = this;
      hexGrid.updateGrid();
      gridctx.reset();
      gridctx.textBaseline = "middle";
      gridctx.font = (.4 * hexGrid.r) + "px sans";
      gridctx.strokeStyle = "#ddd";
      for (let hex of hexGrid) this.emit("colourHex", hex, hex.getColour(), "#ddd")
    },

    colourHex (hex, bgColour, txColour) {
      const { gridctx } = this, vertices = hex.vertices();
      gridctx.beginPath();
      gridctx.moveTo(...vertices[5]);
      for (let [ x, y ] of vertices) gridctx.lineTo(x, y);
      gridctx.fillStyle = bgColour;
      gridctx.fill();
      gridctx.stroke();
      const label = hex.note()[1], [ x, y ] = hex.centre(),
            { width } = gridctx.measureText(label);
      gridctx.fillStyle = txColour;
      gridctx.fillText(label, x - width / 2, y)
    },

    press (type, x, y, id) {
      const { hexGrid, activeHexes, gridTouches } = this,
            coord = hexGrid.getCoord(x, y);
      let hex, ids;
      switch (type) {

        case "start":
          hex = hexGrid.getHex(...coord);
          this.emit("colourHex", hex, "yellow", "#222");
          if (!activeHexes.has(hex)) hex.start();
          activeHexes.set(hex, (activeHexes.get(hex) ?? new Set()).add(id));
          gridTouches.set(id, hex);
          break;

        case "move":
          hex = gridTouches.get(id);
          ids = activeHexes.get(hex);
          if (hex.getCoord().some((v, i) => v !== coord[i])) {
            ids.delete(id);
            if (ids.size === 0) {
              hex.stop();
              activeHexes.delete(hex);
              this.emit("colourHex", hex, hex.getColour(), "#ddd");
            }
            hex = hexGrid.getHex(...coord);
            this.emit("colourHex", hex, "yellow", "#222");
            if (!activeHexes.has(hex)) hex.start();
            activeHexes.set(hex, (activeHexes.get(hex) ?? new Set()).add(id));
            gridTouches.set(id, hex)
          }
          break

        case "end":
          hex = gridTouches.get(id);
          ids = activeHexes.get(hex);
          ids.delete(id);
          if (ids.size === 0) {
            hex.stop();
            activeHexes.delete(hex);
            this.emit("colourHex", hex, hex.getColour(), "#ddd")
          }
          gridTouches.delete(id)
          
      }
    },

    panic () {
      this.audioctx.close();
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
    }
  }
});

$.queries({
  nav: { touchstart (e) { if ($.all("#panic, #volume > input").every(el => e.target !== el)) this.focus() } },
  form: { submit (e) { e.preventDefault() } },
  "#volume > input": { change () { app.emit("volume-change", this.valueAsNumber) } },
  "#panic": { click () { app.emit("panic") } },
  "#keyboard-settings-button": { click () {
    if (app.menuState[0] === "keyboard-settings") app.emit("menu-cancel"); 
    else app.emit("menu-select", "keyboard-settings")
  } },
  "#keyboard-settings > form": { change (e) { $("#keyboard-select > select").value = "Custom" } },
  "#keyboard-select > select": { change () { app.emit("load-keyboard") } },
  ":is(#gstep, #hstep, #edo) > input": { change () { app.emit("change-keyboard-lattice")} },
  "#track-select > select": { change () {
    if (this.value === "None") app.emit("menu-cancel");
    else app.emit("menu-select", "track-editor", ...(this.value === "New" ? [] : [ this.value ]))
  } },
  "#track-name-text": { click () {
    $("#track-name").classList.add("editingTrackName");
    $("#track-name-field").focus()
  } },
  "#track-name-field": { "keyup blur" (e) {
    if (e.type === "blur" || e.key === "Enter") app.emit("track-name-update", this.value = this.value.trim())
  } },
  "#track-edit": { keyup () { app.emit("track-save") } },
  "#track-delete": { click () {
    $("#delete-track-name").innerText = app.trackSelection;
    $("#delete-dialog").showModal()
  } },
  "#delete-dialog button": { click () { app.emit("track-delete", this.dataset.action) } }
})
  </script>
  <noscript><h6>Only viewable with JavaScript enabled.</h6></noscript>
</body>
</html>