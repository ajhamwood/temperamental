<!doctype html>
<html>
<head>
  <title>Temperamental ⁂ Microtonal music explorer</title>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <meta name='keywords' content='music, xenharmony, xenrhythm'>
  <meta name='description' content='Web app for composing, playing, and noodling on microtonal music.'>
  <link rel='icon' type='image/x-icon' href='data:image/x-icon;base64,'>
  <style>
@font-face {
  font-family: HEJI2;
  src: url('fonts/HEJI2Text.woff2') format('woff2'),
       url('fonts/HEJI2Text.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
  unicode-range: U+E260-E266, U+E2C0-E2FA;
  size-adjust: 150%;
  ascent-override: 0%;
  descent-override: 0% }
@font-face {
  font-family: ArbutusSlab;
  src: url('fonts/ArbutusSlab-Regular.woff2') format('woff2'),
       url('fonts/ArbutusSlab-Regular.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap }

@media (min-aspect-ratio: 1) {
  body.menuActive { grid: "nav nav" auto "menu main" 1fr / min-content 1fr }
  menu { max-width: 50dvw }
  #track-editor > form > textarea {
    width: 20em;
    min-width: 10em }
  .interval-display, #mapping { max-width: calc(50dvw - 3.5em - 2px) } }
@media (max-aspect-ratio: 1) {
  body.menuActive { grid: "nav" auto "menu" min-content "main" auto / 100dvw }
  menu { max-height: calc(50dvh - 4.9em) }
  #track-editor > form > textarea {
    width: 100% !important;
    resize: vertical }
  .interval-display, #mapping { max-width: calc(100dvw - 3.5em - 2px) } }

html, body { height: 100dvh }
body, button, select, input, textarea { font-family: HEJI2, ArbutusSlab }
body {
  margin: 0;
  background-color: #222;
  color: #ddd;
  display: grid;
  grid: "nav" auto "main" 1fr / 100dvw;
  overflow: hidden;
  touch-action: none }
  nav {
    grid-area: nav;
    display: flex;
    flex-flow: column }
    nav > * {
      padding: .5em;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
    #controls { display: flex }
      #controls > :nth-child(3) {
        flex: 1;
        text-align: center }
        #controls > :nth-last-child(n+2),
        #track-controls > * { margin-right: .5em }
      #volume > * { vertical-align: middle }
      #track-controls { display: none }
      #track-controls.activeControls { display: flex }
        #track-play:not(.trackPlaying)::before { content: "Play ▶" }
        #track-play.trackPlaying::before { content: "Pause ⏸" }
      #edo-info::after { content: "EDO" }
      #limit-info::after { content: "-limit" }
    nav:focus-within:not(:has(:is(#refresh, #panic, #volume > input):focus)) > #dropdown,
    body.menuActive #dropdown { display: flex }
    #dropdown {
      display: none;
      background-color: #000 }
      #dropdown > :nth-last-child(n+2) { margin-right: 2em }
        #dropdown > * > * { vertical-align: middle }
      #track-select { flex: 1 }
  menu {
    padding: 0;
    margin: 0;
    min-height: 0;
    display: none }
  body.menuActive > menu { display: block }
    menu > li { padding: .5em }
    menu > li:not(#breadcrumbs) {
      overflow-y: scroll;
      height: calc(100% - 3.4em);
      display: none }
    menu > li.activeMenu { display: list-item !important }
    #breadcrumbs {
      background-color: #ddd;
      color: #222;
      display: flex;
      flex-flow: row;
      justify-content: space-between;
      align-items: center }
      #breadcrumb-text { font-size: small }
      #breadcrumb-text::before { content: "// " }
      #breadcrumb-text > :nth-last-child(n+2)::after { content: " ⮞ " }
        #menu-actions > :nth-last-child(n+2) { margin-right: .5em }
    form {
      display: flex;
      flex-flow: row wrap;
      gap: 0 .6em }
      #track-editor > form > * { width: 100% }
      fieldset {
        display: flex;
        flex-flow: column;
        align-items: start;
        flex: auto }
        fieldset > * { padding: .3em }
          input[type="number"] { width: 3.5em }
          :is(#scale, #mapping) > * {
            display: block;
            margin-left: 1em }
            :is(.harmonic, .interval-cell) > button { cursor: pointer }
          #mapping { display: grid }
            .harmonic {
              grid-template-columns: subgrid;
              display: grid !important;
              grid-column: span 9;
              gap: .3em }
              .harmonic > :not(input) { text-align: end }
              .harmonic:not(.prime) > input, .harmonic.prime > span.steps,
              .harmonic.prime.power > input.hcolour  { display: none }
              #error::after { content: "¢" }
          .choice {
            display: flex;
            flex-flow: row;
            gap: .5em }
          .choice input[type="radio"] { display: none }
          .choice > label {
            display: block;
            cursor: pointer }
          .choice > label:active {
            background-color: #ddd;
            color: #222 }
          .choice > label:has(input[type="radio"]:checked) { border-bottom: 1px solid }
          #interval-view {
            display: flex;
            flex-flow: row;
            justify-content: stretch;
            width: 100% }
            #interval-view > div {
              flex: 1;
              text-align: right }
          .interval-display { display: none }
          .choice:has(label#diamond-choice > input[type="radio"]:checked) ~ #diamond-wrapper,
          .choice:has(label#table-choice > input[type="radio"]:checked) ~ #ivtable-wrapper { display: block }
          .interval-display, #mapping { overflow-x: scroll }
            .interval-cell.activeEnharmonic {
              border-bottom: 1px solid;
              margin-bottom: -1px }
          #diamond {
            display: grid;
            grid-template-columns: 1fr repeat(var(--size), auto);
            grid-template-rows: repeat(var(--size), 2em);
            justify-items: end;
            width: max-content }
          #interval-table {
            display: grid;
            grid-template-columns: repeat(calc(var(--harms) + 1), auto);
            grid-template-rows: repeat(calc(var(--edo) + 1), minmax(0, min-content));
            gap: .5em;
            width: max-content }
            .interval-th {
              position: relative;
              display: grid;
              place-items: center }
              .table-border {
                position: absolute;
                z-index: -1 }
              .column-head > span::after { content: "-limit" }
              .column-head > .table-border {
                border-left: 1px solid #ddd8;
                width: calc(100% + .5em);
                align-self: start;
                height: var(--table-height) }
              .row-head > .table-border {
                border-top: 1px solid #ddd8;
                height: calc(100% + .5em);
                justify-self: start;
                width: var(--table-width) }
            .interval-td {
              display: flex;
              flex-flow: column;
              gap: .5em;
              place-self: end / center;
              align-items: end }
            .interval { width: max-content }
              #table-unison {
                text-align: center;
                margin: calc(1px - .25em) 0 calc(1px - .25em) 0;
                background-color: #222;
                width: calc(100% - .25em);
                padding: .25em }
        #commas { display: flex }
          #loading-commas {
            display: none;
            order: 9999 }
          #loading-commas.activeLoading { display: block }
        #track-file {
          display: flex;
          flex-flow: row;
          margin-bottom: .5em }
          #track-file > :nth-last-child(n+2) { margin-right: .5em }
          #track-name { flex: 1 }
          #track-name > * {
            display: none;
            vertical-align: middle }
          #track-name-text { cursor: text }
          #track-name-text:empty::before {
            color: #666;
            content: "..." }
          #track-name:not(.editingTrackName) > #track-name-text,
          #track-name.editingTrackName > input { display: inline }
          #track-name-field.invalid { outline: 1px solid red }
          #track-file:not(.saved) > :is(#track-savestate, #track-delete) { display: none }
          #track-savestate.saving::before {
            content: "...";
            color: orange }
          #track-savestate:not(.saving)::before {
            content: "✓";
            color: lawngreen }
        #track-edit {
          max-width: calc(100dvw - 1.5em);
          height: 10em }
        #insert-accidental {
          display: none;
          margin-top: .5em;
          grid-template-columns: repeat(auto-fill, 3em);
          text-align: center;
          line-height: 3em;
          gap: .5em;
          justify-content: space-evenly }
        #insert-accidental.activeSelect {
          display: grid;
          height: 6.5em;
          overflow: scroll }
          #insert-accidental > * {
            display: inline-block;
            background-color: #fff2;
            border-radius: .5em;
            cursor: pointer }
  main {
    background-color: #000;
    overflow: hidden }
    main.hover { cursor: pointer }
    canvas {
      transform: scale(.5);
      transform-origin: 0 0;
      /* mix-blend-mode: lighten; */
      background-size: cover;
      background-position-y: center }
  dialog { padding: 1em 0 }
    #dialog-prompt { padding: 0 1em }
    dialog > form { justify-content: space-evenly }
  </style>
</head>
<body>
  <nav tabindex="0">
    <div id="dropdown">
      <div id="keyboard-select">
        <span>Keyboard</span>
        <select></select>
        <button id="keyboard-settings-button" type="button">⚙️</button>
      </div>
      <div id="track-select">
        <span>Track</span>
        <select>
          <option name="None">None</option>
          <hr>
          <option name="New">New</option>
        </select>
      </div>
      <button class="info" type="button">ⓘ</button>
    </div>
    <div id="controls">
      <div id="volume">
        <span>Volume</span>
        <input type="range" min="0" max="100" step="1">
      </div>
      <div id="octaves">
        <span>Octaves</span>
        <input type="number" value="2" min="1" max="5" steps="1">
      </div>
      <div id="info">
        <span id="edo-info"></span>
        <span id="limit-info"></span>
      </div>
      <div id="track-controls">
        <button id="track-loop" type="button">Loop</button>
        <button id="track-play" type="button"></button>
      </div>
      <button id="refresh" type="button">Refresh</button>
      <button id="panic" type="button">Panic</button>
    </div>
  </nav>
  <menu>
    <li id="breadcrumbs">
      <span id="breadcrumb-text"></span>
      <div id="menu-actions"></div>
    </li>
    <li id="keyboard-settings">
      <form>
        <fieldset>
          <legend>Shape</legend>
          <label id="gstep">Horizontal steps: <input type="number" min="0" step="1"></label>
          <label id="hstep">Diagonal steps: <input type="number" min="0" step="1"></label>
          <label id="orientation">Orientation:
            <select>
              <option value="">Choose</option>
            </select>
          </label>
          <label id="unit">Key size: <input type="number" min="5" step="1"> px</label>
        </fieldset>
        <fieldset>
          <legend>Note</legend>
          <label id="refNote">Tuning root note: <input type="number" min="0" step="1"></label>
          <label id="freqBasis">Tuning root frequency: <input type="number" min="10" max="40000"> Hz</label>
          <div id="scale">Scale:
            <label id="edo">Divisions of octave: <input type="number" min="1" step="1" max="270"></label>
            <output></output>
          </div>
        </fieldset>
        <fieldset>
          <legend>Harmonic mapping</legend>
          <label id="limit">Harmonic limit: <input type="number" value="9" min="3" step="2"></label>
          <label id="maxerror">Maximum error: <input type="number" value="30" min="0" max="100"> ¢</label>
          <div id="mapping"></div>
          <div id="interval-view" class="choice">
            <label id="diamond-choice"><input type="radio" name="interval-view" checked>Tonality diamond</label>
            <label id="table-choice"><input type="radio" name="interval-view">Interval table</label>
            <div>
              <span>Temperament</span>
              <button id="generate-temperaments" type="button">💡</button>
            </div>
          </div>
          <div id="diamond-wrapper" class="interval-display"><div id="diamond"></div></div>
          <div id="ivtable-wrapper" class="interval-display"><div id="interval-table"></div></div>
        </fieldset>
        <fieldset>
          <legend>Waveform</legend>
          <label id="instrument">Output:
            <select>
              <option value="osc">Local</option>
              <option value="midi">MIDI</option>
            </select>
          </label>
          <label id="instrument-option">
            <span>Oscillator</span>
            <select>
              <option value="custom">Custom</option>
            </select>
            <button type="button">Choose</button>
          </label>
        </fieldset>
      </form>
    </li>
    <li id="temperaments">
      <form>
        <fieldset>
          <legend>Temperament</legend>
          <div id="commas">
            <div id="loading-commas">⌛</div>
          </div>
        </fieldset>
        <fieldset>
          <legend>Chords</legend>
        </fieldset>
      </form>
    </li>
    <li id="track-editor">
      <form>
        <div id="track-file">
          <div id="track-name">
            <span id="track-name-text"></span>
            <input id="track-name-field" type="text">
          </div>
          <span id="track-savestate"></span>
          <button id="toggle-accidentals" type="button"></button>
          <button class="info" type="button">ⓘ</button>
          <button id="track-delete" type="button">✖</button>
        </div>
        <textarea id="track-edit"></textarea>
        <div id="insert-accidental">
          <div></div><div></div><div></div><div></div><div></div><div></div><div></div>
          <div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div>
        </div>
      </form>
    </li>
  </menu>
  <main>
    <canvas id="hex"></canvas>
  </main>
  <dialog id="delete-dialog">
    <div id="dialog-prompt">Delete track "<span id="delete-track-name"></span>"?</div>
    <form method="dialog">
      <button type="button" data-action="Cancel">Cancel</button>
      <button type="button" data-action="Delete">Delete</button>
    </form>
  </dialog>
  <template id="breadcrumb-level">
    <span></span>
  </template>
  <template id="menu-action">
    <button type="button"></button>
  </template>
  <template id="option">
    <option></option>
  </template>
  <template id="harmonic">
    <label class="harmonic">
      <span id="nth-harmonic"></span> harmonic: <input class="steps" type="number" step="1"><span class="steps"></span> steps, <span id="error"></span> error
      <button type="button">▶</button>
      <input class="hcolour" type="color">
    </label>
  </template>
  <template id="interval-cell">
    <div class="interval-cell">
      <span></span> (<span></span>, <span></span> steps) <button type="button">▶</button>
    </div>
  </template>
  <template id="interval-th">
    <div class="interval-th">
      <div class="table-border"></div>
      <span></span>
   </div>
  </template>
  <template id="interval-td">
    <div class="interval-td"> </div>
  </template>
  <template id="comma">
    <div class="comma">
      <span class="ratio"></span> = 1 (<span class="factorisation"></span>), size <span class="size"></span>
    </div>
  </template>
  <script src="js/machine.js"></script>
  <script>



//Utils

const primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 ],

      clamp = (min, max, val) => (max >= min && Number(val) === val) ? Math.max(min, Math.min(max, val)) : undefined,
      lerp = (a, b, t) => a * (1 - t) + b * t,
      between = (min, max, val) => val <= max && val >= min,
      mod = (n, m) => ((n % m) + m) % m,
      gcd = (a, b) => !b ? a : gcd(b, a % b),
      gcd_ = (...ar) => ar.reduce((acc, n) => gcd(acc, n)),
      non2 = h => h / (h & (~(h - 1))),

      group = (ar, cmp = (a, b) => a === b) => ar.reduce((a, v) => {
        const i = a.findIndex(vs => cmp(vs[0], v));  // quadratic in cmp
        return ~i ? a.with(i, a[i].concat([v])) : a.concat([[v]])
      }, []),
      decomp = (...iv) => iv.map(r => {
        let ivh = non2(r), res = [], i = 1;
        while (ivh !== 1) {
          const p = primes[i];
          if (gcd(ivh, p) === 1) i++;
          else { res.push(p); ivh /= p }
        }
        return group(res).map(ar => [ar[0], ar.length])
      }),
      comp = (...iv) => iv.map(ar => ar.reduce((n, [p, rad]) => n * p ** rad, 1)),

      ordinal = (() => {
        const rule = new Intl.PluralRules("en-AU", { type: "ordinal" }),
              suf = new Map([ ["one", "st"], ["two", "nd"], ["few", "rd"], ["other", "th"] ]);
        return n => `${n}${suf.get(rule.select(n))}`
      })(),
      contrast = hc => {
        if (!hc.match(/\p{Hex_Digit}{6}/ug)) return null;
        const [r, g, b] = hc.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
        return r * .299 + g * .587 + b * .114 >= 128 ? "#222222" : "#dddddd"
      },
      colourMix = (hc1, hc2, t) => {
        if (![hc1, hc2].every(hc => hc.match(/\p{Hex_Digit}{6}/ug))) return null;
        const [r1, g1, b1] = hc1.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
        const [r2, g2, b2] = hc2.slice(1).match(/.{2}/g).map(s => parseInt(s, 16));
        return "#" + [[r1, r2], [g1, g2], [b1, b2]].reduce((a, [l, r]) => a + Math.round(lerp(l, r, t)).toString(16), "")
      },
      scaleVolume = value => value && 10 ** (2 * (value / 100 - 1)),

      noteFromFactors = (() => {  // Any way to generalise? Use u/e26c and u/e26d ?
        const pythag = "FCGDAEB".split("").reduce((acc, key, i) => ({ ...acc, [i - 1]: key }), {}),
              hejiRatios = {
                5: [[[3, 4]], [[5, 1]]],
                7: [[], [[3, 2], [7, 1]]],
                11: [[[3, 1], [11, 1]], []],
                13: [[[3, 3]], [[13, 1]]],
                17: [[[3, 7]], [[17, 1]]],
                19: [[[3, 3], [19, 1]], []],
                23: [[[23, 1]], [[3, 6]]],
                29: [[[3, 2], [29, 1]], []],
                31: [[], [[31, 1]]],
                37: [[[37, 1]], [[3, 2]]],
                41: [[[41, 1]], [[3, 4]]],
                43: [[[3, 1], [43, 1]], []],
                47: [[47, 1], [[3, 6]]]
              };
        return factors => {
          let accid = {};
          factors = structuredClone(factors);

          // Factorise out commas
          structuredClone(factors).forEach((d, i) => {
            d.forEach(([p, rad]) => {
              if (p === 3) return;
              const tone = hejiRatios[p].findIndex(side => ~side.findIndex(([q]) => p === q));
              accid[p] = (1 - 2 * (i ^ tone)) * rad;
              hejiRatios[p].forEach((side, j) => side.forEach(([q, qrad]) => {
                const targetSide = i ^ j ^ !tone, k = factors[targetSide].findIndex(([r]) => q === r);
                ~k ? (factors[targetSide][k][1] += qrad * rad) : factors[targetSide].push([q, qrad * rad])
              }))
            })
          });

          // Normalise to Pythagorean key
          factors[1].forEach(([p, rad], i, dc1) => {
            const j = factors[0].findIndex(([q]) => p === q);
            if (!~j) return;
            const qrad = factors[0][j][1];
            if (rad > qrad) factors[1][i][1] -= qrad;
            else factors[1][i] = [];
            if (rad < qrad) factors[0][j][1] -= rad;
            else factors[0].splice(j, 1);
          });
          factors[1] = factors[1].filter(ar => ar.length);

          // Build string
          const tone = factors.findIndex(d => d.length),
                fifths = (1 - 2 * tone) * (~tone ? factors[tone][0][1] : 0),
                sharps = Math.floor((fifths + 1) / 7);
          let acstring = "", pref5 = () => "", prefNo5 = "";
          if (sharps < -2) {
            pref5 = n => ["", String.fromCodePoint(0xe2c1 + n), String.fromCodePoint(0xe2c0 + n)][(sharps === -3) - sharps % 3];
            prefNo5 = ["", String.fromCodePoint(0xe260), String.fromCodePoint(0xe264)][-sharps % 3];
            acstring = sharps === -3 && (5 in accid) ? String.fromCodePoint(0xe264) : String.fromCodePoint(0xe266).repeat(Math.floor(-sharps / 3))
          } else if (sharps > 2) {
            pref5 = n => sharps % 2 ? String.fromCodePoint(0xe2c3 + n) : String.fromCodePoint(0xe2c4 + n);
            prefNo5 = sharps % 2 ? String.fromCodePoint(0xe265) : String.fromCodePoint(0xe263).repeat(2);
            acstring = String.fromCodePoint(0xe263).repeat(Math.floor((sharps - 1) / 2) - !(5 in accid))
          } else {
            pref5 = n => String.fromCodePoint(0xe2c0 + n + (sharps + 2) % 5);
            prefNo5 = sharps === 0 ? "" : String.fromCodePoint(0xe260 + (sharps + 6) % 5)
          }
          if (5 in accid) {
            const arr = accid[5];
            if (Math.abs(arr) <= 3) {
              const arrowsOffset = 5 * (arr > 0 ? 2 * arr - 1 : -2 - 2 * arr);
              acstring += pref5(arrowsOffset);
            } else {
              const arrowsOffset = 5 * (arr > 0 ? 2 * (arr % 3) - 1 : 2 * (-arr % 3) - 2);
              acstring += (arrowsOffset < 0 ? "" : pref5(arrowsOffset)) + String.fromCodePoint(0xe2d6 + 5 * (arr > 0)).repeat(Math.floor(Math.abs(arr) / 3))
            }
          } else acstring = prefNo5 + acstring;
          if (7 in accid) {
            const sep = accid[7];
            acstring += String.fromCodePoint(0xe2e0 + (sep > 0)).repeat(Math.floor((Math.abs(sep) - 1) / 2)) + 
              String.fromCodePoint(0xe2de + (sep > 0) + 2 * Math.abs((sep + 1) % 2));
          }
          Object.keys(hejiRatios).slice(2).forEach((p, i) => acstring += accid[p] > 0 ?
            String.fromCodePoint((i < 7 ? 0xe2e3 : 0xee41) + 2 * i).repeat(accid[p]) :
            String.fromCodePoint((i < 7 ? 0xe2e2 : 0xee40) + 2 * i).repeat(-accid[p]));
          return {
            accid: { "3": fifths, ...accid },
            string: pythag[(((fifths + 1) % 7 + 7) % 7) - 1] + acstring
          };
        }
      })();



// Keyboard grid

class HexButton {
  #g; #h; #grid; #key; #osc; #volume; #noteClass; isGhost

  constructor (g, h, grid, isGhost = false) {
    this.#g = g;
    this.#h = h;
    this.#grid = grid;
    this.isGhost = isGhost
  }

  static vertices (g, h, grid) {
    const { r, w, h: ht, c } = grid, x = w / 2, y = ht / 2, k = .5 * Math.sqrt(3),
          origin = [
            [ x, y - r ], [ x - r * k, y - r / 2 ], [ x - r * k, y + r / 2 ],
            [ x, y + r ], [ x + r * k, y + r / 2 ], [ x + r * k, y - r / 2 ]
          ];
    return origin.map(([ a, b ]) => {
      const [ rx, ry ] = grid.rotate(
              Math.floor(a + r * k * (h + 2 * g)),
              Math.floor(b + 1.5 * r * h)
            );
      return [ rx - c, ry ]
    })
  }
  static centre (g, h, grid) {
    const { r, w: width, h: height, c } = grid, k = .5 * Math.sqrt(3),
          [ rx, ry ] = grid.rotate(
            Math.floor(width / 2 + r * k * (h + 2 * g)),
            Math.floor(height / 2 + 1.5 * r * h)
          );
    return [ rx - c, ry ]
  }

  vertices () { return HexButton.vertices(this.#g, this.#h, this.#grid) }
  centre () { return HexButton.centre(this.#g, this.#h, this.#grid) }

  neighbours () {
    const g = this.#g, h = this.#h;
    return [
      [ g - 1, h ], [ g, h - 1 ], [ g + 1, h - 1 ],
      [ g + 1, h ], [ g, h + 1 ], [ g - 1, h + 1 ]
    ]
  }

  getCoord () { return [ this.#g, this.#h ] }
  getNoteClass () { return this.#noteClass }

  setNoteClass (noteClass) { this.#noteClass = noteClass }
  setKey (key) { this.#key = key }

  note () {
    const n = this.#g * this.#grid.gstep + this.#h * this.#grid.hstep, { edo } = this.#grid;
    return [ Math.floor(n / edo), (n % edo + edo) % edo ]
  }

  colour ({ bgColour, ctx } = {}) {
    ctx ??= app.state().gridctx;
    const { noteColours } = app.state(),
          [ colourBase, oharm, uharm ] = this.#noteClass?.match(/(black|white)(?:(\d{1,2})o)?(?:(\d{1,2})u)?/)?.slice(1) ?? [],
          vertices = this.vertices(), { isGhost } = this,
          drawHex = c => {
            ctx.beginPath();
            ctx.moveTo(...vertices[5]);
            for (let [ x, y ] of vertices) ctx.lineTo(x, y);
            ctx.strokeStyle = isGhost ? c : "#dddddd";
            ctx.fillStyle = isGhost ? "#00000000" : c;
            ctx.lineWidth = isGhost ? 6 : 1;
            ctx.fill();
            ctx.stroke();
          }
    ctx.globalCompositeOperation = isGhost ? "lighten" : "source-over";
    if (bgColour) drawHex(bgColour);
    else if (colourBase) {
      const bc = noteColours[isGhost ? colourBase === "white" ? "black" : "white" : colourBase],
            oc = oharm ? colourMix(bc, noteColours[oharm], .1) : null,
            uc = uharm ? colourMix(bc, noteColours[uharm], .1) : null;
      if (oc && uc) {
        bgColour = colourMix(oc, uc, .5);
        drawHex(colourMix(oc, noteColours.white, .1));
        const [cx, cy] = this.centre();
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, this.#grid.r, 0, Math.PI);
        ctx.closePath();
        ctx.clip();
        drawHex(colourMix(uc, noteColours.black, .1));
        ctx.restore();
      } else drawHex(bgColour = (oc ? colourMix(oc, noteColours.white, .1) : uc ? colourMix(uc, noteColours.black, .1) : bc))
    } else drawHex(bgColour = noteColours.default);
    ctx.font = (isGhost ? "bold  " : "") + (.5 * this.#grid.r) + "px HEJI2, ArbutusSlab";
    const [ x, y ] = this.centre(),
          { label } = this.#key.getLabel(),
          { width } = ctx.measureText(label);
    ctx.fillStyle = isGhost ? bgColour : contrast(bgColour);
    ctx.fillText(label ?? this.note()[1], x - width / 2, y)
  }

  start () {
    const { audioctx, masterVolume, noteColours } = app.state(),
          { edo, freqBasis, refNote } = this.#grid, [ octave, steps ] = this.note(),
          osc = this.#osc = audioctx.createOscillator(),
          volume = this.#volume = audioctx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freqBasis * 2 ** (octave + ((refNote + steps) / edo));
    osc.connect(volume);
    volume.connect(masterVolume);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime)
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime + .05)
    osc.start(audioctx.currentTime)
  }

  stop () {
    const { audioctx } = app.state(),
          osc = this.#osc, volume = this.#volume;
    volume.gain.linearRampToValueAtTime(1, audioctx.currentTime);
    volume.gain.linearRampToValueAtTime(.0001, audioctx.currentTime + .05);
    osc.stop(audioctx.currentTime + .05);
    this.#osc = null;
    this.#volume = null
  }

}

class HexGrid {
  w = 0; h = 0; c; unit = 50; r = this.unit * 2; octLen
  edo = 5; gstep = 2; hstep = 1; orientations = []; theta = 0
  #hexes = new Map(); #edges; #notes; #keys
  active = new Map(); touches = new Map(); scheduled = new Set()
  freqBasis; refNote; orientation
  limit; maxerror
  #bgImgCache

  constructor (opts = {}) {
    Object.assign(this, opts);
    if ("orientation" in opts) this.setOrientation(...opts.orientation)
  }

  #newHex (g, h, isGhost) {
    const row = this.#hexes.get(g) ?? this.#hexes.set(g, new Map()).get(g),
          hex = new HexButton(g, h, this, isGhost);
    row.set(h, hex);
    return hex
  }

  getHex (g, h) { return this.#hexes.get(g)?.get(h) }
  hasHex (g, h) { return this.#hexes.get(g)?.has(h) ?? false }

  * [Symbol.iterator] () { for (let [ , row ] of this.#hexes) for (let [ , hex ] of row) yield hex }

  genOrientations () {
    const { gstep, hstep, edo } = this, res = [];
    for (let y = 0; y <= edo / hstep; y++) {
      const x = (edo - hstep * y) / gstep;
      if (x === Math.floor(x)) res.push ([ x, y ])
    }
    this.orientations = res;
  }
  setOrientation (g, h) {
    this.orientation = [ g, h ];
    const { unit, w } = this, x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5;
    this.theta = Math.atan(y / x)
  }

  updateGrid (force) {
    if (this.#notes && !force) return;
    const { gstep, hstep, edo, c, w, octLen } = this, [ g, h ] = this.orientation;

    // Central line
    this.#hexes = new Map();
    this.#edges = new Set([this.#newHex(0, 0, false)]);
    this.#notes = new Set([0]);
    let left = .5, right = .5, focus = [ [0, 0], [0, 0] ];
    for (let i = 1; i <= g + h; i++) {
      if (left / i <= h / (g + h)) { left++; focus[0][1]++ } else focus[0][0]++;
      if (right / i < h / (g + h)) { right++; focus[1][1]++ } else focus[1][0]++;
      this.#edges.add(this.#newHex(...focus[0], false));
      this.#notes.add(focus[0][0] * gstep + focus[0][1] * hstep);
      if (focus[0].every((v, i) => v === focus[1][i])) continue
      this.#edges.add(this.#newHex(...focus[1], false));
      this.#notes.add(focus[1][0] * gstep + focus[1][1] * hstep)
    }

    // One octave
    const rank = (g, h) => mod(g * gstep + h * hstep, edo),
          dev = coord => Math.abs(this.h / 2 - HexButton.centre(...coord, this)[1]);
    this.fillGrid({
      candidate: (g0, h0) => between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(rank(g0, h0)),
      filter: hexes => group(hexes, ([a, b], [c, d]) => rank(a - c, b - d) === 0)
        .map(enhs => enhs.sort((a, b) => dev(a) > dev(b))[0]),
      isGhost: () => false
    });

    // Two octaves
    this.#notes = new Set();
    this.fillGrid({
      candidate: (g0, h0) => between(w / 2 - c, w / 2 - c + octLen, HexButton.centre(g0, h0, this)[0]) &&
        !this.#notes.has(rank(g0, h0)),
      filter: hexes => group(hexes, ([a, b], [c, d]) => rank(a - c, b - d) === 0)
        .filter(([[g0, h0]]) => !this.#notes.has(rank(g0, h0)))
        .map(enhs => enhs.sort((a, b) => dev(a) > dev(b))[0]),
      isGhost: () => true
    });

    // Fill to sides
    const home = [ ...this ];
    this.fillGrid({
      candidate: (g0, h0) => {
        const homeEquiv = ~home.findIndex(hex => {
                const [ baseG, baseH ] = hex.getCoord();
                return (baseG - g0) * h === (baseH - h0) * g // require gcd(g, h) === 1
              });
        return homeEquiv && HexButton.vertices(g0, h0, this).some(([ px, py ]) =>
          px > 0 && px < this.w && py > 0 && py < this.h)
      },
      isGhost: (g0, h0) => home.find(hex => {
        const [ baseG, baseH ] = hex.getCoord();
        return (baseG - g0) * h === (baseH - h0) * g
      }).isGhost
    })
  }

  async fillGrid ({ candidate, filter = x => x, isGhost }) {
    let viewEdges = new Set([ ...this.#edges ]);
    while (viewEdges.size > 0) {
      let newViewEdges = new Map(), removeViewEdges = new Set(), newNotes = new Set();
      for (let hex of viewEdges) {
        let remove = true;
        for (let [g, h] of hex.neighbours()) {
          const thisHex = this.getHex(g, h);
          if (thisHex) { if (viewEdges.has(thisHex)) removeViewEdges.add(thisHex) }
          else if (candidate(g, h)) {
            newViewEdges.get(g)?.add(h) ?? newViewEdges.set(g, new Set([h]));
            newNotes.add(mod(g * this.gstep + h * this.hstep, this.edo));
          } else remove = false;
        }
        removeViewEdges.add(hex)
        if (remove) this.#edges.delete(hex)
      }
      filter([ ...(function * () {
        for (let [g, s] of newViewEdges) for (let h of s) yield [g, h]
      })() ]).forEach(([g, h]) => {
        const nextHex = this.#newHex(g, h, isGhost(g, h));
        this.#edges.add(nextHex);
        viewEdges.add(nextHex)
      });
      removeViewEdges.forEach(hex => viewEdges.delete(hex));
      this.#notes = new Set([ ...this.#notes, ...newNotes ])
    }
  }

  rotate (x, y, rev = false) {
    const cx = this.w / 2, cy = this.h / 2, theta = rev ? -this.theta : this.theta,
          cos = Math.cos(theta), sin = Math.sin(theta);
    return [ cos * (x - cx) + sin * (y - cy) + cx, cos * (y - cy) - sin * (x - cx) + cy ]
  }

  getCoord (x, y) {
    const { r, w: width, h: height, c } = this;
    ([ x, y ] = this.rotate(x * 2 + c, y * 2, true));
    const a = (x - width / 2) / r / Math.sqrt(3) * 2,
          b = (y - height / 2) / r * 2,
          band = Math.floor(Math.floor((b + 1) / 3));
    if (((Math.floor(b % 3)) + 3) % 3 === 1) {
      const clampedA = ((a % 1) + 1) % 1, clampedB = ((b % 1) + 1) % 1,
            topLeft = clampedA + clampedB > 1, bottomLeft = clampedA < clampedB,
            h = 2 * Math.floor((b + 4) / 6), g = Math.floor((a - h) / 2);
      if (band % 2) return Math.floor(a) % 2 ? [ g + 1, h - !topLeft ] : [ g + !bottomLeft, h - !bottomLeft ];
      else return Math.floor(a) % 2 ? [ g + !bottomLeft, h + bottomLeft ] : [ g, h + topLeft ]
    } else return [ Math.floor((a - band + 1) / 2), band ]
  }

  // TODO for each basis interval in order, primes then nonprimes, until no keys left,
  //   place *all intervals* up/down one basis interval onto new keys until idempotent
  classifyKeys (force) {
    if (this.#keys && !force) return;
    const { edo, hmap } = this,
          [p0, prad] = hmap.length ? decomp(hmap[0][0])[0][0] : [], pstep = hmap[0]?.[1];
    this.#keys = new Map();
    let i = edo - 1, prev, k = 0, result = Array(edo).fill(), prevResult,
        intervals = app.intervals.map(([iv, step]) => [decomp(...iv), step]);
    result[0] = [[[], []]];
    while (i > 0 && (i !== prev || i === edo - 1) && hmap.length) {
      prev = i;
      prevResult = structuredClone(result);
      for (let [[n, d], step] of intervals) {
        let s = mod(step + k / prad * pstep, edo),
            ni = n.findIndex(([p]) => p === p0), nrad = n[ni]?.[1],
            di = d.findIndex(([p]) => p === p0), drad = d[di]?.[1];
        if (prevResult[s] === undefined) (result[s] ??= (i--, [])).push(~di ?
          drad > k ? [n.slice(), d.with(di, [p0, drad - k])] :
            [ drad < k ? [[p0, k - drad]].concat(n) : n.slice(), d.toSpliced(di, 1) ] :
          [ ~ni ? n.with(ni, [p0, nrad + k]) : k ? [[p0, k]].concat(n) : n.slice(), d.slice() ]);
        s = mod(step - k / prad * pstep, edo);
        if (k > 0 && prevResult[s] === undefined) (result[s] ??= (i--, [])).push(~ni ?
          nrad > k ? [n.with(ni, [p0, nrad - k]), d.slice()] :
            [ n.toSpliced(ni, 1), nrad < k ? [[p0, k - nrad]].concat(d) : d.slice() ] :
          [ n.slice(), ~di ? d.with(di, [p0, drad + k]) : k ? [[p0, k]].concat(d) : d.slice() ])
      }
      k += prad
    }
    result.forEach(ivs => ivs?.forEach(iv => iv?.forEach(fs => fs.sort(([a], [b]) => a > b))));
    for (let hex of this) {
      const key = hex.note()[1], labels = [];
      if (result[key] === undefined) hex.setNoteClass("default");
      else for (let i = 0, ivs = result[key]; i < ivs.length; i++) {
        const { accid, string: label } = noteFromFactors(ivs[i]);
        let noteClass = between(6, 10, mod(accid[3], 12)) ? "black" : "white";
        const ot = ivs[i][0].findLast(([p]) => p !== 3);
        if (ot) noteClass += ot[0] + "o";
        const ut = ivs[i][1].findLast(([p]) => p !== 3);
        if (ut) noteClass += ut[0] + "u";
        labels.push({ label, noteClass, interval: ivs[i] })
        if (i) continue;
        hex.setNoteClass(noteClass)
      }
      this.#keys.has(key) ? this.#keys.get(key).addNote(hex) :
        this.#keys.set(key, new HexKey(hex, labels));
      }
  }

  getEnharmonics (key) { return this.#keys.get(key).getLabels() }

  renameKey (key, i) {
    this.#keys.get(key).setLabel(i);
    this.redraw()
  }
  getLabelsFromSteps (steps) { return this.#keys.get(steps).getLabels() }
  getHexFromSteps (steps) { return this.#keys.get(steps).getNotes().find(hex => !hex.isGhost && hex.note()[0] === 0) }

  redraw (force) {
    const { gridctx, canvas } = app.state(), { width, height } = canvas;
    this.updateGrid(force);
    this.classifyKeys(force);
    gridctx.fillStyle = "#000000";
    gridctx.fillRect(0, 0, width, height);
    for (let hex of this) hex.colour();
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(new Blob([blob]));
      canvas.style.backgroundImage = `url('${url}'), url('${this.#bgImgCache}')`;
      this.#bgImgCache = url
    })
  }

  colour () {
    const { gridctx, canvas } = app.state(), { width, height } = canvas;
    gridctx.clearRect(0, 0, width, height);
    for (let [hex] of this.active) hex.colour({ bgColour: app.noteColours.active });
    for (let hex of this.scheduled) hex.colour({ bgColour: app.noteColours.active });
  }
}

class HexChord {
  #hexes
  constructor (...hexes) { this.#hexes = hexes }
  start () { this.#hexes.forEach(hex => hex.start()) }
  stop () { this.#hexes.forEach(hex => hex.stop()) }
  getHexes () { return this.#hexes }
}

class HexKey {
  #labels; #notes; #labelIndex = 0
  constructor (note, labels) {
    this.#notes = new Set([note]);
    note.setKey(this);
    this.#labels = labels
  }
  addNote (note) {
    this.#notes.add(note);
    note.setKey(this)
  }
  getNotes () { return [ ...this.#notes ] }
  getLabels () { return this.#labels.slice() }
  getLabel () { return this.#labels[this.#labelIndex] }
  setLabel (i) { this.#notes.forEach(note => {
    if (i >= this.#labels.length) return false;
    this.#labelIndex = i;
    const { label, noteClass } = this.#labels[i];
    note.setNoteClass(noteClass)
  }) }
}



// Harmonic mapping

class Common {
  static #allPrimes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 ]
  
  static between = (min, max, val) => val <= max && val >= min
  static non2 = h => h / (h & (~(h - 1)))
  static gcd = (a, b) => !b ? a : this.gcd(b, a % b)
  static group = (ar, groupBy = x => x) => ar.reduce((a, v) => {
    const k = groupBy(v);
    a[k] = (a[k] ?? []).concat([v]);
    return a
  }, {})
  static decomp = (...iv) => iv.map(r => { // use 2s?
    let ivh = this.non2(r), raw = [], res = new Map(), i = 1;
    while (ivh !== 1) {
      const p = this.#allPrimes[i];
      if (this.gcd(ivh, p) === 1) i++;
      else { raw.push(p); ivh /= p }
    }
    for (let [ k, v ] of Object.entries(this.group(raw))) res.set(parseInt(k), v.length)
    return res
  })
}

class HarmonicMapping {

  // Static
  static #isPrime (pdec) {
    let sum = 0;
    for (let [, rad] of pdec) sum += rad;
    return sum === 1
  }
  static #transp = mat => Array(mat[0].length).fill()
    .reduce((row, _, i) => row.concat([mat.reduce((cols, row) =>
      cols.concat([row[i]]), [])]), [])

  static #invDet (mat, decs, ps) { // TDOD: use leading value
    const
      rows = mat.length, cols = mat[0].length,
      aug = mat.map((row, i) => row.concat(Array(rows).fill(0).with(i, 1)));
    if (mat.length === 0) return null;
    let det = 1, lcm = 1;
    for (let i = 0; i < rows; i++) {
      if (aug[i][i] === 0) {
        let m = 0;
        for (m = i + 1; m < rows; m++) if (aug[m][i] !== 0) {
          ([ aug[m], aug[i], decs[m], decs[i] ] = [ aug[i], aug[m], decs[i], decs[m] ]);
          for (let j = 0; j < rows; j++)
            ([ aug[j][cols + m], aug[j][cols + i] ] = [ aug[j][cols + i], aug[j][cols + m] ]);
          det = -det;
          break
        }
        if (m === rows) return {}
      }
      const val0 = aug[i][i];
      lcm = val0 / Common.gcd(lcm, val0);
      for (let j = 0; j < rows; j++) if (i !== j) {
        const val1 = aug[j][i], c = Common.gcd(val0, val1);
        if (i < ps.length) det *= val0 / c;
        for (let k = 0; k < rows + cols; k++)
          aug[j][k] = (val0 * aug[j][k] - val1 * aug[i][k]) / c;
      }
    }
    mat = this.#transp(aug);
    det = mat.slice(0, ps.length).reduce((acc, row, i) => acc * row[i], 1) / det
    const degen = aug.findIndex(row => !row.slice(0, cols).some(x => x));
    if (~degen) aug.splice(degen);
    // console.log("==>", JSON.stringify(decs.map(([h]) => h)), aug.map(JSON.stringify));
    return {
      det, lcm,
      mods: aug.slice(0, ps.length).map((row, i) => [ ps[i], lcm / row[i] ]),
      inv: mat.slice(cols, cols + ps.length).map((row, i) => [ decs[i][0], row ]),
      verify: mat.slice(aug.length, cols).map((vec, i) => [ ps[aug.length + i], vec ])
    }
  }

  static * #subsets (args, { minlength = 1, maxlength = args.length } = {}) {
    for (let n = minlength; n <= maxlength; n++) {
      let max = -1, counter = [];
      while (max + n <= args.length) {
        if (~max) yield counter.map(k => args[k]);
        const i = counter.findLastIndex((j, k) => j < max + k);
        if (~i) counter[i]++;
        else counter = Array(n).fill().map((_, j) => j).with(-1, n + max++);
      }
    }
  }

  // Instance
  maxHarmonic = Infinity//app.maxHarmonic; // Where to put primes?
  edo; rawHarmonicList; harmonicList = new Map()
  nonHarmonics = new Set() // Cached blacklist
  #primes; #basisPrimes; params; index; verify; stepsBasis
  #properIntervalSet = new IntervalSet(this); intervalSet = new IntervalSet(this)
  ready = false
  mask // TODO: for temperings

  constructor (rawHarmonicList, edo) { // [ odd ], number
    if (edo < 0 || edo % 1 || rawHarmonicList.some(h => !Common.between(3, this.maxHarmonic, h) || h % 2 !== 1))
      throw new Error("Bad mapping");
    this.edo = edo;
    this.rawHarmonicList = rawHarmonicList;//.sort((a, b) => a > b);

    const
      { true: primeDecs = [], false: compositeDecs = [] } = Common.group(
        Common.decomp(...rawHarmonicList).map((pdec, i) => [ rawHarmonicList[i], pdec ]),
        ([, a]) => HarmonicMapping.#isPrime(a)),
      decs = primeDecs.concat(compositeDecs), ds = decs.map(([h]) => h),
      ps = [ ...decs.reduce((acc, [, pdec]) => {
        for (let [p] of pdec) acc.add(p);
        return acc
      }, new Set()).values() ].sort((a, b) => a > b);
    if (compositeDecs.length) {
      let system, best = 0, dims = -1;
      const cols = ps.length;
      for (let hs of HarmonicMapping.#subsets(decs)) { // TODO: memoise?
        const mat = [], rows = hs.length;
        for (let [, pdec] of hs) mat.push(ps.map(p => pdec.get(p) ?? 0));
        if (rows < cols) mat.splice(Infinity, Infinity, ...Array(cols - rows).fill().map(() => mat.at(-1).slice()));
        if (rows > cols) mat.forEach((row, i) => row.splice(Infinity, Infinity, ...(i < cols ? Array(rows - cols).fill(0) :
          Array(rows - cols).fill(0).with(i - cols, -1))));
        // console.log("<==", mat.map(JSON.stringify));
        const { mods, inv, det, lcm, verify } = HarmonicMapping.#invDet(mat, hs, ps);
        if (det === undefined) continue;
        // console.log(JSON.stringify(hs.map(([h]) => h)), det, Math.abs(det) === 1 ? "is basis" : "is not basis", inv.map(JSON.stringify), mods.map(JSON.stringify),
        //   verify.map(JSON.stringify), JSON.stringify(ps))
        if ((best !== 0 && Math.abs(det) < Math.abs(best)) || (best === 0 && (det !== 0 || inv.length > dims)))
          ([system, best, dims] = [hs, det, inv.length]);
        if (Math.abs(det) === 1) break;
      }
      const
        hs = system.reduce((acc, [h], i) => {
          const j = acc.findIndex(([p]) => p === h);
          ([ acc[i], acc[j] ] = [ acc[j], acc[i] ]);
          return acc
        }, decs),
        rows = hs.length, mat = [];
      for (let [, pdec] of hs) mat.push(ps.map(p => pdec.get(p) ?? 0));
      if (rows > cols) mat.forEach((row, i) => row.splice(Infinity, Infinity, ...(i < cols ? Array(rows - cols).fill(0) :
        Array(rows - cols).fill(0).with(i - cols, -1))));

      // Can I use det to exclude harmonics before running the counting function?
      const { mods, inv, det, lcm, verify } = HarmonicMapping.#invDet(mat, hs, ps);
      // console.log(JSON.stringify(hs.map(([h]) => h)), best, inv.map(JSON.stringify), lcm, mods.map(JSON.stringify), verify.map(JSON.stringify), JSON.stringify(ps));

      this.index = system.map(([h]) => h);
      this.params = ds.filter(d => !~system.findIndex(([h]) => h === d));
      this.#primes = ps;
      this.#basisPrimes = primeDecs.map(([h]) => h).filter(p => !~ps.findIndex(h => h === p));
      // console.log(this.#primes, this.#basisPrimes)

      // if underdetermined, the params must be provided
      // if overdetermined, these components must be verified
      this.verify = (...primeVec) => {
        const
          dps = primeVec.slice(0, decs.length),
          vps = primeVec.slice(decs.length);
        return verify.every(([p, vec], i) => dps.reduce((a, x, j) => a + x * vec[j] * (mods[j]?.[1] ?? 1), 0) === vps[i])
      };

      inv.forEach(([h, vec]) => this.harmonicList.set(h, new Harmonic(this, h,
        (...params) => {
          const rawNum = hs.reduce((a, _, i) => a + (params[i] ?? 0) * vec[i] * (mods[i]?.[1] ?? 1), 0);
          return rawNum % lcm ? null : rawNum / lcm // Null means failure
        }), true));
      decs.filter(([d]) => !~inv.findIndex(([h]) => h === d))
        .forEach(([h]) => this.harmonicList.set(h, new Harmonic(this, h, this.countingFn(h), true)));

      // Generate all intervals
      const withUnison = [1].concat(ds);
      for (let n of withUnison) for (let d of withUnison) {
        const params = Array(this.params.length).fill(0);
        // params[this.params.findIndex(h => h === n)] = 1;
        // params[this.params.findIndex(h => h === d)] = -1;
        const iv = new Interval(this, n, d, params, true);
        this.#properIntervalSet.add(iv);
        this.intervalSet.add(iv)
      }
    } else {}
    this.ready = true
  }
  countingFn (n, d) { //Null is failure
    const pdec = Common.decomp(n)[0];
    if (d) {
      for (let [p, rad] of Common.decomp(d)[0]) if (pdec.has(p)) { // TODO move to Interval
        const nrad = pdec.get(p);
        if (nrad === rad) pdec.delete(p);
        else pdec.set(p, nrad - rad)
      } else pdec.set(p, -rad)
    }
    const
      { params, index, harmonicList, verify } = this,
      primes = this.#primes, basisPrimes = this.#basisPrimes,
      countingFns = new Map();
    for (let p of basisPrimes) {
      if (!pdec.has(p)) continue;
      else countingFns.set(p, () => pdec.get(p));
      pdec.delete(p)
    }
    const primeVec = primes.map(p => pdec.get(p) ?? 0);
    for (let [p] of pdec) if (!~primes.findIndex(q => q === p)) return null;
    if (!verify(...primeVec)) return null;
    return basisPrimes.concat(index).reduce((fn, h) => (...params) => {
      const acc = fn(...params);
      if (acc === null) return null;
      const res = harmonicList.get(h).countingFn(...primeVec, ...params);
      return res === null ? null : acc.concat([res])
    }, () => [])
  }
  getProperIntervals () { return [ ...this.#properIntervalSet ] }
  addInterval (interval) { intervalSet.add(interval) }
  setSteps (stepsMap) {  // Map([[ harmonic, steps ]])
    const { index } = this;
    if (index.some(h => {
      const s = stepsMap.get(h);
      return s === undefined || s < 0 || s % 1
    })) throw new Error("Could not set steps for mapping");
    this.stepsBasis = stepsMap
  }
}

class Harmonic {
  #mapping; h; isBasis; countingFn
  constructor (mapping, h, countingFn, isInitial = false) {
    const existing = mapping.harmonicList.get(h);
    if (existing) return existing;
    this.#mapping = mapping;
    this.h = h;
    // Unison
    if (h === 1) {
      this.isBasis = false;
      this.countingFn = () => Array(mapping.index.length).fill(0)
    } else {
      const
        { harmonicList, nonHarmonics, index, ready } = mapping,
        doErr = () => { throw new Error("Harmonic not in mapping") };
      if (ready) {
        countingFn = mapping.countingFn(h);
        if (nonHarmonics.has(h) || countingFn === null) doErr();
        this.isBasis = false;
      } else this.isBasis = Boolean(~index.findIndex(v => v === h));
      this.countingFn = countingFn
    }

  }
}

class Interval { // Check to add noteFromFactors
  #mapping; n; d; params; octave; fraction; decomp; noteSpelling; isProper
  octaveAdjust
  constructor (mapping, n, d, params, isProper) {
    const c = Common.gcd(n, d);
    n = n / c;
    d = d / c;
    if (mapping.intervalSet.hasRatio(n, d)) return mapping.intervalSet.getRatio(n, d);
    this.n = Common.non2(n);
    this.d = Common.non2(d);
    const octave = this.octave = Math.floor(Math.log2(n) - Math.log2(d));
    this.octaveAdjust = octave;
    this.#mapping = mapping;
    this.params = params;
    this.isProper = isProper;
    this.fraction = [ octave < 0 ? n << -octave : n, octave > 0 ? d << octave : d ];
    this.decomp = mapping.countingFn(n, d)(...params);
    // this.noteSpelling = noteFromFactors([ n.primeDecomp, d.primeDecomp ])
  }
  withOctave (n) {
    this.octaveAdjust = n;
    return this
  }
  steps () {
    const { index, stepsBasis, edo } = this.#mapping;
    return this.decomp.reduce((acc, rad, i) => acc + stepsBasis.get(index[i]) * rad, 0) + this.octaveAdjust * edo
  }
}

class IntervalSet {
  #mapping; #rawMap // Map([[ number, Map([ number, interval ]) ]])
  constructor (mapping, intervalList = []) {
    this.#mapping = mapping;
    this.#rawMap = new Map();
    for (let interval of intervalList) this.add(interval)
  }
  add (interval) {
    const { harmonicList } = this.#mapping,
          { n, d } = interval, c = Common.gcd(n, d),
          nMap = this.#rawMap.get(n / c) ?? this.#rawMap.set(n / c, new Map()).get(n / c);
    if (!nMap.has(d / c)) nMap.set(d / c, interval)
  }
  has (interval) {
    const { n, d } = interval;
    return Boolean(this.#rawMap.get(n)?.has(d))
  }
  hasRatio (n, d) { return Boolean(this.#rawMap.get(Common.non2(n))?.has(Common.non2(d))) }
  get (interval) {
    const { n, d } = interval;
    return this.#rawMap.get(n)?.get(d)
  }
  getRatio (n, d) {
    const iv = this.#rawMap.get(Common.non2(n))?.get(Common.non2(d));
    if (iv === undefined) return iv;
    return iv.withOctave(Math.log2(n * iv.d / d / iv.n))
  }
  * [ Symbol.iterator ] () { for (let [g, s] of this.#rawMap) for (let [h, iv] of s) yield iv }
}



// Page state

var app = new $.Machine({
    // Navigation
      menuState: [],
      keyboards: {
        "12edo": {
          gstep: 2, hstep: 1, orientations: [[6,0],[5,2],[4,4],[3,6],[2,8],[1,10],[0,12]], orientation: [5, 2], unit: 45,
          refNote: 9, freqBasis: 220, edo: 12, limit: 9, maxerror: 33, hmap: [[3, 7], [5, 4], [7, 10]], instrument: "triangle"
        },
        "19edo": {
          gstep: 3, hstep: 2, orientations: [[5,2],[3,5],[1,8]], orientation: [5, 2], unit: 45,
          refNote: 14, freqBasis: 220, edo: 19, limit: 9, maxerror: 21, hmap: [[3, 11], [5, 6]], instrument: "triangle"
        },
        "22edo": {
          gstep: 4, hstep: 1, orientations: [[5,2],[4,6],[3,10],[2,14],[1,18],[0,22]], orientation: [5, 2], unit: 45,
          refNote: 16, freqBasis: 220, edo: 22, limit: 9, maxerror: 18, hmap: [[3, 13], [5, 7], [7, 18]], instrument: "triangle"
        },
        "31edo": {
          gstep: 5, hstep: 3, orientations: [[5,2],[2,7]], orientation: [5, 2], unit: 45,
          refNote: 23, freqBasis: 220, edo: 31, limit: 9, maxerror: 12, hmap: [[3, 18], [5, 10], [7, 25]], instrument: "triangle"
        },
        "41edo": {
          gstep: 7, hstep: 3, orientations: [[5,2],[2,9]], orientation: [5, 2], unit: 45,
          refNote: 30, freqBasis: 220, edo: 41, limit: 9, maxerror: 9, hmap: [[3, 24], [5, 13], [7, 33]], instrument: "triangle"
        },
        "53edo": {
          gstep: 5, hstep: 4, orientations: [[9,2],[5,7],[1,12]], orientation: [5, 7], unit: 45,
          refNote: 39, freqBasis: 220, edo: 53, limit: 9, maxerror: 7, hmap: [[3, 31], [5, 17], [7, 43]], instrument: "triangle"
        },
        "94edo": {
          gstep: 9, hstep: 7, orientations: [[5,7]], orientation: [5, 7], unit: 45,
          refNote: 69, freqBasis: 220, edo: 94, limit: 9, maxerror: 4, hmap: [[3, 55], [5, 30], [7, 76]], instrument: "triangle"
        },
      },

      // Keyboard
      octaves: null,
      noteColours: {
        default: "#333333", active: "#ffff00",
        white: "#222222", black: "#777777",
        5: "#ff0000", 7: "#0000ff", 11: "#00ff00", 13: "#ff00ff"
      },
      keyboardSelection: null,
      canvas: null,
      gridctx: null,
      hexGrid: null,
      getGridScope: () => app.menuState.at(-2) === "keyboard-settings" ? app.menuState[1] : app,
      mousedown: false,
      audioctx: null,
      masterVolume: null,

      // Harmony
      maxHarmonic: 51,
      temperings: null,
      intervals: null,

      // Track
      tracks: {},
      trackSelection: null
    });



// Events

$.targets({

  load () { app.emit("init") },

  keydown (e) { if (e.key === "Escape") document.activeElement.blur() },

  resize () {
    app.emit("resize", true);
    app.getGridScope().hexGrid.redraw(true)
  },

  contextmenu (e) { e.preventDefault() },

  "touchstart touchend touchmove" (e) {
    const nav = $("nav");
    if (e.type === "touchstart" && document.activeElement === nav && !e.composedPath().includes(nav)) $(nav).blur();
    const canvas = $("canvas");
    if (e.target === canvas) 
      for (let { clientX, clientY, identifier } of e.changedTouches) {
        const x = clientX - canvas.offsetLeft, y = clientY - canvas.offsetTop,
              { hexGrid } = app.getGridScope();
        if (hexGrid && (hexGrid.touches.has(identifier) || e.type === "touchstart") &&
          (hexGrid.hasHex(...hexGrid.getCoord(x, y)) || e.type === "touchend"))
          app.emit("press", e.type.slice(5), x, y, identifier)
      }
  },

  mousedown (e) {
    const { hexGrid } = app.getGridScope();
    if (e.target === $("canvas") && hexGrid.hasHex(...hexGrid.getCoord(e.layerX / 2, e.layerY / 2))) {
      app.mousedown = true;
      app.emit("press", "start", e.layerX / 2, e.layerY / 2)
    }
  },
  mousemove (e) {
    const { hexGrid } = app.getGridScope(),
          hover = hexGrid.hasHex(...hexGrid.getCoord(e.layerX / 2, e.layerY / 2));
    $("main").classList.toggle("hover", hover);
    if (app.mousedown && hover)
      app.emit("press", "move", e.layerX / 2, e.layerY / 2)
  },
  "mouseup mouseout" (e) {
    if (app.mousedown && e.type !== "mouseout") {
      app.mousedown = false;
      app.emit("press", "end", e.layerX / 2, e.layerY / 2)
    }
  },

  document: { fonts: { loadingdone () {
    app.emit("resize", true);
    app.getGridScope().hexGrid.redraw(true)
  } } },

  app: {

    init () {
      this.canvas = $("#hex");
      this.gridctx = this.canvas.getContext("2d");
      new ResizeObserver(() => {
        this.emit("resize", true);
        this.getGridScope().hexGrid.redraw(true)
      }).observe($("main"));
      const ivTable = $("#interval-table");
      new ResizeObserver(() => {
        const { width, height } = ivTable.getBoundingClientRect();
        ivTable.style.setProperty("--table-width", Math.round(width) + "px");
        ivTable.style.setProperty("--table-height", Math.round(height) + "px")
      }).observe(ivTable);
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = scaleVolume($("#volume > input").valueAsNumber);
      $("#limit").max = this.maxHarmonic;
      this.octaves = $("#octaves > input").valueAsNumber;
      $("#track-select > select").selectedIndex = 0;
      this.emit("load-presets")
    },

    "clear-storage" () { localStorage.clear() },

    "load-presets" () {

      // Keyboards
      let keyboards = localStorage.getItem("keyboards");
      if (!keyboards) {
        keyboards = this.keyboards;
        localStorage.setItem("keyboards", JSON.stringify(keyboards))
      } else localStorage.setItem("keyboards", JSON.stringify(keyboards = Object.assign(this.keyboards, JSON.parse(keyboards))));
      Object.keys(keyboards).forEach(name => {
        const el = $.load("option", "#keyboard-select > select")[0][0]
        el.innerText = name;
        el.setAttribute("name", name)
      });
      const customKeybOptEl = $.load("option", "#keyboard-select > select")[0][0]
      customKeybOptEl.innerText = "Custom";
      customKeybOptEl.setAttribute("name", "Custom");
      customKeybOptEl.disabled = true;

      let keyboardSelection = localStorage.getItem("keyboardSelection");
      if (!keyboardSelection) {
        keyboardSelection = Object.keys(app.keyboards)[0];
        localStorage.setItem("keyboardSelection", keyboardSelection)
      } else keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value = keyboardSelection;
      
      let keyboard = keyboardSelection === "Custom" ? JSON.parse(localStorage.getItem("keyboard")) : keyboards[keyboardSelection];
      $("#edo-info").innerText = keyboard.edo;
      $("#limit-info").innerText = keyboard.limit;

      let hmap = new Map(keyboard.hmap.map(([k, v]) => [parseInt(k), v])),
          hs = Array((keyboard.limit + 1) / 2).fill().map((_, i) => [ 2 * i + 1, decomp(2 * i + 1)[0].reduce((s, [p, rad]) => s + hmap.get(p) * rad, 0) % keyboard.edo ]);
      this.intervals = group(hs.reduce((acc, [n, i]) => acc.concat(hs.map(([d, j]) => {
        const oct = Math.floor(Math.log2(n) - Math.log2(d)), c = gcd(n, d);
        return [oct > 0 ? [n / c, (d / c) << oct] : oct < 0 ? [(n / c) << -oct, d / c] : [n / c, d / c], (i - j + keyboard.edo) % keyboard.edo]
      })), []), ([[a, b]], [[c, d]]) => a * d === b * c).map(([v]) => v);

      this.emit("fill-keyboard-settings", keyboard);
      app.getGridScope().hexGrid = new HexGrid(keyboard);

      let noteColours = localStorage.getItem("noteColours");
      if (!noteColours) {
        noteColours = this.noteColours;
        localStorage.setItem("noteColours", JSON.stringify(noteColours))
      } else localStorage.setItem("noteColours", JSON.stringify(this.noteColours = JSON.parse(noteColours)));      

      // Tracks
      let tracks = localStorage.getItem("tracks");
      if (!tracks) {
        this.tracks = tracks = {};
        localStorage.setItem("tracks", "{}");
      } else this.tracks = tracks = JSON.parse(tracks);
      const trackSelEl = $("#track-select select"), selectHrEl = $("#track-select hr");
      Object.keys(this.tracks).forEach(name => {
        const el = $.load("option", "#track-select > select")[0][0];
        el.innerText = name;
        el.setAttribute("name", name);
        trackSelEl.insertBefore(el, selectHrEl)
      })

    },

    resize (reset) {
      const { hexGrid } = this.getGridScope(),
            { canvas, octaves } = this, { unit, orientation: [g, h], theta } = hexGrid,
            x = (2 * g + h) * Math.sqrt(3) / 2, y = h * 1.5,
            { width, height } = $("main").getBoundingClientRect(),
            r = hexGrid.r = Math.min(unit * 2, width / (Math.hypot(x, y) * octaves + 2) * 2);
      if (reset) {
        hexGrid.w = canvas.width = Math.ceil(width) * 2,
        hexGrid.h = canvas.height = Math.ceil(height) * 2;
        this.gridctx.textBaseline = "middle"
      }
      hexGrid.c = (octaves % 2) * Math.hypot(x, y) * r / 2;
      hexGrid.octLen = Math.hypot(x, y) * r;
      canvas.style.setProperty("width", Math.ceil(width));
      canvas.style.setProperty("height", Math.ceil(height));
    },

    press (type, x, y, id) {
      const { hexGrid } = this.getGridScope(),
            { active, touches } = hexGrid,
            coord = hexGrid.getCoord(x, y), [g, h] = coord;
      let hex, ids;
      switch (type) {
        case "start":
          hex = hexGrid.getHex(...coord);
          if (!active.has(hex)) hex.start();
          active.set(hex, (active.get(hex) ?? new Set()).add(id));
          touches.set(id, hex);
          hexGrid.colour();
          break;
        case "move":
          hex = touches.get(id);
          ids = active.get(hex);
          if (hex.getCoord().some((v, i) => v !== coord[i])) {
            ids.delete(id);
            if (ids.size === 0) {
              hex.stop();
              active.delete(hex)
            }
            hex = hexGrid.getHex(...coord);
            if (!active.has(hex)) hex.start();
            active.set(hex, (active.get(hex) ?? new Set()).add(id));
            touches.set(id, hex);
            hexGrid.colour()
          }
          break;
        case "end":
          hex = touches.get(id);
          ids = active.get(hex);
          ids.delete(id);
          if (ids.size === 0) {
            hex.stop();
            active.delete(hex)
          }
          touches.delete(id)
          hexGrid.colour()
      }
    },

    panic () {
      this.audioctx.close();
      const audioctx = this.audioctx = new AudioContext(),
            masterVolume = this.masterVolume = audioctx.createGain();
      masterVolume.connect(audioctx.destination);
      masterVolume.gain.value = $("#volume > input").valueAsNumber / 100;
    },



    // Keyboard

    "fill-keyboard-settings" ({
      unit, edo, gstep, hstep, freqBasis, refNote,
      orientation, orientations, limit, maxerror, hmap }) {
      $("#gstep > input").value = gstep;
      $("#hstep > input").value = hstep;
      $.all("#orientation > select > *").forEach(el => el.remove());
      orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      });
      $("#orientation > select").options.namedItem(orientation.join(",")).selected = true;
      $("#unit > input").value = unit;
      $("#refNote > input").value = refNote;
      $("#freqBasis > input").value = freqBasis;
      $("#edo > input").value = edo;
      $("#scale > output").value = `One step of ${edo}edo = ${(1200 / edo).toFixed(2)}¢`;
      $("#limit > input").value = limit;
      $("#maxerror > input").value = maxerror
    },

    "load-keyboard" () {
      keyboardSelection = this.keyboardSelection = $("#keyboard-select > select").value;
      let keyboard = {};
      localStorage.setItem("keyboardSelection", keyboardSelection);
      if (keyboardSelection === "Custom") {
        [ "unit", "edo", "gstep", "hstep", "refNote", "freqBasis", "limit", "maxerror" ]
          .forEach(dataname => keyboard[dataname] = $(`#${dataname} > input`).valueAsNumber);
        keyboard.orientation = $("#orientation > select").value.split(",").map(v => parseInt(v));
        keyboard.hmap = $.all(".harmonic.prime > input.steps").map(el => [parseInt(el.parentElement.dataset.harm), el.valueAsNumber]);
        const hexGrid = this.getGridScope().hexGrid = new HexGrid(keyboard);
        hexGrid.genOrientations();
        keyboard.orientations = hexGrid.orientations;
      
        localStorage.setItem("keyboard", JSON.stringify(keyboard))
      } else {
        $("#keyboard-select > select").namedItem("Custom").disabled = true
        keyboard = this.keyboards[keyboardSelection];
        localStorage.removeItem("keyboard");
        
        const hexGrid = this.getGridScope().hexGrid = new HexGrid(keyboard);
        hexGrid.setOrientation(...keyboard.orientation);
        this.emit("fill-keyboard-settings", hexGrid);
      }
      $("#edo-info").innerText = keyboard.edo;
      $("#limit-info").innerText = keyboard.limit;
      this.emit("update-mapping")
    },

    "change-keyboard-edo" () {
      const edo = $("#edo > input").valueAsNumber;
      $("#refNote > input").value = Math.round(Math.log2(5 / 3) * edo);
      $("#scale > output").value = `One step of ${edo}edo = ${(1200 / edo).toFixed(2)}¢`;
      $("#maxerror > input").value = Math.floor(400 / edo);
      this.emit("change-keyboard-lattice");
      this.emit("update-mapping")
    },

    "change-keyboard-lattice" () {
      const { hexGrid } = this.getGridScope(),
            gstep = $("#gstep > input").valueAsNumber,
            hstep = $("#hstep > input").valueAsNumber,
            edo = $("#edo > input").valueAsNumber;
      $.all("#orientation > select > *").forEach(el => el.remove());
      if (gcd(gstep, hstep) !== 1) {
        $("#keyboard-settings-apply").disabled = true;
        return
      }
      $("#keyboard-settings-apply").disabled = false;
      Object.assign(hexGrid, { gstep, hstep, edo });
      hexGrid.genOrientations();
      const orientation = hexGrid.orientations.find(([g, h]) => g + h === 7) || hexGrid.orientations[0];
      if (!orientation) {
        $("#keyboard-settings-apply").disabled = true;
        return
      }
      hexGrid.setOrientation(...orientation);
      hexGrid.orientations.forEach(coord => {
        const el = $.load("option", "#orientation > select")[0][0];
        el.innerText = coord;
        el.setAttribute("name", coord)
      })
      $("#orientation > select").namedItem(orientation).selected = true
    },



    // Harmonic mapping

    "update-mapping" () {
      const limit = $("#limit > input").valueAsNumber,
            maxerror = $("#maxerror > input").valueAsNumber,
            edo = $("#edo > input").valueAsNumber,
            { hexGrid } = this.getGridScope();
      $.all(".harmonic").forEach(el => el.remove());
      let hmap = new Map();

      // Harmonics
      for (let i = 3; i <= limit; i += 2) {
        const just = Math.log2(i) % 1,
              isComp = decomp(i)[0].reduce((s, [p, r]) => s + r * hmap.has(p), 0) > 1,
              steps = isComp ?
                decomp(i)[0].reduce((acc, [p, rad]) => {
                  const [pp, pr] = Array(rad).fill().map((_,i) => [p ** (i + 1), i + 1]).find(([pp]) => hmap.get(pp))
                  return acc + hmap.get(pp) * (rad / pr)
                }, 0) % edo :
                clamp(Math.ceil((just - maxerror / 1200) * edo), Math.floor((just + maxerror / 1200) * edo), hmap.get(i)) ?? Math.round(just * edo),
              error = (steps / edo - just) * 1200;
        if (!isComp) hmap.set(i, steps);
        if (Math.abs(error) >= maxerror || steps + edo * maxerror / 1200 < 1 || steps - edo * maxerror / 1200 > edo - 1) {
          hmap.delete(i);
          continue;
        }
        const labelEl = $.load("harmonic", "#mapping")[0][0],
              inputEl = $("input.steps", labelEl),
              compositeEl = $("span.steps", labelEl),
              errorEl = $("#error", labelEl),
              colourEl = $("input.hcolour", labelEl);
        labelEl.dataset.harm = i;
        $("#nth-harmonic", labelEl).innerText = ordinal(i);
        inputEl.setAttribute("value", steps);
        inputEl.setAttribute("min", Math.max(1, Math.ceil((just - maxerror / 1200) * edo)));
        inputEl.setAttribute("max", Math.min(edo - 1, Math.floor((just + maxerror / 1200) * edo)));
        if (isComp) compositeEl.innerText = steps;
        else {
          labelEl.classList.add("prime");
          if (decomp(i)[0][0][1] > 1) labelEl.classList.add("power");
        }
        errorEl.innerText = error.toFixed(2);
        if (i === 3) {
          colourEl.value = this.noteColours.white;
          labelEl.appendChild(colourEl.cloneNode()).value = this.noteColours.black;
        } else colourEl.value = this.noteColours[i] ??= this.noteColours.default;
        $.queries({
          "input.steps": { change () { app.emit("update-mapping") } },
          "input.hcolour": { change () { app.emit("set-colour", i, this.value, this === $.all("input.hcolour")[1]) } },
          button: (chord => ({
            pointerdown (e) {
              const { hexGrid: grid } = app.getGridScope();
              let enhi = grid.getEnharmonics(steps).findIndex(({ interval }) => comp(interval[0])[0] === i && interval[1].length === 0);
              ~enhi && grid.renameKey(steps, enhi);
              chord = new HexChord([ ...grid ][0], grid.getHexFromSteps(steps));
              this.setPointerCapture(e.pointerId); chord.start();
              chord.getHexes().forEach(hex => grid.scheduled.add(hex));
              grid.colour();
            },
            pointerup (e) {
              const { hexGrid: grid } = app.getGridScope();
              chord.getHexes().forEach(hex => grid.scheduled.delete(hex));
              grid.colour();
              this.releasePointerCapture(e.pointerId); chord.stop()
            }
          }))()
        }, labelEl)
      }
      Object.assign(hexGrid, { limit, maxerror, edo, hmap: [...hmap] });

      // Tonality diamond
      const diamondEl = $("#diamond");
      $.all(":scope > *", diamondEl).forEach(el => el.remove());
      const temperings = this.temperings = $.all(".harmonic").map(el => [ parseInt(el.dataset.harm), $("input", el).valueAsNumber ])
              .sort(([p], [q]) => Math.log2(p) % 1 > Math.log2(q) % 1),
            h = temperings.length;
      diamondEl.style.setProperty("--size", 2 * h + 1);
      for (let i = 0; i <= h; i++) {
        const cell = $.load("interval-cell", "#diamond")[0][0],
              [ interval, note, width, button ] = $.all(":scope > *", cell);
        cell.style.gridArea = `${h + 1}/${2 * i + 1}/span 1/span 2`;
        interval.innerHTML = "<sup>1</sup>/<sub>1</sub>";
        note.innerText = "C";
        width.innerText = button.dataset.steps = 0
        button.dataset.interval = "1/1";
      }
      const ivs = [[[1,1],0]];
      for (let i = h; i > 0; i--) for (let j = 0; j < i; j++) {
        const upperCell = $.load("interval-cell", "#diamond",)[0][0],
              lowerCell = $.load("interval-cell", "#diamond",)[0][0],
              [ upperInterval, upperNote, upperWidth, upperButton ] = $.all(":scope > *", upperCell),
              [ lowerInterval, lowerNote, lowerWidth, lowerButton ] = $.all(":scope > *", lowerCell),
              num = h - i + j, den = j - 1,
              octave = Math.floor(Math.log2(temperings[num][0] / (temperings[den]?.[0] ?? 1))),
              div = gcd(temperings[num][0], (temperings[den]?.[0] ?? 1)),
              upNum = temperings[num][0] * (octave < 0 ? 2 ** -octave : 1) / div,
              upDen = (temperings[den]?.[0] ?? 1) * (octave < 0 ? 1 : 2 ** octave) / div,
              loNum = (temperings[den]?.[0] ?? 1) * (octave < -1 ? 1 : 2 ** (octave + 1)) / div,
              loDen = temperings[num][0] * (octave < -1 ? 2 ** (-octave - 1) : 1) / div,
              upSteps = (temperings[num][1] - (temperings[den]?.[1] ?? 0) + edo) % edo,
              loSteps = (edo - upSteps) % edo;
        upperCell.style.gridArea = `${i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        lowerCell.style.gridArea = `${2 * h + 2 - i}/${h - i + 2 + 2 * j}/span 1/span 2`;
        if (!~ivs.findIndex(([n, d]) => n === upNum && d === upDen)) ivs.push([[upNum, upDen], upSteps]);
        if (!~ivs.findIndex(([n, d]) => n === loNum && d === loDen)) ivs.push([[loNum, loDen], loSteps]);
        upperInterval.innerHTML = `<sup>${upNum}</sup>/<sub>${upDen}</sub>`;
        lowerInterval.innerHTML = `<sup>${loNum}</sup>/<sub>${loDen}</sub>`;
        upperNote.innerText = noteFromFactors(decomp(upNum, upDen)).string;
        lowerNote.innerText = noteFromFactors(decomp(loNum, loDen)).string;
        upperButton.dataset.interval = `${upNum}/${upDen}`;
        lowerButton.dataset.interval = `${loNum}/${loDen}`;
        upperWidth.innerText = upperButton.dataset.steps = upSteps;
        lowerWidth.innerText = lowerButton.dataset.steps = loSteps
      }
      this.intervals = group(ivs, ([[a, b]], [[c, d]]) => a * d === b * c).map(([v]) => v).sort(([, a], [, b]) => a > b);
      app.emit("resize", true);
      hexGrid.redraw(true)

      // Interval table
      const ivTable = $("#interval-table");
      $.all(":scope > *", ivTable).forEach(el => el.remove());
      const hs = [...hmap.keys()];
      ivTable.style.setProperty("--harms", hs.length);
      ivTable.style.setProperty("--edo", edo);
      tableLegendEl = $.load("interval-th", "", ivTable)[0][0].innerHTML = "Steps";
      hs.forEach((p, k) => {
        const el = $.load("interval-th", "", ivTable)[0][0];
        el.classList.add("column-head");
        el.style.gridColumnStart = k + 2;
        $("span", el).innerText = p
      })
      for (k = 0; k < edo; k++) {
        const el = $.load("interval-th", "", ivTable)[0][0];
        el.classList.add("row-head");
        el.style.gridRowStart = k + 2;
        $("span", el).innerText = k
      }
      for (let steps = 0; steps < edo; steps++) hexGrid.getLabelsFromSteps(steps)
        .forEach(({ interval: iv, label, noteClass }) => {
          const [ n, d ] = iv.map(side => side.reduce(([big, log], [p, rad]) =>
                  [big * BigInt(p) ** BigInt(rad), log + Math.log2(p) * rad], [1n, 0]))
                  .reduce(([bn, ln], [bd, ld]) => {
                    const oct = BigInt(Math.floor(ln - ld));
                    return [oct < 0 ? bn << -oct : bn, oct > 0 ? bd << oct : bd]
                  }),
                curh = noteClass.match(/\d{1,2}/g)
                  ?.map(s => parseInt(s)).sort((a, b) => a < b)[0] ?? (steps ? 3 : 1);
          let td = $(`.interval-td[data-cell="${steps},${curh}"]`);
          if (!td) {
            td = $.load("interval-td", "", ivTable)[0][0];
            td.style.gridArea = steps === 0 ?
              `2/2/span 1/span ${hs.length}` :
              `${steps + 2}/${hs.findIndex(h => h % curh === 0) + 2}`;
            td.dataset.cell = `${steps},${curh}`
          }
          const cell = $.load("interval-cell", "", td)[0][0],
                [ interval, note, width, button ] = $.all(":scope > *", cell);
          if (steps === 0) cell.id = "table-unison";
          interval.innerHTML = `<sup>${n}</sup>/<sub>${d}</sub>`;
          note.innerText = label;
          width.innerText = button.dataset.steps = steps
          button.dataset.interval = `${n}/${d}`;
        })

      // Play interval buttons
      $.queries({
        '.interval-display button[data-steps="0"]': (hex => ({
          pointerdown (e) {
            this.setPointerCapture(e.pointerId);
            if (this.closest("#diamond"))
              $.all('.interval-display button[data-steps="0"]').forEach(el => el.parentElement.classList.add("activeEnharmonic"));
            const { hexGrid: grid } = app.getGridScope();
            (hex = [ ...grid ][0]).start();
            grid.scheduled.add(hex);
            grid.colour();
          },
          pointerup (e) {
            $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
            hex.stop();
            const { hexGrid: grid } = app.getGridScope();
            grid.scheduled.delete(hex);
            grid.colour();
            this.releasePointerCapture(e.pointerId);
          }
        }))(),
        '.interval-display button:not([data-steps="0"])': (chord => ({
          pointerdown (e) {
            this.setPointerCapture(e.pointerId);
            const { hexGrid: grid } = app.getGridScope(),
                  steps = parseInt(this.dataset.steps),
                  [n, d] = this.dataset.interval.split("/").map(v => non2(parseInt(v))),
                  enhi = grid.getEnharmonics(steps).findIndex(({ interval: iv }) => comp(iv[0])[0] === n && comp(iv[1])[0] === d);
            $.all(`button[data-steps="${steps}"]`, this.closest(".interval-display"))
              .forEach(el => el.parentElement.classList.add("activeEnharmonic"));
            ~enhi && grid.renameKey(steps, enhi);
            chord = new HexChord([ ...grid ][0], app.getGridScope().hexGrid.getHexFromSteps(steps));
            chord.start();
            chord.getHexes().forEach(hex => grid.scheduled.add(hex));
            grid.colour();
          },
          pointerup (e) {
            $.all(".activeEnharmonic").forEach(el => el.classList.remove("activeEnharmonic"));
            const { hexGrid: grid } = app.getGridScope();
            chord.stop();
            chord.getHexes().forEach(hex => grid.scheduled.delete(hex));
            grid.colour();
            this.releasePointerCapture(e.pointerId);
          }
        }))()
      })
    },

    "set-colour" (harm, colour, isBlackKeys) {
      if (harm === 3) this.noteColours[isBlackKeys ? "black" : "white"] = colour;
      else this.noteColours[harm] = colour;
      localStorage.setItem("noteColours", JSON.stringify(this.noteColours));
      this.getGridScope().hexGrid.redraw()
    },



    // Temperaments

    "generate-temperaments" () {

    },



    // Track editor

    "track-name-update" (name) {
      const { tracks, trackSelection } = this, trackSelEl = $("#track-select > select");
      if (name === "New" || name in tracks && trackSelEl.value !== name) {
        $("#track-name-field").classList.add("invalid");
        return
      }
      $("#track-file").classList.add("saved");
      delete this.tracks[trackSelection];
      this.tracks[name] = $("#track-edit").value;
      this.trackSelection = name;
      $("#track-name-text").innerText = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name").classList.remove("editingTrackName");
      $(`#track-select option[name='${trackSelection}']`)?.remove();
      const el = $.load("option", "#track-select > select")[0][0];
      el.innerText = name;
      el.setAttribute("name", name);
      trackSelEl.insertBefore(el, $("#track-select hr"));
      el.selected = true;
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
    },

    "track-editor" (name) {
      const { tracks } = this;
      if (!name) {
        const nth = Object.keys(tracks)
                .map(tn => tn.match(/^Untitled( [1-9]\d*)?$/)?.slice(1).map(v => v ? parseInt(v) : 0))
                .flat().sort().findLastIndex((k, i) => k === i) + 1;
        name = "Untitled" + (nth ? " " + nth : "");
        $("#track-edit").value = "";
        $("#track-file").classList.remove("saved")
      } else {
        $("#track-edit").value = tracks[name];
        $("#track-file").classList.add("saved")
      }
      this.trackSelection = name;
      $("#track-name-field").value = name;
      $("#track-name-field").classList.remove("invalid");
      $("#track-name-text").innerText = name;
      $("#track-name").classList.remove("editingTrackName");
    },

    "track-save" () {
      $("#track-file").classList.add("saved");
      $("#track-savestate").classList.add("saving");
      clearInterval(this.menuState[1].saveDebounce);
      this.menuState[1].saveDebounce = setTimeout(() => {
        localStorage.setItem("tracks", JSON.stringify(this.tracks));
        $("#track-savestate").classList.remove("saving")
      }, 500)
      const trackSelection = $("#track-name-field").value;
      let el;
      if (!(trackSelection in this.tracks)) {
        el = $.load("option", "#track-select > select")[0][0];
        el.innerText = trackSelection;
        el.setAttribute("name", trackSelection);
        $("#track-select select").insertBefore(el, $("#track-select hr"));
        el.selected = true
      } else el = $("#track-select > select").namedItem(trackSelection);
      this.trackSelection = $("#track-name-field").value;
      this.tracks[this.trackSelection] = $("#track-edit").value;
      el.innerText = trackSelection;
      el.setAttribute("name", trackSelection)
    },

    "track-delete" (response) {
      $("#delete-dialog").close(response);
      if (response === "Cancel") return;
      const { tracks, trackSelection } = this;
      delete this.tracks[trackSelection];
      this.trackSelection = null;
      $(`#track-select option[name='${trackSelection}']`).remove();
      localStorage.setItem("tracks", JSON.stringify(this.tracks));
      this.emit("menu-cancel")
    },



    // Menu

    "menu-select" (which, ...data) {
      const breadcrumbText = {
              "keyboard-settings": "Keyboard ⚙️",
              "temperaments": "Temperament 💡",
              "track-editor": "Track ✎"
            };
      this.emit("menu-cancel");
      this.menuState = which.concat([null]);
      const menuLeaf = which.at(-1);
      $("body").classList.add("menuActive");
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $("#" + menuLeaf).classList.add("activeMenu");
      $.all("#breadcrumb-text > *").forEach(el => el.remove());
      which.forEach((level, i) => {
        const levelEl = $.load("breadcrumb-level", "#breadcrumb-text")[0][0];
        levelEl.innerText = breadcrumbText[level];
        if (i < which.length - 1) levelEl.dataset.menu = which.toSpliced(i + 1)
      });
      $.queries({ "#breadcrumbs > :nth-last-child(n+2)": { click () {
        app.emit("menu-select", this.dataset.menu.split(","))
      } } });
      let cancelEl, applyEl;
      switch (menuLeaf) {
        case "keyboard-settings":
          cancelEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(cancelEl, { innerText: "Cancel", id: "keyboard-settings-cancel" });
          applyEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(applyEl, { innerText: "Apply", id: "keyboard-settings-apply" });
          $.queries({
            "#keyboard-settings-cancel": { click () { app.emit("menu-cancel") } },
            "#keyboard-settings-apply": { click () {
              app.hexGrid = app.menuState[1].hexGrid;
              app.emit("load-keyboard");
              app.emit("menu-cancel")
            } }
          });
          this.menuState[1] = { hexGrid: new HexGrid(this.hexGrid) };
          this.emit("fill-keyboard-settings", this.hexGrid);
          this.emit("update-mapping");
          break;
        case "temperaments":
          this.emit("generate-temperaments")
          break;
        case "track-editor":
          $("#track-controls").classList.add("activeControls");
          $("#track-select > select").namedItem(data[0] ?? "New").selected = true;
          closeEl = $.load("menu-action", "#menu-actions")[0][0];
          Object.assign(closeEl, { innerText: "Close", id: "track-editor-close" });
          $.queries({ "#track-editor-close": {
            click () { app.emit("menu-cancel") }
          } });
          this.menuState[1] = { saveDebounce: null };
          this.emit("track-editor", ...data)
      }
    },
    "menu-cancel" () {
      $("body").classList.remove("menuActive")
      $("menu > .activeMenu")?.classList.remove("activeMenu");
      $.all("#menu-actions > *").forEach(el => el.remove());
      switch(this.menuState[0]) {
        case "track-editor":
          $("#track-controls").classList.remove("activeControls");
          $("#track-select > select").selectedIndex = 0
      }
      this.menuState = [];
      this.emit("resize", true);
      this.getGridScope().hexGrid.redraw(true)
    },

    "volume-change" (value) { this.masterVolume.gain.value = scaleVolume(value) }

  }
});



// Elements

$.queries({

  nav: { touchstart (e) { if ($.all("#refresh, #panic, #volume > input").every(el => e.target !== el)) this.focus() } },
  form: { submit (e) { e.preventDefault() } },
  "#volume > input": { change () { app.emit("volume-change", this.valueAsNumber) } },
  "#octaves > input": { change () {
    app.octaves = this.valueAsNumber;
    app.emit("resize", true);
    app.getGridScope().hexGrid.redraw(true)
  } },
  "#refresh": { click () {
    app.emit("resize", true);
    app.getGridScope().hexGrid.redraw(true)
  } },
  "#panic": { click () { app.emit("panic") } },

  "#keyboard-settings-button": { click () {
    if (app.menuState[0] === "keyboard-settings") app.emit("menu-cancel"); 
    else app.emit("menu-select", [ "keyboard-settings" ])
  } },
  "#keyboard-settings > form": { change (e) { $("#keyboard-select > select").value = "Custom" } },
  "#keyboard-select > select": { change () { app.emit("load-keyboard") } },
  "#edo > input": { change () {
    app.emit("change-keyboard-edo");
    app.emit("resize", true);
    app.getGridScope().hexGrid.redraw(true);
    this.focus()
  } },
  ":is(#gstep, #hstep) > input": { change () {
    app.emit("change-keyboard-lattice");
    const selEl = $("#orientation > select");
    if (selEl.children.length) {
      app.emit("resize", true);
      app.getGridScope().hexGrid.redraw(true);
      selEl.showPicker();
    }
  } },
  "#orientation > select": { change () {
    const { hexGrid } = app.getGridScope();
    hexGrid.setOrientation(...JSON.parse(`[${this.value}]`));
    app.emit("resize", true);
    hexGrid.redraw(true);
    this.focus()
  } },
  "#unit > input": { change () {
    const { hexGrid } = app.getGridScope();
    hexGrid.unit = this.valueAsNumber;
    app.emit("resize", true);
    hexGrid.redraw(true)
  } },
  ":is(#limit, #maxerror) > input": { change () { app.emit("update-mapping") } },
  "#generate-temperaments": { click () { app.emit("menu-select", [ "keyboard-settings", "temperaments" ]) } }, 

  "#track-select > select": { change () {
    if (this.value === "None") app.emit("menu-cancel");
    else app.emit("menu-select", [ "track-editor" ], ...(this.value === "New" ? [] : [ this.value ]))
  } },
  "#track-name-text": { click () {
    $("#track-name").classList.add("editingTrackName");
    $("#track-name-field").focus()
  } },
  "#track-name-field": { "keyup blur" (e) {
    if (e.type === "blur" || e.key === "Enter") app.emit("track-name-update", this.value = this.value.trim())
  } },
  "#track-delete": { click () {
    $("#delete-track-name").innerText = app.trackSelection;
    $("#delete-dialog").showModal()
  } },
  "#delete-dialog button": { click () { app.emit("track-delete", this.dataset.action) } },
  "#track-edit": { keyup () { if (this.value !== app.tracks[app.trackSelection]) app.emit("track-save") } },
  "#toggle-accidentals": { click () { $("#insert-accidental").classList.toggle("activeSelect") } },
  "#insert-accidental > *": { click () {
    const { value } = $("#track-edit"), editorEl = $("#track-edit"), selStart = editorEl.selectionStart;
    $("#track-edit").value = value.slice(0, selStart) + this.innerText + value.slice(editorEl.selectionEnd)
    if ($("#track-edit").value !== app.tracks[app.trackSelection]) app.emit("track-save")
    editorEl.setSelectionRange(selStart + 1, selStart + 1);
    editorEl.focus()
  } }

})
  </script>
  <noscript><h6>Only viewable with JavaScript enabled.</h6></noscript>
</body>
</html>